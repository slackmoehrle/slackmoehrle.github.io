{"./":{"url":"./","title":"Introduction","keywords":"","body":"Cocos Creator 3D User Manual Welcome to the Cocos Creator 3D user manual! This manual includes detailed instructions, a workflow for users, and a step-by-step tutorial for beginners. This manual canan help you quickly learn how to develop cross-platform games with Cocos Creator 3D. Note: please select the corresponding manual version in the upper right corner according to the Cocos Creator 3D version you are using. General guide Use the feature map to quickly understand engine features: Function Map Graphics rendering Material Lighting Particle System UI system Animation System Audio Physical Simulation Scripting Guide and Event System Components Assets Scene and Environment Settings Beginner's guide Novice Dashboard Hello world! Quick start: making your first game Caution Editor manual Quick Start Panel Introduction Project Preview Debugging Particle Editor Animation System Terrain System Build release Engine Manual Scenes and Environment Lighting Material Sound Particle Animation Easy Physics UI Components Scripting Guide and Event Mechanism Resource Manual Demo and example projects Show example collection: From the use of basic components to the display of rendering effects, this project includes multiple scenarios with different functions and multiple Game Demo for user reference One step and two steps: This is the Quick Start document Step-by-step explanation of the game Physics car: Demo of racing games Demo, based on the physics system, contains the basic gameplay of racing games Falling ball: Demo of falling ball game Demo, based on the physics system, completed the basic gameplay of falling ball game Rolling Ball: Demo of physics-based object movement Demo, which moves the object by applying force to the object Engulfing Black Hole: Devouring Game Demo Demo Simple-Games：Simple games demo, users can use this case study to complete some simple and famous games. Module display collection: The example project of each function of the engine, which basically covers most of the function modules of the engine. Users can refer to it when using the functions Development in this project UI Show Demo: Demo of various UI components combined use Demo Note: the above items will be updated from time to time. Their default branch on GitHub is master, which generally corresponds to the latest Cocos Creator 3D version. If you are still using an older version of Cocos Creator 3D, these projects may not open, try to switch to the same named branch as the old version. "},"getting-started/dashboard/":{"url":"getting-started/dashboard/","title":"Dashboard","keywords":"","body":"Use Dashboard The Dashboard is the starting page, you can browse, create, and import projects. Interface Overview Open project Select Open Project from the tab bar. New Project Select New Project from the tab bar. Next, select a project template and path, and click the New Project button below. Help Select Help from the tab bar to help you get an initial understanding of Cocos Creator 3D. "},"getting-started/attention/":{"url":"getting-started/attention/","title":"Caution!","keywords":"","body":"Precautions Syntax format Cocos Creator 3D and Cocos Creator use a different syntax format. Cocos Creator 3D has full support for ES6 and TypeScript. Therefore, Cocos Creator 3D only supports ES6 and TypeScript classes. In addition, we also support TypeScript syntax hints. Cocos Creator supports only ES5 classes. Please keep this precaution in mind. "},"editor/":{"url":"editor/","title":"Editor Introduction","keywords":"","body":"Editor interface introduction This chapter will introduce the editor interface, familiarize developers with the various panels, menus and buttons that make up the editor. The Cocos Creator 3D editor consists of multiple panels, which can be freely moved and customized to suit the needs of different projects and the preferences of developers. The default editor layout will be used as an example to quickly browse the names and functions of the various panels: Scene Editor The Scene Editor is a working area for displaying and editing visual content in a Scene. The WYSIWYG scene construction work is completed by the display in the Scene Editor. For details, please read the Scene Editor documentation. Hierarchy Manager The Hierarchy Manager shows all the nodes in the Scene and their hierarchical relationship is displayed in the form of a tree view. All the content in the Scene Editor can be found in the corresponding node entry in the Hierarchy Manager. The contents of the two panels will be displayed simultaneously. Generally, we will also use these two panels to build the Scene at the same time. For more details, please read the Hierarchy Manager documentation. Asset Panel The Asset Panel displays all assets in the project asset folder (assets). Here the folders will be displayed in a tree structure and the changes to the contents of the project asset folder in the operating system will be automatically synchronized. You can drag and drop files directly from outside the project, or use the menu to import assets. For details, please read the [asset Manager] (assets / index.md) section. Property inspector Property Inspector is the work area where we view and edit the properties of the currently selected node and component. This panel will display and edit the attribute data from the script definition in the most suitable form. For details, please read the [Property Inspector] (inspector / index.md) section. Console Console will display errors, warnings, or log information generated by other editors and engines. Please read the [Console] (console / index.md) section for details. Animation Editor Animation Editor Can edit and store animation data. For details, please read the [Familiar with Animation Editor] (../animation/index.md) section. Preferences Preferences provides various personalized global settings for various editors, including native development environment, game preview, and global settings for other plugins. Please read the [Preferences] (preferences / index.md) section for details. Project Settings Project Settings provides various project-specific personalized settings, including group management, module settings, project preview, custom engine, etc. For details, please read the [Project Settings] (project / index.md) section. "},"editor/scene/":{"url":"editor/scene/","title":"Scene Editor","keywords":"","body":"Scene Editor Scene Editor is the core working area of content creation, You will use it to choose an place the scene image, character, effect, UI and other game elements. in this working area, you can select and use transform tool to change the position, rotation, scale, size and other attributes of node, also you will preview the WYSIWYG scene. View Introduction Navigation There are some differences between 3D view and 2D view navigation. you can change between 3D view and 2D view by click the 3D/2D button on the toolbar.3D view is used for 3D scene editing，2D is used for UI,Sprite editing. 3D View In 3D view, you can move and rotate view of Scene Editor by following operations: left mouse button + Alt：rotate editor camera around view center. middle mouse button：pan view. mouse scroll：move editor camera back and forth. right mouse button + WASD：wandering in scene editor. F shortcut：focus editor to the selected node. 2D View In 2D view, you can move and rotate view of Scene Editor by following operations: middle mouse button：pan view. mouse scroll：scale view based on the current mouse position。 right mouse button：pan view. F shortcut：focus editor to the selected node. Coordinate System And Grid The Grid in a scene is an important reference information for us to layout scene elements. For information on relationship between coordinate system and node attributes, like position, please read Transform documentation. Scene Gizmo The Scene Gizmo is in the upper-right corner of the Scene view. It indicates the view direction of editor camera in Scene view. You can change view direction quickly by clicking on it. Click on the six arrows, you can change to the top, down, left, right, front, back views separately. Click on the cube in the center, you can switch between ortho camera mode and perspective camera mode. Selecting a node The node will be selected upon left-clicking the mouse on the node in Scene Editor. You can use transform tools (like position, rotation) to do basic node operations when it is selected. Gizmo Operation Introduction The main function of Scene Editor is to edit and arrange the visible elements in the scene and get a WYSIWYG scene immediately, we mainly use Gizmo tools to assist in the visual editing of the scene。 Transform Gizmo Camera Gizmo Light Gizmo Collider Gizmo ParticleSystem Gizmo "},"editor/hierarchy/":{"url":"editor/hierarchy/","title":"Hierarchy Manager","keywords":"","body":"Hierarchy Panel Hierarchy Manager is the panel used to show the hierarchical relationship of most nodes in the current scene. There are some nodes in the scene that do not need to be displayed, which are generally the necessary factors to support the display of the scene, but they are not operable and can be ignored by the user. If there is a plug-in, you can see the details of the plug-in. You can select, create, move, rename or delete nodes in the Hierarchy Manager. Any node can create a child node. The coordinate system of the child node is relative to the parent node. Hierarchy Manager introduction Hierarchy Manager contains a top menu area and a bottom tree list area on the panel: The functions of the top menu are: New Node Button, Search Type Button, Search Box, Fold All or Expand Button, Refresh List Button. The tree-like list area at the bottom mainly reflects the hierarchical relationship of nodes. The root node is scene node. When editing the prefab file, is the root node scene node, but the top node of itself. There is a blank area with a height of 20px at the end of the tree-shaped area. Click here to uncheck, that is, the Hierarchy Manager can have no selected items. The panel supports right-click menus, and the content of right-click menus in different positions and nodes will be different. The panel supports keyboard shortcuts: Copy: Ctrl or Cmd + C Paste: Ctrl or Cmd + V Duplicate: Ctrl or Cmd + D, Ctrl + drag node Delete: Delete Up and down selection: up and down arrows Collapse of nodes: left arrow or Backspace Expansion of nodes: right arrow or Enter Multi-select: Ctrl or Cmd + click Multi-select: Shift + click Rename: Enter/F2 Cancel: input: Esc New Node Click the New Node button When adding a node, a input box will appear first. It is required to fill in the name of the node. The name of the node is allowed to be empty. If an item is not selected in the tree list, it will be newly created at the current root node by default. If there are multiple selected items, it will be newly created at the first selected node. In addition, there is a New entry in the right-click menu of the node. For the UI node, in order for it to display properly, at least one of its superior nodes must contain a cc.UITransformComponent component, so when it is created, if it does not meet the rules, it will assist in adding a Canvas node as Its parent. In addition, a node can be generated by dragging a prefab asset from the Asset Manager to Hierarchy Manager. You can generate a asset by dragging a prefab node into the Asset Manager through the Hierarchy Manager. Moving a Node The movement is divided into moved node and target placement node, in which the height of target placement node is identified in three parts: upper, middle, and lower. These indicate: On the upper side, move the moved node above the target placement node, the two are level. In the middle, move the moved node to the target placement node, at the end. On the lower side, move the moved node below the target placement node, the two are level. Searching for a Node The search types are: search name, search UUID, search path and search component name. search component name is the search node component. The component name can be viewed in Property Inspector, as cc.ModelComponent. Search box is searched in real time. When a node is selected in the search results, after clearing the search content, it will be relocated to the selected node. Renaming a node Select a node, press the shortcut key Enter or F2, or right-click the menu and selectg Rename to modify. The node name is allowed to be empty, press the shortcut key Esc to cancel this rename. Different nodes can have the same name. "},"editor/assets/":{"url":"editor/assets/","title":"Assets","keywords":"","body":"Explorer The Asset Manager panel is an important tool used to access and manage project assets. When starting to make a game, importing assets is usually a necessary step. You can use the Hello World template project as a starting point when creating a new project. After you create and open a new project, various types of assets are visible in the Explorer panel. Explorer Panel introduction The Explorer panel is the main panel. It has a heads-up menu area, a central tree list area, and a bottom information display area. The functions of the heads-up menu area are: New asset button, Sort by button, Search type button, Search box, Fold or expand all button, and Refresh list button The central tree list area mainly reflects the hierarchical relationship of assets. The root node is the asset root folder corresponding to the file manager of the operating system. The editor calls an asset database (DB for short), and is located in the project folder. It belongs to the project asset; Internal DB comes with the editor and provides some built-in necessary assets. It is a read-only asset. It cannot be added, deleted, modified, but can be directly referenced or copied. The bottom display area is the URL of the asset after the asset is selected, such as db://assets The right-click menu of the panel is also an important function. The contents of the right-click menu in different locations are different, and the unavailable menus are grayed out. The shortcut of the panel currently supports the operation of assets: Copy: Ctrl or Cmd + C Paste: Ctrl or Cmd + V Copy: Ctrl or Cmd + D, Ctrl + drag asset Delete: Delete Up and down selection: up and down arrows Folder folding: left arrow or Backspace Expand the folder: right arrow or Enter Multi-select: Ctrl or Cmd + click Multi-select: Shift + click Rename: Enter/F2 Cancel Rename: Esc New assets Click the New Asset button when adding a asset. An input box will appear. The name of the asset is required. If the input is empty, the asset will not be created. If there is no selected item in the tree list, it will be newly created on the root node of Asset DB by default; if there are multiple selected items, it will be newly created in the first selected item at this time. In addition, there is a New entry in the right-click menu of the folder. New asset: Right-click on the new asset in the menu: Selecting an asset In the Asset List, you can use the following operations to select assets: Click to Select Assets. The up and down arrows on the keyboard can be used to select. Hold down Ctrl or Cmd + click to select multiple assets. Hold down Shift + click to select multiple assets. Moving an asset The assets are moved by dragging the tree nodes: Move the asset: the asset is dragged from one folder in the tree list to another folder. An orange frame will indicate the range of the folder to which the new location belongs. Drag out assets: you can drag .prefab, .gltf, .mesh, .fbx assets to the Scene Panel or the Hierarchy Manager to generate nodes. Drag the asset: drag the node from the Explorer Panel to a folder in the list. You can save the node as a .prefab asset. Please see thePrefab Asset documentation. From the file manager of the operating system, drag the file to the list to realize the asset import. Deleting an asset Right-click Delete in the menu, or use the keyboards Delete key, which supports deleting assets in batches after multiple selections. After the assets are deleted, you can restore them in the Recycle Bin of the operating system. Re-importing assets Right-click Re-import Resource in the menu to update the data generated to the Library and support batch re-importing. Sorting assets The Sort by button in the top menu has 2 sorting methods: Sort by name, and Sort by type. The sorting method has a memory, and the next time you open the editor, the saved sorting method will be preserved. Searching for assets The Search Type button in the top menu has 3 sorting methods: Search Name, Search UUID, and Search Type. Where Search Type is the Import type of the search asset, not the suffix type of the asset. The Search box changes the instant search. You can select the asset in the search results, after clearing the search content, the selected asset will be relocated within the window to achieve the purpose of locating the asset by searching. Collapsing assets The Fold or expand all button is an easy way to retract the view range and find assets easily. The parent node in the tree supports shortcut keys. First select the asset, and then perform keyboard operations: Folder folding: left arrow or backspace Expand the folder: right arrow or Eenter/return key Renaming an asset Select a asset, use either the shortcut key F2 or by a right-click and selecting Rename to modify the name. The name cannot be empty. Use the shortcut key Esc will cancel the rename. The name of the script cannot start with a number and cannot be the same as an existing script file. "},"editor/inspector/":{"url":"editor/inspector/","title":"Inspector","keywords":"","body":"Property Inspector The Property Inspector is important for viewing and editing the properties of nodes or assets. You can edit the location of a node, components, pictures, materials, models and other assets of a node. The Property Inspector features many details and can seem complicated. To get started, aselect the node in Scene Editor, Hierarchy Manager, or select the asset in Asset Manager. Properties can now be displayed or edited. Header area The two arrows on the left are the historical records, click to switch the editing items. The lock icon on the right can lock the panel, fix the edited object, and prevent the panel from changing with the new selected item. Editing a Node Nodes correspond to the nodes in the tree structure in the Hierarchy Manager and display the same name. The check box in the upper left corner indicates the activation state of the node. By default, the check box indicates that the node is in an inactive state. The node will be suspended from rendering, and the entire node, including child nodes, will be hidden when running. In the input box is the name of the node. The name can be empty. Next are several general properties of the node: position, rotation, scale, and layer. The node menu on the right, the menu inside can be copied, paste the value of the node attribute, or you can paste a new component. Use the Add component button, after clicking, a list of components will appear, including components provided by the system and custom script components. The list of added components has a search box that supports the up and down arrows on the keyboard, or Enter can be used to confirm the selection. Editing Node Components This panel can display node components and component properties. Like the general properties of nodes, each component has a foldable or expandable header. When multiple components are attached to a node, the scrolling range can be reduced by folding components that are not frequently modified, and improve editing efficiency. To the right of the component name is a help document and a component menu button. The help document button can jump to the API document of the component. The component menu can be operated on: removed, moved up, moved down, copied, pasted as a value, or pasted as a new component. The component created by the user through a script, when editing a node, can be directly dragged into the Property Inspector to generate a component. The different properties in the script component are declared by the user in the script code. When the different types of properties are edited, the editor will automatically recognize the appropriate UI component. The definition of properties is explained, in detail, in the Declaring Properties documentation. How to use UI components Properties are divided into value types and reference types. Value type properties Value type includes simple variable types that take up very little memory, such as numbers, strings, booleans, and enumerations: Number: the keyboard is used to enter digits. The up and down arrows next to the input box can gradually increase or decrease the attributes value. Vector (Vec2): The vector control is a combination of two numeric inputs, and the input box will identify the sub-property name corresponding to each numeric value with x and y. String: the keyboard is used to input strings directly in a text box. The string input control is divided into single line and multi-line. The multi-line text box can be changed by pressing Enter. Boolean: edited in the form of a check box. The selected state indicates that the attribute value is true, and the non-selected state indicates false. Enum: edited in the form of a pull-down menu. Click the enumeration menu, and then select an item from the pop-up menu list to complete the modification of the enumeration value. Color: click the color attribute preview box, and a color picker window will pop up. In this window, you can directly click the desired color with the mouse, or directly enter the designation in the RGBA color input box below s color. Click Color Picker anywhere outside the window to close the window and use the last selected color as the attribute value. For example, the color picker component: Reference type properties Reference types include objects, such as nodes, components, or assets. You can select and assign values ​​by dragging or popping up the asset panel. Batch operationas Multi-selectable nodes, inconsistent properties cannot be modified, and - in the input component indicates that they cannot be modified. Batch assign materials, pictures, animations and other assets, which can be dragged multiple times. Editing Prefab Nodes When editing a Prefab Node, the header area buttons are: disassociate, associate, locate assets, restore from assets, and update to assets. Disassociation refers to disconnecting the prefab node from the asset and turning it into a normal node, the color is no longer green. Association means that a Prefab asset is selected first and then associated with the current Prefab node. The new association between common nodes and Prefab assets can be found in the top menu of the editor Edit: Locating assets refers to locating the Prefab asset on the assets panel and making it flash. Restore from asset means to return an edited Prefab node, along with its child nodes, to the initial state. Update to asset refers to updating the Prefab node data that has been edited to the Prefab asset. Editing Assets When editing assets, please pay attention to the last click to save, the green tick icon in the figure below is the save button. "},"editor/console/":{"url":"editor/console/","title":"Console","keywords":"","body":"Console The Console display errors, warnings, or other log information generated by the editor and engine. Information of different levels of importance is displayed. About log The log system is based on the JavaScript console model. When the editor is running, logs will be captured and printed out to the console in each process and distinguishes them by color. Log (console.log): This is gray text, editor messages and developer output are likely to be printed to the console. Warn (console.warn): This is yellow text, when the program is running, abnormal situations that do not affect the program's result are encountered and outputted. Error (console.error): This is red text, abnormal situations that will affect the result, a problem that must be resolved, or an uncaught error message. Panel operation All the console's functionality is on a toolbar at the top, listed from left to right is: Clear all logs in the current console Open log file Enter text to filter the displayed log Whether regular matching is used in text filtering Filter the displayed log types Other settings Other settings for the console are available in Preferences. Read about advanced settings in the Preferences documentation. "},"editor/animation/":{"url":"editor/animation/","title":"Animation","keywords":"","body":"The Animation system This chapter will introduce the Animation System of Cocos Creator 3D. In addition to standard displacement, rotation, zoom animation and sequence frame animation, this Animation System also supports arbitrary component properties and user-defined properties. Plus the time of arbitrary editing curves and innovative mobile trajectory editing functions enable content producers to create delicate, yet, dynamic effects without writing a line of code. Note: Cocos Creator 3D's built-in Animation Editor is suitable for making less complex animations that need to be linked with logic, such as UI animations. About Animation Familiar with animation editor Create Animation components and animation clips Edit Animation Sequence Creating A Frame Animation Edit Animation Curve Animation event Start with the About Animations introduction. "},"editor/preferences/":{"url":"editor/preferences/","title":"Preferences","keywords":"","body":"Preferences The personalized settings of the editor are provided in the Preferences window. You can click the Preferences menu to open the Preferences window. Preferences is divided into the following pages: General General page are mainly configured for some basic data related to the editor. Language: Can choose 中文 or English. IP Address: Case the user may have multiple IP addresses on this computer. Manually select one and two-dimensional code as a default when previewing address. This will list all native IP, editor will picked one for you automatically. Spin step: In the Properties, all numeric property has a set of UP and DOWN arrows next to the input box, values that can be used to step Input: When hovering close to the value of the property name, the cursor will turn into such a shape, then Drag the mouse, can also according to a continuous increase or decrease the value of step amplitude. The above two ways to modify the value，the default step is 0.1, spin step says each time you click the step button or drag the mouse to change the step amplitude. For example, if you mainly use numbers to integers in the script, you can take the step size is set to 1, can be adjusted more easily. Native Develop This page is used to set the path of the development environment required when the game is published to the native platform (iOS, Android, Mac, Windows). Use Builtin JS Engine: Whether to use the engine path that comes with the Cocos Creator 3D installation path as the JavaScript engine path.This engine is used for scene rendering in the scene panel of editor, declaration of built-in components, and engine modules in other Web environments such as preview or publish. Custom JS Engine: In addition to using the built-in engine, you can also go to engine repository to clone or fork a copy of the engine to the local anywhere, then uncheck Use Builtin JS Engine, then set the JavaScript engine path to your customized engine path. You can use the editor to customize your engine. WeChatGame APP Path: Set the WechatGame App Path, See WeChat Mini Games. Android NDK Path: Set the NDK Path, See Setup Native Development Environment. Android SDK Path: Set Android SDK Path, See Setup Native Development Environment. Data Editor This category is used to set the default open mode for assets. Script Editor：You can use the executable file of any external text editing tool as the opening method when you double-click the script file in Assets. Picture Editor: Similar to the above option, used here to set when Assets, double-click the picture file, open the picture with the default application path. Extension The plugin allows directly registering configuration items into preferences. The configuration items registered in the preferences will be displayed here. For details, please refer to the documentation of each plug-in. Laboratory About Laboratory： The laboratory provides some new technical solutions or experimental features, you can turn each feature on with the on/off switch. Non-backward compatible changes or removal may occur in any future release. Use of the feature in production environments should be well tested and pay attention to the publish notes of future versions. We welcome users to try out and give us your feed backs via our forum, you can make those features more powerful and easier to use in your own projects. Use The Search Pop To Add Components Many users feedback that components can not be searched when add components make they inconvenient. In the face of massive custom scripts component of many projects, find their own scripting components is very difficult.But use the search pop means multi-step operation. Of course, you can turn this option back to the original use. In order to make user more convenient, we also add some auxiliary editing design: The focus will be in the search box when the pop-up window is opened, and you can directly search for related keywords without mouse click to expand; When searching for related components, you can directly use the shortcut keys ↑ ↓ to quickly switch component options, and press the enter key to add the component; For this feature, if you have more awesome suggestions, welcome to tell us in the forum. Turn on terrain For more details can refer to Terrain system documentation. "},"editor/project/":{"url":"editor/project/","title":"Project Settings","keywords":"","body":"项目设置 项目设置 面板通过主菜单的 项目 -> 项目设置 菜单打开，这里包括所有特定项目相关的设置。 项目设置分为全局设置和本地设置。 全局设置存放在 $HOME/profiles/packages/project-settings.json 本地设置存放在 $PROJECT/profies/packages/project-settings.json 我们可以通过每个菜单页面顶部的 local 进入本地配置，并且去除 Use Global 选项来使用本地项目配置。 如果需要在不同开发者之间同步项目设置，请将 $PROJECT/profies/packages/project-settings.json 目录加入到版本控制。 并且在每个编辑器上，去除 Use Global 选项，强制使用本地配置。 通用设置 通用设置主要是针对项目全局的一些基础数据进行配置。 项目预览 预览相关的一些配置信息。 模块设置 构建发布引擎的时候，打包进入最终发布包内的引擎模块设置。 引擎设置 自定义引擎、引擎内可选择的模块的一些配置。 骨骼贴图布局设置 显式指定骨骼贴图布局，用于辅助蒙皮模型的 instancing，具体参考 这里。 "},"editor/engine-customization/engine-customization.html":{"url":"editor/engine-customization/engine-customization.html","title":"Engine Customization Workflow","keywords":"","body":"引擎定制工作流程 Cocos Creator 3D 的引擎部分包括 JavaScript、Cocos2d-x-lite 和 adapter 三个部分(暂不支持Cocos2d-x-lite 和 adapter 引擎定制)。引擎在 github 上开源。地址在： JavaScript 引擎：https://github.com/cocos-creator/engine 建议你通过 GitHub 的 fork 工作流程来维护自己定制的代码，以便在将来引擎升级时，可以方便地将定制的部分更新上去，具体操作方式请阅读 Fork a repo。如果你愿意帮助 Cocos 越做越好，欢迎在 GitHub 提交你的修改，请参考 如何向 Cocos 提交代码。关于更多 GitHub 相关工作流程请参考 GitHub Help。 另外，根据不同的 Creator 3D 版本，还需要切换不同的引擎分支，例如： master/develop 分支：当前最新版本所用分支 vX.Y-release 分支：对应 X.Y 版本所用分支 vX.Y 分支：和 vX.Y-release 分支相同，主要用于范例工程 next 分支：大型重构所用分支 通常建议使用和所用 Creator 3D 相同版本的 vX.Y-release 分支，如果找不到的话，则使用 master 分支。 1 定制 JavaScript 引擎 如果您只需要定制 Web 版游戏的引擎功能，或只需要修改纯 JavaScript 层逻辑（如 UI 系统，动画系统），那么您只要按照下面的流程修改 JS 引擎就可以了。 1.1 获取 JS 引擎 如果您仅需基于当前的版本做一些调整，那么在 Cocos Creator 3D 内置的引擎基础上修改就可以了。点击 Creator 3D 编辑器右上方的 打开程序安装路径，然后将内置的 engine 目录拷贝到本地其他路径。 如果您想获得官方正在开发中的最新版本，首先您需要从 github 上 fork 或者克隆 JavaScript 引擎的原始版本（地址见上文）。JavaScript 引擎在使用前请根据 Creator 3D 版本切换相对应的分支。下载完成后存放到任意本地路径。 1.2 安装编译依赖 # 在命令行中进入引擎路径 cd /Users/yufang/engine # 安装 gulp 构建工具 npm install -g gulp # 安装依赖的模块 npm install 备注：生成debuginfos需要gulp构建工具。 1.3 进行修改然后编译 接下来您可以定制引擎修改了，修改之后请在命令行中继续执行： npm run build 也可以在 Cocos Creator 3D 中通过 开发者 -> 编译引擎 选项进行编译。 该命令会在引擎目录下生成一个 bin 文件夹，并将引擎源码编译到 bin 目录下。 1.4 在 Cocos Creator 3D 中使用定制版引擎 通过 项目 -> 项目设置 面板的 引擎设置 选项卡，设置本地定制后的 JavaScript 引擎路径。 "},"editor/preview/":{"url":"editor/preview/","title":"Preview a Game","keywords":"","body":"Previewing The Game After we use the editor to manage assets, build scenes and tweaking components，it's time to preview the game to run on your target platform. Note：Cocos Creator 3D can only preview inside a browser currently. Preview In Browser Introduction To Preview Process And Common Error Handling Let's get started now with the Preview In Browser documentation. "},"editor/preview/browser.html":{"url":"editor/preview/browser.html","title":"Previewing in Browser","keywords":"","body":"Preview In Browser How To Preview Click the Preview button on top of editor window to see the game in action. After clicking, editor will launch the game in your default browser. We recommend Chrome as the browser of choice, since the developer tools in Chrome are most advanced in web debugging and inspecting. There are a number of control in Preview page: On the left are viewport size presets to simulate how your game look on mobile devices. Rotate button to toggle between landscape and portrait view. Debug Mode let you control the severe level of logs to be shown. Show FPS toggle framerate and draw call stats display. FPS framerate cap. Pause to pause game. Refresh Preview Page If we want to refresh the preview page after some modified, just refresh in browser or click the refresh button in editor. The difference is that click refresh button in editor will refresh all preview pages.If you want the preview page to refresh automatically, just save the scene.The settings for saving scene auto-refresh can be enable in Project Settings-> Project Preview. Scene of Preview The editor will use the current scene as start-scene of preview, we can modified it in Project Settings-> Project Preview. For more information, please refer to the Project Settings documentation. Preview In Mobile There are the following ways to debug the preview page on the mobile phone: Use the mobile browser preview mode of Browser Developer Tools Scan preview QR code Move the mouse to the ip preview address on the left side of the editor toolbar, and a preview QR code will be displayed, which can be scanned with your mobile phone. Directly Enter the preview address in the mobile browser Note: Make sure the mobile phone and the computer is on the same network segment.Since there will be multiple networks on the computer, if the IP address of the preview URL in the editor is incorrectly, you can modify it in Preferences-> General Settings-> Select Local Preview Address. Please refer to the description of thepreference settings documentation. Custom Preview Template We can add custom preview template to change the preview result,just put your template in preview-template folder in the project dictionary.Editor also use template to render to index.html. If there is a file named index.ejs in this dictionary,editor will use it as the template that render to index.html.Your can click the menu in editor Project ——> Generate Preview Template to get the latest template used in editor. project-folder |--assets |--build |--preview-template |--index.ejs Note: There are some preview menu items and preview debugging tools in the preview template, We recommended you keep all the content and just add what you need or modified code carefully to avoid some unexpected errors.. In addition, if index.html and index.ejs coexist, index.html will replace index.ejs as the render-template for preview page. Examples of Use Code of this example is stored in the test-case-3d repository. Get lasted preview template Click the menu Project-> Generate Preview Template to generate a preview template, and the address generated by the preview template will be printed in the console. Add script in folder Add the scripts you need to use in folder, such as test.js, where contains the default logic for starting the game.test.js in the example below will be loaded after the game starts. Modify index.ejs Open index.ejs and modify as follows: ... ... // Game start processing logic // New script Place test.js in the preview-template folder like blow |--preview-template |--index.ejs |--test.js Preview Now, you can refresh your preview game to see changes. Add Custom Devices Info Open Project ——> Project Preview. Custom device info can be modified on this page, and changes will work after refreshing the preview page. Debugging with browser Developer Tools Take Chrome for example, open menu and choose Developer/Developer Tools to open the Developer Tools. It is possible to debug source code, add breakpoints, check the call stack and use step control during debugging. To learn more about using DevTools, please read the Chrome Dev Tools User Guide documentation, or other browser's developer documentation. Browser compatibility The desktop browsers tested during Cocos Creator 3D development include: Chrome, Firefox (Firefox), other browsers can be used as long as the kernel version is high enough. Please do not enable IE6 compatibility mode. Browsers tested on mobile devices include: Safari (iOS), Chrome, QQ browser, UC browser, and WeChat built-in Webview. Continue to the Introduction To Preview Process And Common Error Handling documentation. "},"particle-system/editor/":{"url":"particle-system/editor/","title":"Particle Editor","keywords":"","body":"Particle System Editor The particle system editor mainly includes an introduction to the interface for editing particle properties and how to view and edit the status of selected particles. It mainly consists of the following parts: Curve Editor Gradient Editor Particle Control Panel "},"particle-system/editor/curve-editor.html":{"url":"particle-system/editor/curve-editor.html","title":"Curve Editor","keywords":"","body":"Curve Editor The curve editor can set the curve of a certain property in the particle system with time. The interface of the curve editor is as follows: The curve editor can perform the following operations: The abscissa represents the unitized life cycle of a particle. For example, the life cycle of a particle is 5s, then 0.5 represents 2.5s. The ordinate represents the attribute value, and the ordinate interval can be adjusted through the upper edit bar. The default interval is [-1,1]. Right-click a point on the curve to add a keyframe. Drag the key frame to change its coordinates. You can change the slope of this point by turning the line segment next to the key frame. There is a built-in curve template below the editor. Click a template to apply it directly to the current curve. "},"particle-system/editor/gradient-editor.html":{"url":"particle-system/editor/gradient-editor.html","title":"Gradient Editor","keywords":"","body":"Gradient Editor The gradient editor can set the color of a certain property in the particle system that changes with time. The interface of the gradient editor is as follows: The gradient editor can perform the following operations: Mode has two possible choices: Blend mode will be interpolated according to the two adjacent keyframes at the current time to get the color of the current frame. Fixed mode will directly use the color of the previous keyframe at the current time. Click an empty space above the ribbon to insert an alpha key frame, click an empty space below the ribbon to insert an rgb key frame. Drag the key frame to move left and right to adjust the key frame position, and drag the key frame to move up and down to delete the key frame. The corresponding rgb or alpha value can be edited in the Color / Alpha edit box. Location can edit the position of the selected key frame. "},"particle-system/editor/particle-effect-panel.html":{"url":"particle-system/editor/particle-effect-panel.html","title":"Particle Effects","keywords":"","body":"Particle Control Panel The particle control panel can perform some operations on the particles selected in the editor. The interface is as follows: The following operations are possible: ：Play / Pause particle ：Replay particle ：Stop playing particle Playback Speed: Adjust particle playback speedPlayback Time: Show particle durationParticles: Display the current number of particles "},"editor/animation/animation.html":{"url":"editor/animation/animation.html","title":"About Animation","keywords":"","body":"About Animations Before creating an Animation, you must first add an Animation Component to the node, and mount the clip file for the component before editing. Before that, it is necessary to first understand the related concepts of an Animation Clip and Animation Component. Animation Component Cocos Creator 3D is a component structure, and Animation is no exception. It is also a component on the node. Only after adding an Animation Component to the node can the node be given the ability to participate in the animation. Therefore, after clicking on the relevant node, if the node does not have an Animation Component, the Add Animation Component button will be displayed on the interface of the Animation Editor, click to add. Clip Animation clip An Animation Clip is a piece of declaration data for an animation. If we mount it on an Animation Component, we can apply this animation data to a node. An Animation Component can mount multiple Animation Clips. It is not possible to edit animations on nodes without clips. After clicking on the relevant nodes, if the node has only Animation Components, but no clip files, the Animation Editor will display the Create Clip File button, click to create and assign to the component. In the animation editing mode, you can also switch to edit different Animation Clips through the clip option in the lower left corner of the Animation Editor. Animation editing mode Animations are not allowed to be edited in normal mode. Only in animation editing mode can animation files be edited. However, in animation editing mode, you cannot add, delete, or rename nodes. Opening edit mode: Select the node that contains the Animation Component and contains more than one clip file. Click the button to enter the animation editing mode in the upper left corner of the Animation Editor. Press, Ctrl/Cmd+E Exiting edit mode: Click the exit button in the upper right corner of the Animation Editor, or the close button in the upper left corner of the Scene Editor Press, Ctrl/Cmd+E For more details, refer to the Animation System Design and the Script Control.md) documentation. Continue to the Animation Editor documentation. "},"editor/animation/animation-editor.html":{"url":"editor/animation/animation-editor.html","title":"Familiar with animation editor","keywords":"","body":"Animation Editor Introduction to the main panel of the editor The Animation Editor can be divided into 6 main parts. Toolbar Timeline and Events Node List Keyframe preview in node Property List Property track keyframe preview Toolbar The Toolbar is responsible for displaying some commonly used functions that are triggered by buttons. Function Icon Shortcut Key Remarks Move to the first frame Ctrl/Cmd + Left n/a *Move to previous frame Left n/a Play/Pause Ctrl/Cmd + P n/a Move to next frame Right n/a Move to the last frame Ctrl/Cmd + Right Move to the last frame in the effective range Stop animation Ctrl/Cmd + S Click to stop the current animation, it will move to the first frame after stopping Add event keyframe - Clicking will add an event keyframe at the current time control line position Exit animation editing mode Ctrl + Q Click to exit animation editing mode Switch the scale of time axis display - The default is 00-00 mode, click to switch toframe (in keyframe number) display mode. For details about the time axis scale, please refer to the Time axis scale unit representation documentation. Display the current time and jump to the corresponding time - The specific time of the current time control line is displayed. You can also manually enter it to adjust the current time control line to the corresponding time. You can directly input the frame of frame or00-00. Adjust the default keyframe interval - The number of keyframe intervals filled in will be taken as the number of intervals when multiple keyframes are generated at the same time (for example: when creating a frame animation and dragging multiple pictures at once, the interval between the multiple keyframes added at this time will be taken as value) Arrange selected keyframes - The selected keyframes will be arranged based on the first frame and the values in the input box as intervals. Timeline and Events The timeline, along with the added custom event frames will mainly be displayed here. Right-clicking will move the event control to the corresponding position. The right-click menu can be used to add/remove, or copy/paste keyframes of the event. The effective length of the animation will also have a corresponding display effect. Timeline scale representation The default notation for ticks on the time axis is 01-05. The value consists of two parts. The preceding number indicates the current second, and the following number indicates the number of frames in the current second. 01-05 means that the scale is located on the time axis at the time that 1 second and 5 frames have passed since the start of the animation. Because the frame rate (sample) can be adjusted at any time, the time indicated by the same scale will also vary with the frame rate. When the frame rate is 30, 01-05 means 1 + 5/30 = 1.1667 seconds after the animation starts. When the frame rate is 10, 01-05 means 1 + 5/10 = 1.5 seconds after the animation starts. Although the time indicated by the current scale will change with the frame rate, once a keyframe is added at a position, the total number of frames where the keyframe is located will not change. If we change the frame rate to 01-05 when the frame rate is 30. A keyframe has been added to the scale, and this keyframe is located at the 35th frame after the animation starts. Then change the frame rate to 10, the keyframe is still at the 35th frame after the animation starts, and the scale reading of the keyframe position at this time is 03-05. After conversion to time, it is exactly 3 times as before. Click the button You can change the scale to frame and toggle back and forth. Key frame events Right-click on the timeline position or click the timeline button to add event key frames. Click the event __key frame mail menu to align for removal, copy and other operations. At the same time, after selection, it also supports a series of copy and paste, delete shortcut keys. Node list The index node in the animation data is based on the relative path of the node where the Animation component is attached. Therefore, a node with the same name under the same parent node can only generate one copy of animation data, and can only be applied to the first node with the same name. The nodes here and the nodes of the Hierarchy Manager are mapped one by one. Using this relationship, when the number of nodes in the node list is too large to be consulted, you can use the search function of the Hierarchy Manager to locate the nodes. Click on the node in the Hierarchy Manager, and it will also jump to the corresponding node position in the Animation Editor to achieve a reasonable display effect. Selected node icon Since the node list of the Animation Editor is merged with the data in the clip. There may be more node information than the original node, but this part of the extra nodes is the lost node, which cannot be edited and used. The interface, which will be displayed as yellow is also grayed out at the key frame track. At this time, you can transfer the lost node to other nodes through the migration data in the right-click menu. Keyframe preview within the node This is mainly to display a preview of all frames on each node. Here, you can delete the key frame by right-clicking the key frame position menu, and you can also move the key frame position. Clicking the key frames of different nodes at the same time will select the corresponding node. Double-click the key frame to move the time control line to this position. Without the selected property, Ctrl/Cmd + Shift + Left/Right can Move the time control line up/down to the next key frame position. Property list Mainly displays the property list of the currently selected node participating in the animation. Each property display item has a key frame icon, corresponding to the current property track and the key frame status of the current time control line position. Click to add/remove the corresponding key frame . The right-click menu can remove the current track or clear data. Click on the plus button at the top to add an property track for the currently selected node. Like the node, the property track may also be lost. The property recorded in the animation clip does not exist on the current node. This property is the property lost under the current node. The missing Properties are also displayed in yellow. In this case, you can add the relevant Properties to the corresponding node or directly remove the missing property track after exiting the editing mode. Property track keyframe preview It mainly displays the specific key frame settings on each property track, and is also the main area for key frame editing. You can right-click directly on the track to add key frames, or you can drag the time control line to the corresponding position and press enter to add. At the same time, it also supports frame selection and key frame selection to move, copy, paste and other operations in this area. Basic Operation Guide Switch between different animation clips for editing Click the clip option in the lower left corner of the Animation Editor and select the clip to be edited: Change the keyframe display area Change the timeline zoom What should I do if I feel that the range displayed by the animation editor is too small during operation, and it needs to be scaled down to allow more key frames to be displayed in the editor? You can zoom in or zoom out the display scale of the time axis by scrolling the mouse wheel in areas b, d, and f in the figure. Navigate the display area If you want to see the key frame on the right side of the Animation Editor that is hidden beyond the editor or the key frame on the left side, you need to move the display area: Press the middle/right mouse button and drag in the areas b, d and f in the figure. c. Drag to change the layout of the animation editor The dividing line between the node list and the time, and the dividing line between the Property List and the time axis can be used to drag and change the layout, and can be freely adjusted to the layout effect suitable for editing by dragging. Change the currently selected time You can change the current time node by clicking anywhere or dragging the time control line in the time axis (Figure B area) area. Drag and drop time control line. Click the button that controls the time control line in the toolbar. Double-click the key frame to jump the current time to the corresponding position. Use the shortcut keys to control the current time position s. Play/pause animations Click the play button in the area of ​​Figure A, the button will automatically change to pause, click again to play. In the playback state, operations such as saving the scene will terminate the playback. Shortcut key Ctrl/Cmd + P control For more information about keyframe operations, please review the Edit Animation Sequence documentation. Shortcut key summary Function Shortcut key Description Enter/exit animation editor Ctrl/Cmd + E - Save animation data Ctrl/Cmd + S - Move forward one frame Left (←) If it is already at frame 0, the current operation is ignored. When the key frame is not selected, the small red line moves, and after the node is selected, the key frame is moved; Move one frame backward Right (→) When the key frame is not selected, the small red line is moved, and after the node is selected, the key frame is moved; Move to the first frame Ctrl/Cmd + Left (←) - Move to the last frame Ctrl/Cmd + Left (←) The number of effective frames in the current clip Delete the currently selected keyframe Delete/Cmd + Backspace - Play/Pause Animation Alt + P - Stop animation Alt + S Current time will become 0 Add key frame I After selecting the property track, the key frame will be added at the position of the time control line, if it is not selected, it will be ignored Skip to the previous key frame Ctrl/Cmd + Shift + Left (←) Move to the nearest key frame to the left of the time control line (select the property track or select the node) Skip to the next key frame Ctrl/Cmd + Shift + Right (→) Move to the nearest key frame on the right of the time control line (selected on the property track or selected node) Select multiple keyframes Ctrl Hold down Ctrl and click on keyframes to select multiple keyframes Select all keyframes of the track Ctrl/Cmd + A Select all keyframes of the selected property track Copy to generate key frame Alt After selecting the key frame, press Alt and hold and drag the selected key frame to copy the corresponding key frame to the new moving position Copy selected key frame Ctrl/Cmd + C - Paste the key frame of the last copy Ctrl/Cmd + V - Unselected key frame or event frame Esc - "},"editor/animation/animation-create.html":{"url":"editor/animation/animation-create.html","title":"Create Animation components and animation clips","keywords":"","body":"Create Animation components and animation clips Creating Animation Components On each Node, we can add different components. If we want to create an animation on this node, we must also create a new Animation component for it. There are two ways to create a new Animation component: Select the corresponding node, click Add Component below in the Property Inspector, and select Animation Component in Components. Open the animation editor, then select the node in which to add then animation in the Hierarchy Manager, and click the Add Animation component button in the animation editor. Specifics about Animation component parameters can be found in Animation Component Reference documentation. Creating and mounting animation clips Even though there is an Animation component on the Node, there is no corresponding animation clip data. There are two ways to create animation clips: Click the + on the upper left in the Assets manager, or right-click the blank area and select Animation Clip. Now, a clip file named 'New AnimationClip' will be created in the Assets manager. It is not enough to just create it. We need to click on the node, in the Hierachy manager and find Animation in the Property Inspector. At this time, Clips shows 0, and it needs to be changed to 1. Next, drag the New AnimationClip that was just created in the Assets Manager, and drag it into the animation-clip selection box that just appeared. If you have not added an animation clip file in the Animation component, you can directly click the New AnimationClip button in the animation editor to create a new animation clip file. The newly created animation clip will be automatically attached to the animation component. Note: If you choose to overwrite the existing clip file, the content of the overwritten file will be cleared. So far, we have completed the preparations before the animation, the next step is to edit the animation sequences. "},"editor/animation/animation-clip.html":{"url":"editor/animation/animation-clip.html","title":"Edit Animation Sequence","keywords":"","body":"Edit animation sequence After the animation clip is attached to the Node, click Enter Animation Edit Mode to enter the animation editing mode, and then you can create some animation frame data in the animation clip. First, it is important to understand about animation properties. Animation properties include a Node's own position, rotation and other properties, as well as the properties in a Component. The component contains the component's name and other properties, such as cc.SpriteComponent.spriteFrame. The corresponding blue prism on the property track is the key frame. Animation components can animate the node and component properties on the node and child nodes, including Properties in user-defined scripts. This means that various animation requirements can be flexibly implemented. The specific animation implementation depends on different animation needs and different steps. For an example case, please refer to the official example-3d. This repository mainly introduces some common editing operations and facilitates rapid editing to achieve these effects. Modify a clip's common properties sample: define the frame rate of the current animation data per second, the default is 60, this parameter will affect the number of frames between every two integer seconds scale on the time axis (that is, how many divisions within one seconds). speed: the current playback speed of the animation, the default is 1. duration: when the animation playback speed is 1, the duration of the animation. real time: the actual duration of the animation from the beginning to the end of the animation, corresponding to the number in the parenthesis in the lower right corner of the editor. wrap mode: Loop mode, please refer to the Cycle Mode documentation for specific configuration effects. Changes to properties take effect after the focus leaves the control. Common operations of node panel The animation clip defines the position of the data by the name of the node, ignoring the root node itself, and the remaining child nodes find their corresponding data through the relative path index of the root node. Clear node data: right-click the node item of the animation editor, select Empty Data, and select Clear after the pop-up window prompts Migrating node data: sometimes we will rename the node after the animation is completed, which will cause problems with the animation data, as shown below: At this time, we can right-click on Migrate Data on the missing node, and then click on other nodes to migrate the data. If you do not want to migrate after clicking Migrate Data, click directly in the timeline area or click Cancel in the pop-up window after clicking other nodes. !(./animation-clip/moving_node.gif) Note: by default, node data migration will overwrite the data on the target node Common operations of property track data An animation clip may contain multiple nodes, and multiple animation properties are bound to each node. The data in each property is the actual key frame. The key frame operation in the property has been mentioned above. This section mainly introduces some operations for the entire property track: Add an property track: click the + small button next to the property list, after the pop-up property menu pops up, click on the property that needs to be added. Example: Remove property track: right-click the property list item and select Remove property track. Example: Clear track data: right-click the property list item and select Clear property track. Example: Copy and paste track data: right-click the property list item, select copy track data or press Ctrl + C, then click the same type of track as the copied track, right-click will see the paste option, click or press Ctrl + V to paste. Example: Common Key Frame Operations In the process of producing animations, there are often some manipulation of key frames. There are a variety of key frame processing methods in the animation editor.. Knowing these methods and techniques can help to edit animation clips faster. Selecting a key frame After clicking the key frame, the key frame will be selected. At this time, the key frame changes from blue to white. Currently, there are the following ways to select the key frame: Right-click a key frame to select it, press Ctrl and right-click to select multiple key frames. Drag the frame directly in the key frame area to select the key frame. Press down the mouse in the empty area of the key frame panel and drag to form a selection area to select all key frames inside. Add key frame To add a key frame: Right-click on the corresponding property track position and select Add Key Frame. The current number of key frame frames will also appear on the right-click menu. Select the corresponding node and the corresponding property, move the time cursor to the position where the key frame needs to be added, and press the I (inset) key Move the time cursor to the position where the key frame needs to be added. In the corresponding property list item, click . After selecting the corresponding node and the corresponding property track, the editor control for the corresponding property will appear in the middle of the animation editor, and the key frame can be marked by modification. After adding the property track, move the time cursor to desired position of the Property Inspector or perform scene operations to automatically generate key frames. Removing key frames Select the key frames you want to delete and press delete/Cmd + backspace on MacOS and delete/Ctrl + backspace on Windows. At the position of the key frame to be deleted right-click, select Remove Key Frame. Drag the time cursor to the position where the key frame needs to be removed and double-click the key frame, in the corresponding property list item, click Modifying key frame data On the timeline double-click the key frame that needs to be modified. The time cursor will move to that position. You can also directly drag the time cursor to the corresponding position, and modify the corresponding properties directly in the Property Inspector. Make sure the animation editor is in edit mode. For example, there are three property tracks in the property list: position, scale, and rotation. After the key frame is selected, you can modify the position, scale, and rotation properties in the Property Inspector. In animation editing mode, move the time control line to a position where there are no key frames on the timeline, and then modify the corresponding properties in the Property Inspector, and a frame will also be inserted automatically. Moving a key frame After selecting a key frame, right-click and hold on the selected key frame to drag, and release it to complete the movement. There will be prompts for the distance and the number of frames in the final position during the movement. Zooming a keyframe After selecting multiple key frames, the left and right control levers will be displayed. Drag any one of the joysticks to move and perform zooming of the key frames. Arranging key frames at specific intervals After selecting multiple key frames, adjust the number of interval key frames. After pressing the button for arranging intervals, the selected key frames will be arranged in sequence according to the set number of intervals. Copying/pasting keyframes After selecting the key frame, follow the normal shortcut key C/V to copy and paste. Note that the location of the shortcut key paste will start from the current key frame. After selecting the key frame, right-click on the selected key frame, select Copy Key Frame, and then right-click elsewhere, select Paste Key Frame. After selecting the key frame, press the Alt key, hold down and drag on the selected key frame. The key frame will be copied to the corresponding position of the move after releasing the mouse. Tips: when copying and pasting a single key frame within a short distance, it is recommended to use alt + mouse dragging; for long distance and multiple key frames, it is recommended to use the shortcut key to copy, and the right mouse button to paste. For more about the design of animation sequences and the content of scripting animations, you can refer to the Animation Clip documentation. Continue to the Making a Frame Animation documentation. "},"editor/animation/sprite-animation.html":{"url":"editor/animation/sprite-animation.html","title":"Creating A Frame Animation","keywords":"","body":"Creating a frame animation Previous chapters wrote about the operation of Attribute Frames, now how to create a Frame Animation. Adding a Sprite component to a node First, we need to allow the node to display the texture normally, so we need to add a Sprite component to the node. After selecting the node, use the Add Component button in the Property Inspector and select UI-> Render-> Sprite. Add a cc.Sprite.spriteFrame to the attribute list After the node can display the texture normally, an Attribute Track needs to be created for the texture. Click the + next to the Property List of the Animation Editor. Select cc.SpriteComponent-> spriteFrame. Adding a Frame First, from the Explorer, drag the texture to the Attribute Frame area and place it on the cc.Sprite.spriteFrame track. Next, drag the texture to be displayed in the next frame to the specified position, and then click Play to preview the animation that was just created. If you drag multiple textures to the Attribute Track at the same time, the button textures are selected in the order on the track, and they are arranged in sequence according to the number of intervals displayed on the toolbar to generate key frames. Arranging and modifying key frame intervals The interval frame number of frame animation is usually fixed. Sometimes after adding multiple textures, if you want to adjust the interval number, you can fill in the desired interval frame number at the top of the toolbar Then select the key frame to be arranged, click Arrange button on the toolbar or right-click on the selected key frame and select Arrange selected key frames. Continue to the Editing Animation Curves documentation. "},"editor/animation/animation-curve.html":{"url":"editor/animation/animation-curve.html","title":"Edit Animation Curve","keywords":"","body":"Editing Animation Curves We have created a basic animation in previous sections of this documentation. However, sometimes we need to implement easing effects, such as EaseInOut between two key frames. How is this achieved in the animation editor? First, two unequal key frames need to be created on a track, such as two key frames on position, from 0,0 to 100,100. Next, a connecting line will appear between the two key frames (the blue line segment connecting the key frames). Double-click the connecting line to open the Curve Editor. When the Curve Editor is open, if the current animation curve data is in a preset, the corresponding item on the left of the preset will have a golden border to show it's selected effect. The modification of the animation curve is real-time, there is no need to click save. After modifications, click the close button in the upper right corner. Using preset curves Presets can be selected on the left side of the Curve Editor. For example, Ease In, can be applied to the current animation curve by clicking the corresponding curve. Custom curves Sometimes, when the preset curve can not meet the needs of the animation, we can also modify the curve ourselves. In the preview curve of the Curve Editor, there are two gray control points. Drag the control point to change the curve's trajectory. If the control point needs to be dragged out of view, the mouse wheel can be used to zoom the preview. The curve data during the modification process will be displayed in the input box in the upper left corner of the curve area in real time, and the input box also supports manual input of curve data to generate a curve, of course, the format of the curve data must be four numbers in CSV format (commas separated value format) with, otherwise it cannot be applied normally. Save custom curve Sometimes some custom curve data required by the project needs to be reused, it can be saved in the preset library of User. Specifically, after editing the curve data to be saved, select the User option in the preset menu at the upper left and enter the name of the curve data to be saved in the input box at the lower left, and click add to add. Note: The curve with the same name will be overwritten, and the custom curve is saved without undo processing, so if it is overwritten, it needs to be added again. The custom curve saved in the preset is the same as the preset curve of other libraries, click to apply. At the same time, when the mouse moves over the curve, a delete icon will appear. Click to delete the corresponding curve data. For more about the design of animation curve and script control code, please refer to the Animation Curve documentation. Continue to the Add Animation Events documentation. "},"editor/animation/animation-event.html":{"url":"editor/animation/animation-event.html","title":"Animation event","keywords":"","body":"Animation Events In games, it is often necessary to execute some function at the end of an animation or at a specific moment in a certain frame. At this time, it can be achieved by adding Animation Events. After adding an event function on to a key frame, the animation system will match the corresponding function methods on the animation root node and execute them when the animation reaches the key frame. Please refer to the frame events documentation before continuing. Adding an event frame First, move the time control line to the position where the event needs to be added, and then click the button in the toolbar area. The same golden icon , this is the event we added. Deleting an event frame At the added time frame position, right-click and select Delete. Deleting here will delete all time frame functions at that time position. Add an event frame function Click the + button on the upper left of the Event Function Editor to add a new event frame function Delete time frame function To delete a frame function at the corresponding time position separately, you can click the delete button next to the function name in the Event Function Editor. Editing a specified event trigger function Double-click the event frame just added to open the Event Editor. In the editor, we can manually enter the name of the function that needs to be triggered. When the event is triggered, animation system will execute all corresponding method with the same name in each component of the animation root node. If you need to add the incoming parameters, click + or - next to Params. Currently, only three types of parameters are supported: Boolean, String, and Number. After the modification occurs, a red asterisk will appear next to the title of the Event Function Editor. The modification of the event function needs to be manually saved. After the modification, click the save button above to save. If not saved, there will be a pop-up box prompting to save when closing the Event Editor. "},"editor/terrain/":{"url":"editor/terrain/","title":"Terrain System","keywords":"","body":"Terrain system The terrain system displays the mountainous landscape of nature in an efficient way. Developers can easily use a brush to sculpt basins, mountains, valleys, plains and other landforms. Creating a terrain Two steps are required to create a terrain: Click the right mouse button in Hierarchy Manager and click Create -> Terrain to create a terrain node. Terrain nodes can be moved, but rotation and zoom are not yet supported. Click the right mouse button in the Assets Panel and click Create -> Terrain in the pop-up menu to create the necessary terrain assets. Using a terrain Click on the created terrain node. There is a terrain component in the Inspector Panel, and the created terrain assets are assigned to the Asset in the terrain component. Editing a terrain After assigning the terrain assets, the editing panel can be accessed from the Scene. The terrain editing system includes three major functions: management of terrains, sculpting terrains, and painting terrains. These three functions can be switched between by clicking on the corresponding tabs. It is also possible to switch between each more using the icon on the toolbar. Management of terrains Management is adjusting various parameters of a terrain. Tile is the smallest unit of terrain. Tile constitutes one 32x32 block of tiles with each terrain needing to consist of at least one tile block. Parameter Description TileSize The size of the terrain tile. Currently, a terrain block consists of 32 x 32 tiles, so the side length of a terrain block is 32 x TileSize. BlockCount Number of terrain blocks in two dimensions WeightMapSize Weight map size LightMapSize Lightmap size Sculpting a terrain Sculpting is changing the shape of a terrain. Brush function Brush controls are as follows: Up/Down, left mouse button/Shift+left mouse button. Smooth, raised and depressed operations tend to make the terrain look sharp. Brush type Currently only round brushes are supported. The brush can have the following parameters: Parameter Description BrushSize The size of the brush BrushStrength Brush strength Brush Falloff Brush falloff, this value determines the sharpness of the brush edge. 0.0 means that the brush has full effect in the whole range (all covered by the current layer texture), with sharp edges, 1.0 means that the brush has full effect only in its center, and the influence will be attenuated when reaching the edge. Painting a terrain Painting is the texture used to depict the appearance of a terrain. Parameter Description DetailMap Current Layer texture TileSize The tile size of the texture. The smaller the value, the more tiles will be used in the same size area. Layer editing Click +/- to add and delete layers (up to 4 layers are supported). After selecting a Layer, you can edit the DetailMap and TileSize parameters. "},"editor/lightmap/":{"url":"editor/lightmap/","title":"Lightmap","keywords":"","body":"Lightmap The baking system is the process of finally generating light maps and applying them in the scene by calculating the influence of all light sources on the object in the engine scene. The purpose of this system is to reduce the calculation of real-time light sources, thereby improving the efficiency of the scene. Creating Three steps are required to turn on the baking system: Click the menu button in the top menu bar Project (Project), click the Lightmap (light map) button in the pop-up menu bar to pop up the lightmap panel. Before baking, you need to set the Bakeable property of the light source component to true in the editor, Note: currently only one main direction light source is supported. In the lightmap panel that pops up, after setting the corresponding parameters, click the Lightmap Generate button and select the corresponding storage folder to generate the lightmap Note: the storage folder must be under Effective Assets. Using During the process of generating baked maps, there will be a generated progress prompt. After the generation, you can view it in the ->Baked tab in the lightmap panel. Among them, Baked result (baked result display panel) shows the lightmap texture after baking, Lightmap clear (clear button) can delete the generated result of baking, and information output panel shows the information of each baked image (file name) , Size, etc.). Note: Only terrain lightmap is supported in v1.1, and the lightmap of the model is also supported after v1.1.1 version, but before the lightmap is enabled, the model needs to include two sets of uv, the second set of uv is used to access the lightmap, and Materials also need to check the lightmap option to apply the shadow information after the model is baked. Editing The baking process is to calculate the generated results according to the parameters set on the panel, as shown below: The following table describes the specific meaning of each parameter. Parameter Description MSAA Multisampling: Has the following values ​​(1, 2, 4, 8) Resolution Baking map size: has the following values ​​(128, 256, 512, 1024, 2048) Gamma Gamma correction value GIScale Global illumination scaling factor GISamples Global illumination sampling coefficient AOLevel AO Level AOStrength AO Strength AORadius AO Radius AOColor AO Color "},"editor/publish/":{"url":"editor/publish/","title":"Build and Publish","keywords":"","body":"Publishing Workflow The Build panel allows you to publish games to multiple platforms, including Web, iOS, Android, Windows, Mac, and various mini-game platforms. Index About the Build Panel General Build Options Publishing to the Web Publishing to native Setup Native Development Debugging JavaScript on Native Platforms Publishing from the Command Line Custom Project Build Process Build Process with FAQ Publish to Mini Games Publishing to Alipay Mini Games Publishing to Huawei Quick Games Publishing to ByteDance Mini Games Publishing to Cocos Play Publishing to WeChat Quick Games WeChat Engine Plugin Publishing to OPPO Mini Games Publishing to vivo Mini Games Publishing to Baidu Mini Games Publishing to Xiaomi Quick Games "},"editor/publish/build-panel.html":{"url":"editor/publish/build-panel.html","title":"About the Build Panel","keywords":"","body":"About the Build Panel Click Project -> Build in the main menu or use the shortcut Ctrl / Cmd + Shift + B to open the Build panel. If multiple build tasks are added at the same time, the editor will automatically start building the next task after the current platform's build task is completed in the order in which it was added. Platform Plugin Each platform's build will be embedded in the Build panel as a separate plugin, with platform related options placed in a collapsible section (e.g. the Web Desktop in the figure below). New Build Task Click the New Build Task button at the top right of the Build panel to open the build options configuration panel. After the options are configured, click Build. Make sure the content in the Scene panel is saved before you build. If it is not saved, when you click on the Build button, a prompt will pop up asking: Do you want to save the current data before build?. You can choose Save, Ignore or Unbuild. If Save / Ignore is selected, the build will continue, and if Unbuild is selected, a record of cancelled builds will be generated. Note: There is no point in executing a build if there is no scene in the project, so projects without a scene are not allowed to add build tasks. Build Task Name Build Task Name is the name of the release folder generated after the build. It is not modified by default. If the same platform performs multiple builds, the suffix -001, -002, -003 and so on will be added to the original Build Task Name. If you want to overwrite an old release package, simply manually change the Build Task Name back to its original name. Note: Cocos Creator 3D uses the Platform name as the name for the release package generated after the build, and overwrites the original package with each build. Note: Cocos Creator 3D uses the Build Task Name as the name of the release package that is generated after the build, and a new release package is generated with each build. If you want to overwrite the original release package, you can manually modify the Build Task Name to match the original release package name. Build Progress After clicking Build, you can monitor the current build task progress in the Build panel. If the build is successful, the progress bar is shown in green, and the time of the actual build is output. Sometimes, especially a first build, the engine will be slow to compile, please be patient. If the build fails, the progress bar is shown in red. Run Currently, most platforms can directly click the Run button in the Build panel to preview the effect of the project after the build is complete. If there is no Run button, it means that the current platform does not support run in the editor, please refer to the release document of the relevant platform for details. Build Log Because the build process generates so many log messages, by default only error log are printed to the editor's Console panel. There are several ways to view all log information: Open Build DevTools Click Developer -> Open Build DevTools in the menu bar to see all the log information printed during the build, including the call stack. Log Level Click Preferences -> Extension in the menu bar, set Package to builder, and then set the log type to output to the Console panel in Log Level. Log File The editor will record the error log generated during each build, which can be viewed by clicking the button under build task in the Build panel. The log file is stored in the project's temp/build-log directory and can be attached when you send feedback to the forum on build related issues. Adjust the build options configuration The Build panel has a button below the build task, which can be clicked to see or adjust the configuration of the previous build options. Click the Recompile button after the adjustment is complete, the generated release package will directly overwrite the original. The information about the completed build task will be saved in the profiles/packages/build.json file of the project. As long as the source file of the corresponding build task is not deleted, either in the Build panel or directly deleted in the project directory, you can view the build options configuration of the previous build after reopening the editor, as well as to run and preview again. Note: The button is for developers to recompile after adjusting the build options of the current build task, while the New Build Task button is for creating a new build task, please don't confuse the two. Export / Import Export The Export option at the top right of the Build panel exports the current configuration of build options to a JSON file. This mainly facilitates building from the command-line and sharing the configuration of build options within the same project. The exported configuration of build options are platform-specific. For developers who use the command line to build, you can directly use the JSON configuration file as the configPath of the command-line build options. Import The Import option reads JSON configuration file into the Build panel for developers to share build options configuration. Recompile If you want to adjust the configuration of build options after the project is built, or if you want to recompile the project after a bug fix. There are following two ways: Option 1: use the Recompile button at the bottom right of the build task, in the Build panel. This option will directly recompile using the previous configuration of build options. Option 2: use the button at the bottom of the build task in the Build panel. Click the button to enter the Build panel and you can see a Recompile button. For details, see Adjust the build options configuration in the upper part of the documentation. "},"editor/publish/build-options.html":{"url":"editor/publish/build-options.html","title":"General Build Options","keywords":"","body":"General Build Options General Options in the Build Panel Build Path You can designate a release path for the game by inputting a path in the Build Path input field or choosing one via the ... browsing button. The following cross-platform release will create assets or projects in child folders of this release path. The default release path is in the build under the project folder. If you use version control systems like git and svn, you can ignore the build folder in version control. Debug In release mode, the uuid of the asset, the built engine script and the project script will be compressed and confused, and the JSON of the same asset will be subpackaged to reduce the number of asset loads. When debugging a project, it is recommended to check the Debug option for easy positioning of the problem. Replace Splash screen Mouse over this option and an Edit button will appear. Click this button and the panel will open. The first time you use this feature you need to fill out a questionnaire before opening the Replace Splash screen panel. There will be some project-based information in the questionnaire, and we hope to gather more information on games developed using Cocos Creator 3D, as well as more support programs in the future that developers will hopefully be able to fill out truthfully. Included Scenes There are usually multiple game scenes in the project, this option allows you to choose the scenes you want to package. During the build process, all assets that depended on these selected scene assets in deep will be packaged. Just select the game scenes that are actually needed can reduce the size of game package after build. For more information about assets packaging, please refer to the Build Process with FAQ documentation. Start Scene The first scene after entering the game can be set directly in the Start Scene. You can also choose other scenes, that are part of your game, in Included Scenes. Move the mouse to the scene, a move up icon button will appear after the scene, then click the button to set it. Source Maps The build will compress engine files and project scripts by default, if you want to generate a sourcemap, you need to check this box. A source map is a file that maps from the transformed source to the original source, enabling the browser to reconstruct the original source and present the reconstructed original in the debugger. For more details on source maps, please refer to the Source Maps documentation. Compress Texture Some compression options can be added to spriteFrame type image assets in the editor. Once enabled, the corresponding image assets are generated based on these compression options during build. If disabled, the compression texture will not take effect at build time even if configured. Please refer to the Compress Texture documentation for details. packAutoAtlas The Auto Atlas is the editor's built-in texture merge. If this is disabled, even if you configure the packAutoAtlas, it will not take effect at build time. Please refer to the Auto Atlas documentation for details. Merge all JSON that the Start Scene depends on When merging assets automatically, all JSON files that the Start Scene depends on are merged into the package that contains the Start Scene. This option is disabled by default. When enabled, it will not increase the overall game size, but if these JSON is also used by other scenes, then CPU overhead may increase slightly when they are loaded again. MD5 Cache Append MD5 hash to the exported assets for resolving CDN or browser cache issue. After being enabled, if any asset fails to load, it is because the renamed new file can not be found. It is usually because some third party assets was not loaded by cc.loader. If this happens, you can convert the url before loading, to fix the loading problem. Example: url = cc.loader.md5Pipe.transformURL(url); Other option configurations involved in the build. Engine Modules Click Project -> Project Setting -> Modules in the menu bar to open the Modules panel. The Modules panel is mainly used to reduce the size of the packaged package by eliminating some engine modules that are not needed in the project. Engine modules may change with the version upgrades, and specific module information is subject to the version-specific editor. Note: Please reconfirm the module information after each version upgrade before building and releasing it. Canvas Click Project -> Project Setting -> General -> Default canvas setting in the menu bar to set the Canvas. The Canvas is mainly used to set multiple resolutions. If there is no Canvas component in the project, this option can be ignored. Please refer to the Multi-Resolution Adaption documentation for details. "},"editor/publish/publish-web.html":{"url":"editor/publish/publish-web.html","title":"Publishing to the Web","keywords":"","body":"Publishing to the Web Open main menu's Project -> Build to open the Build panel. Cocos Creator 3D provides page templates for two kinds of Web platforms. From the pop up menu of Platform, you can choose Web Mobile or Web Desktop. The major difference is that in Web Mobile, the image will cover the whole browser window by default, while in Web Desktop, you are allowed to designate the resolution of image, which doesn't change when you zoom on the browser window. Build Options For some general build options of platforms, please refer to the General Build Options documentation. Web Desktop Options Optional or not Default Explanation Polyfills Optional { asyncFunctions: true } Since v1.0.3, the Build supports some new feature of polyfills, mainly when the script is packaged, and the corresponding processing will be done. developer can choose polyfills according to their needs. This option currently only has Async Functions, and more functions will be opened in the future. Preview Resolution Required 1280 * 960 Resolution width and height of the game view Web Mobile Options Optional or not Default Explanation Orientation Required Auto Device orientation, including Auto, Landscape, Portrait. Polyfills Optional Async Functions Since v1.0.3, the Build supports some new feature of polyfills, mainly when the script is packaged, and the corresponding processing will be done. developer can choose polyfills according to their needs. This option currently only has Async Functions, and more functions will be opened in the future. VConsole Optional false Whether to use vConsole. vConsole is similar to the mini version of DevTools and is used to aid debugging. Preview URL Multiple Web projects can be previewed at the same time, so the Preview URL in the Build panel is no longer unified, but each build task will have a separate preview URL, which does not interfere with each other. Click the URL to automatically open the browser to preview. The specific preview URL stitching rule is ${The Preview IP in Preferences}:${Editor preview port number}/${Build platform}/${Build task name}/index.html. Build and Preview After configuring the build parameters, click the Build button, then a progress bar will appear on the top of the panel. When the progress bar reaches 100%, the build is finished. The image above shows the preview of Web Mobile, you can see that the game view will cover the whole browser window, but Web Desktop will not, as shown below: Browser Compatibility The desktop browsers tested during the Cocos Creator 3D development process include: Chrome, Firefox, Safari (Mac), QQ browser, 360 browser. Other browsers as long as the kernel version is high enough to work properly, for some browsers do not open IE6 compatibility mode. Browsers tested on mobile devices include: Safari (iOS), Chrome, QQ browser, UC browser and WeChat built-in WebView. Retina Setting You can use view.enableRetina(true) to set the high resolution in the script, and the Retina display will be turned on by default when you build to the Web platform. Release a game on Web server If you want to release or share your games on the Internet, click the Open button next to Build Path. After opening the release path, according to the current build task name, copy the entire contents of the corresponding folder generated by the build to your Web server. Then you can see the game later there. For information on setting up a Web server, please search for solutions, such as: Apache, Nginx, IIS and Express. "},"editor/publish/publish-native.html":{"url":"editor/publish/publish-native.html","title":"Publishing to Native","keywords":"","body":"Publishing to native Cocos Creator 3D officially supports the native platform since v1.0.3, click the Project -> Build in the main menu to open the Build panel. There are four native platforms, which include Android, iOS, Mac and Windows. The options to release games on iOS, Mac and Windows will only appear on those operating systems. This means it isn't possible to publish, for example, a game to iOS from a Windows computer. Currently, all native platforms are packaged together, you can configure the parameters of each native platform in the Build panel, and all native platform release packages can be generated in one build. Environment Configuration Please refer to the Setup Native Development Environment documentation for details. Build Options For some general build options of platforms, please refer to the General Build Options documentation for details. The following are specific build options for individual platforms and considerations for general build options. MD5 Cache MD5 Cache is used as a generic option, mainly to add MD5 information to all asset file names after the build, solving the CDN asset cache problem during hot update. When enabled, if any asset fails to load, it is because after renaming the new file, it cannot be found. This is usually because some third party assets used in C++ was not loaded by cc.loader. At this point, you can convert the URL before loading with the following method, to fix the loading problem: auto cx = ScriptingCore::getInstance()->getGlobalContext(); JS::RootedValue returnParam(cx); ScriptingCore::getInstance()->evalString(\"cc.loader.md5Pipe.transformURL('url')\", &returnParam); string url; jsval_to_string(cx, returnParam, &url); Native Build Options Due to the adjustments made to the build mechanism, the processing of the different platforms is provided in the form of plugins. When you select Native in the Platform section of the Build panel, you will see that there is a native option in addition to the build options of a specific platform, and the configuration of native related options will affect all native platforms. Template There are two types of available engine templates in the dropdown menu of Template, from which we can choose one: Default - build the project with the Cocos2d-x source-code version engine. Link - unlike the Default template, the Link template does not copy the Cocos2d-x source-code to the build directory. Instead, the shared Cocos2d-x source-code is used. This can effectively reduce the footprint of the build directory, and modifications to the Cocos2d-x source-code can also be shared. Let's review the concept of the source-code engine: The Cocos2d-x engine includes the source-code engine. Remember: The first time the source-code engine builds and compiles a project, it takes a long time to compile C++ code, depending on the configuration of the computer, which may take 5~20 minutes. After the same project has been compiled once, the time required for the next recompile is greatly shortened. The projects built by the source-code engine, compiled and run using native development environment (such as Android Studio, Xcode, etc. IDE), and also can be debugged and error captured. The Cocos Creator 3D installation directory under resources/3d/cocos2d-x-lite already contains the Cocos2d-x source-code engine. Polyfills Polyfills is a new feature option supported by the script system. If this option is checked at build time, the resulting release package will have the corresponding polyfills in it, and will also increase the size of the package. Developers can choose polyfills on demand, but only Async Functions are currently available, and more will be opened later. Android Build Options Package Name (Bundle Identifier) Usually in descending order by product site URL, e.g. com.mycompany.myproduct. Note: Only numbers, letters and underscores can be included in the Package Name. In addition, the last part of the Package Name must begin with a letter, not with an underscore or a number. Target API Level Set the Target API Level required to compile the Android platform. Click the Set Android SDK button next to it to quickly jump to the Android SDK configuration page. You can refer to the Setup Native Development Environment documentation for details. APP ABI Set the CPU types that Android needs to support, including armeabi-v7a、arm64-v8a and x86. You can choose one or more options. Note: When you select an ABI to build and then build another ABI without Clean, both ABI's so will be packaged into the APK, which is the default behavior of Android Studio. If you import a project with Android Studio, after selecting an ABI to build, run Build -> Clean Project, then build another ABI, only the latter ABI will be packaged into the APK. Note: After the project is imported with Android Studio, it is an independent existence and does not depend on the Build panel. If you need to modify the ABI, you can directly modify the PROP_APP_ABI property in gradle.properties as shown below: Keystore Android requires that all APKs be digitally signed with a certificate before they can be installed. A default keystore is provided, check the Use Debug Keystore to use the default keystore. If you need to customize the keystore, you can remove the Use Debug Keystore checkbox. Please refer to the official Android Documentation for details. Orientation The orientation of the device includes three types Portrait, Landscape Left, and Landscape Right. Generate App Bundle (Google Play) Check this option to package the game in App Bundle format for uploading to the Google Play store. Please refer to the official Android Documentation for details. Mac Build Options Bundle Identifier Please refer to the Package Name option for Android. iOS Build Options Bundle Identifier Please refer to the Package Name option for Android. Orientation Please refer to the Orientation option for Android. Build After selecting the Platform, setting the initial scene and the platform configuration options in Build panel, then click the Build button in the bottom right corner, and you can start the building process. When the build is complete, what we get is a standard Cocos2d-x project that has the same structure as a new one built using the Cocos Console. Then clicking the Open button next to the Build Path opens the build release path in the operating system's file manager, where the release package for all native platforms is included in the native -> frameworks -> runtime-src directory of this path. Compile Currently, the editor has not integrated compilation functions. You need to manually open the built native project in the IDE of the corresponding platform (e.g. Xcode, Android Studio, Visual Studio) for further preview, debugging and releasing. The following are manual compilations for each native platform: iOS: Use Xcode to open the native\\frameworks\\runtime-src\\proj.ios_mac\\.xcodeproj file in the build directory, set the signature in the General -> Signing of the Xcode panel, and then click the compile button after selecting the connected device in the top left of Xcode to compile and run. Android: Open the project using Android Studio, download the missing tool (if prompted), and then compile and run it. Mac: Use Xcode to open the native\\frameworks\\runtime-src\\proj.ios_mac folder in the build directory to compile and run. Windows: Use Visual Studio (Visual Studio 2017 is recommended) to open the native\\frameworks\\runtime-src\\proj.win32\\.sln file in the build directory, or just double-click it to compile and run the project. When installing Visual Studio, please note that you need to check the box to install the SDK for Windows 8.1 version. Note: When running a project built in debug mode on the MIUI 10 system, the Detected problems with API compatibility prompt may pop up, which is a problem introduced by the MIUI 10 system itself, just use the release mode to build. "},"editor/publish/setup-native-development.html":{"url":"editor/publish/setup-native-development.html","title":"Setup Native Development","keywords":"","body":"Setup Native Development Environment Apart from publishing games to the Web, Cocos Creator 3D uses JSB technology based on the Cocos2d-x engine for the cross-platform release of native games. Before using Cocos Creator 3D to bundle and publish games to native platforms, you need to configure related Cocos2d-x development environment first. Android platform dependencies To publish to the Android platform, you need to install all of the following development environments. If you do not have a plan to publish to the Android platform, or if your operating system already has a full Android development environment, you can skip this section. Download the Java SDK (JDK) Compile the Android project requires a complete Java SDK tool on your local computer, download it at the following address: Java SE Development Kit 8 Downloads Download and pay attention to select the machine and the operating system and architecture, download the installation can be completed after the installation process. After the installation is complete, please confirm that the java command is valid on the command line. Input the following code into Mac terminal or Windows command line tool for check: java -version If JAVA SE displays, there is no problem. If JRE displays, then you need to install JAVA SE running environment). On Windows platform, please confirm if JAVA_HOME is included in your environmental variables. By right clicking Computer on your computer, choosing Property -> Advanced system setting -> Environment Variables to check and modify environmental variables. For effective running on Windows platform, you might need to restart the computer. For details, please refer to the document: How do I set or change the PATH system variable?. Download and install Android Studio Cocos Creator 3D does not support Eclipse's ANT build, we need to use Android Studio as an Android platform's build tool and you should download the required SDK and NDK packages in Android Studio. First install Android Studio. Download the SDK and NDK required to publish the Android platform After installing Android Studio, refer to the official documentation and open the SDK Manager: SDK Manager Instructions. In the SDK Platforms tab page, check the API level you want to install, and it is recommended to select the required mainstream API Level such as API Level 23 (6.0), API Level 26 (8.0) and API Level 28 (9.0), etc. In the SDK Tools tab page, first check the lower right corner of the Show Package Details, show the version of the tool selection. In the Android SDK Build-Tools, select the latest build Tools version. Check the Android SDK Platform-Tools and Android SDK Tools. If you need to install the Android Support Library, please refer to the official Android Documentation. Check the NDK and the recommended version is r17 ~ r19. Take note of the path of Android SDK Location on top of the SDK Manager window. Later we need to fill in the location of the SDK in Cocos Creator 3D. Click OK and follow the prompts to complete the installation. Install C++ compiling environment Please install the following running environment: Python 2.7.5+, download page. Pay attention! Don't download Python 3.x version. In Windows, the installation of Visual Studio 2017 Community Edition is needed. When installing Visual Studio, please check Desktop development with C++ and Game development with C++ two modules. Note: There is a Cocos option in the Game development with C++ module. Do NOT check it. In Mac, the installation of Xcode and command line tool is needed. Configure Native Develop environments path Next, let's go back to Cocos Creator 3D to configure the environmental path of the native platform. Choose CocosCreator 3D -> Preferences in the main menu, and open the Preferences panel: We need to configure the following two paths here: NDK Root, choose the ndk-bundle folder in Android SDK Location path we just noted in Android Studio SDK Manager window. You can skip this if you don't need to compile on Android platform. Android SDK Root, choose the Android SDK Location path we just noted in Android Studio SDK Manager window (the directory of Android SDK should include folders like build-tools, platforms, etc.). You can skip this if you don't need to compile the Android platform. Close the window after configuration is completed. Note: The configuration will work when build native project. If the configuration not work, please try to set these settings to System Environment manually: COCOS_CONSOLE_ROOT, NDK_ROOT, ANDROID_SDK_ROOT. Notes We have received lots of feedback about native packing in the public beta, and some possible reasons are supplemented here: Package name issue Check the Game Package Name in the Build panel, including blank space, -, etc. are all illegal. Android built successfully, but prompt dlopen failed: cannot locate symbol \"xxxx\" referenced by \"libcocos2djs.so\"... in runtime. Please check if the architecture and version of NDK and Android SDK correspond to the phone's Android system. In addition you can try to use the NDK and Android SDK version used in this article to test. In the end, if building still fails, please send a question to the Forum with the Creator 3D version, the build log file in the Build panel, and a demo that reproduces the problem. "},"editor/publish/debug-jsb.html":{"url":"editor/publish/debug-jsb.html","title":"Debuging JavaScript on Native Platforms","keywords":"","body":"Debugging JavaScript on Native Platforms After a game is released on the native platform, because the runtime environment is different, there may be some bugs that cannot be reproduced in the browser preview. This means we must debug it directly on the native platform. Cocos Creator 3D makes it easy to debug JavaScript remotely in the native platforms. Debugging on Android / iOS If a game can only run on a physical device, then the packaged game must be debugged on a physical device. Debugging steps are as follows: Make sure that the Android / iOS device is on the same LAN as Windows or Mac. Select the Android/iOS platform and Debug mode in the Build panel to build, compile and run a project (The iOS platform recommends connecting to the physical device via Xcode to compile and run). Open address with Chrome browser: devtools://devtools/bundled/js_app.html?v8only=true&ws={IP}:6086/00010002-0003-4004-8005-000600070008, where {IP} is the local IP of the Android/iOS device, then you can debug it. Debugging on Windows / Mac The steps for debugging a game on the Windows / Mac platform are similar to the Android / iOS, just compile the project and run it in the IDE. Compile and run the packaged project with the IDE (Visual Studio for Windows and Xcode for Mac). Open Chrome while the game is running and enter the address: devtools://devtools/bundled/js_app.html?v8only=true&ws=127.0.0.1:6086/00010002-0003-4004-8005-000600070008 to debug it. Other Platform Debugging If you need to debug in Release mode, or if you need to debug a custom native engine, please refer to the JSB 2.0 Use Guide: Remote Debugging and Profile documentation. "},"editor/publish/publish-in-command-line.html":{"url":"editor/publish/publish-in-command-line.html","title":"Publishing from the Command Line","keywords":"","body":"Publishing from the Command Line Publish a project from the command line can help us build an auto-publish routine that allows modifying command line parameters to achieve different goals. Command Reference For example: Build Web Desktop with debug mode enabled: Mac /Applications/CocosCreator3D.app/Contents/MacOS/CocosCreator3D --project projectPath --build \"platform=web-desktop;debug=true\" Windows CocosCreator3D/CocosCreator3D.exe --project projectPath --build \"platform=web-desktop;debug=true\" Currently, when using the command line to build, except for the required build options, if no parameter values are uploaded, the default values are used to build. Please refer to the description below and the platform's build options description for specific default values. Exit Codes 332 Build failed —— Invalid build parameters. 334 Build failed —— Some unexpected errors occurred during the build process, please refer to the build log for details. 336 Build success. Publish Parameters --project: Required, specify the project path. --build: Specify the parameters to be used when building the project. If no parameters are specified after --build, then the parameters used in the Build panel, such as platforms, templates, and so on, will be used as default parameters. If additional parameter settings are specified, the default parameters will be overwritten with the specified parameters. The available parameters are: configPath: Parameter file path. If define configPath, then Cocos Creator 3D will load this file as a build parameter in the JSON file format. This parameter can be modified by yourself or exported directly from the Build panel. includedModules: Package modules for custom engines. Only the required modules are packaged. Note: The pass is an array of module entry fields, see this documentation for details. taskName: Build task name, the name of the release folder generated after the build. name: Game name platform: Required, the platform needs to be built. buildPath: The game's release path, the default release path is in the build under the project folder. startScene: The uuid of the main scene (the participating scene will use the build option parameters in the Build panel from the last build), and the first scene from the Included Scenes will be used if not specified. scenes: Information about the scenes involved in the build, which defaults to all scenes when not specified. debug: Whether or not debug mode, the default is false. mergeStartScene: Whether or not to merge all JSON that the initial scene depends on, the default is false. packAutoAtlas: Enabled or disabled the Auto Atlas, the default is false. compressTexture: Enabled or disabled the compress texture, the default is false. replaceSplashScreen: Whether to replace the splash screen, the default is false. md5Cache: Enabled or disabled the MD5 Cache, the default is false. Each platform's build will be embedded in the Build panel as a separate plugin, so each platform's build options are in different locations, and the build options are in packages.platform-name.key. For example, to specify the build options for the WeChat Mini Game, the configuration is as follows: { taskName: 'wechatgame', packages: { wechatgame: { appid: '*****', } } } After the build plugin system is opened to the public, the configuration parameters of other plugins are embedded in the Build panel in the same way. Please refer to the documentation of each platform for the specific parameter fields of each platform, it is better to use the Export function of the Build panel to get the configuration parameters. Currently it is still compatible with the old version of the parameters to build, but the compatibility process will be gradually removed later, so please upgrade the configuration parameters as soon as possible. Publishing using Jenkins Cocos Creator 3D still needs the GUI environment when running from the command line. If the Jenkins server can not run Cocos Creator 3D from the command line, a solution is running Jenkins in agent mode, so it can interact with the operating systems window server. For more details please review this Stack Overflow post. If the Jenkins server can not compile under Windows, specify a local user for the Jenkins service in the Windows Control Panel -> Administrative Tools -> Services, and then restart the computer. You don't need to set up a master-slave mode separately. "},"editor/publish/custom-project-build-template.html":{"url":"editor/publish/custom-project-build-template.html","title":"Custom Project Build Process","keywords":"","body":"Custom Project Build Process Custom Project Build Template Cocos Creator 3D supports custom build templates for each project. Add a build-templates folder to the project path, divide the sub-folder according to the platform path. Then all the files in this folder will be automatically copied to the build generated project according to the corresponding folder structure after the build. Currently, all platforms except the native platform support this function, the specific platform name can be referred to the following custom build template platform support table. Folder Structure: project-folder |--assets |--build |--build-templates |--web-mobile |--index.html If the current platform is web-mobile, then build-templates/web-mobile/index.html will be copied to build/web-mobile/index.html. In addition to this, build templates can be customized in the following ways. ejs type Since the content of the package is not guaranteed to be exactly the same in every version, when the build template within the editor is updated, the developer also needs to update the build template within their project. Now add a new way to use the template, click on Project -> Create preview template in the main menu, and an .ejs template file will be generated for the corresponding platform. project-folder |--assets |--build |--build-templates |--web-mobile |--index.ejs Parameters are imported into these templates during the build, and content that is frequently changed during the build is placed in sub-templates of that template. You only need to modify what you want to use, so that the build templates within the project can be updated less frequently. Note: The copy template occurs after the rendered template. For example, if both index.ejs and index.html exist in this directory, the final packaged package will be the index.html file instead of the index.ejs rendered file. JSON Type Many mini games have their own configuration JSON files, like game.json to WeChat Mini Games. Files in the build templates folder will just copy in default, but this configuration JSON will be merged instead of overwrite. Of course, it doesn't mean that all JSON file will be merged, you can check it in the tables below. Custom build template platform supports tables The JSON files corresponding to the data fusion for each mini game are as follows: Platform Actual Name Custom Build Template WeChat Mini Game wechatgame game.ejs, game.json, project.config.json Web Mobile web-mobile index.ejs Web Desktop web-desktop index.ejs Xiaomi Quick Game xiaomi-quick-game manifest.json Huawei Quick Game huawei-mini-game Use the Build Panel's Cocos Play cocos-play game.config.json Baidu Mini Game baidu-mini-game game.json, project.swan.json OPPO Mini Game oppo-mini-game manifest.json vivo Mini Game vivo-mini-game project.config.json Alipay Mini Game alipay-mini-game game.json Native native X (Not recommended) Custom Build Plugins It is currently in the internal testing phase and is not open to the public at this time. "},"editor/publish/build-guide.html":{"url":"editor/publish/build-guide.html","title":"Build Process with FAQ","keywords":"","body":"Build Process with FAQ The build process is mainly divided into two parts, the General Build Process and the Platform Adaptation Process. The adaptation processing logic for each platform will be embedded in the Build panel as a separate plugin. The build plugin system is then open and developers can dynamically embed some build parameters into the panel for use. General build Process The general build process for Cocos Creator 3D consists of the following: Initialization of build parameters Prepare build data Write the built asset to the file system Organizing the data of settings Compression and writing of settings uuid Initialization of build parameters This step mainly initializes the initial options passed to the build to the internal options of the build, does some parameter formatting, initializes the asset data of the build asset database, loads the latest asset information, and classifies it. Prepare build data The editor will first summarize the scene currently involved in the build and all assets in the resources directory. Each asset is packaged through the engine's deserialization process to find the dependent asset and recursion to pack the assets. The entire project's scripting environment is configured before being deserialized, that is, all non-plugin project scripts are loaded. Because whether the script loads correctly or not directly affects the deserialization, failure to load because the script is not written legally will directly result in build failure. If the dependent asset is lost in the deserialization process, a warning is issued, but the build continues nonetheless. The warning here does not mean that the problem does not need to be resolved, and if the asset loss is not resolved, it is difficult to guarantee that the problem will not occur after the build. This step will also sort out the asset types based on the build's internal division, such as scenes, scripts, texture compression tasks, JSON grouping information, etc., and weed out asset information that is not used. Note: All user scripts are loaded before this step is performed. Write the built asset to the file system After performing the previous steps, then we need to generate the used assets into the file system. After building, the serialized JSON files of all assets are placed in the res/import directory. The original files of all assets are placed in the res/raw-assets directory. The build process can be broken down into the following phases: Build scripts: The scripts in the editor are divided into plugin scripts and non-plugin scripts. The plugin script will copy the source file to the build/src directory, which is generated after the build based on the original directory structure. The plugin script does not support any script that needs to be compiled, such as TS or JS written in ES6. The asset information of the plugin script is written to the jsList array in settings. The non-plugin script will package the source files into project.js (project.dev.js in debug mode) in the corresponding src directory. Checking the sourceMap option will generate a corresponding map file, and the debug option will determine whether the script is compressed or not. Auto Atlas: Query all Auto Altas assets in the project, and then pack SpriteFrame assets within Auto Altas into a big Sprite Atlas assets, serialize assets to JSON according to the configuration of Auto Atlas assets. This step will modify the JSON grouping information, asset asset grouping information and add texture compression task. If the packAutoAtlas option in the Build panel is not checked during the build, no processing is done. Compress Texture: Compress the texture assets according to the organized texture compression tasks and write them to the folder generated after build. If the Compress Texture option in the Build panel is not checked during the build, no processing is done. Build engine: Follow the settings in the menu bar Project -> Project Setting -> Modules to discard the unused engine modules, and package them into the src/cocos3d.js file. Checking the sourceMap option will generate a corresponding map file. Checking the debug option will determine whether the script is compressed or not. The main steps in building the engine are as follows: Get the engine module information in the menu bar Project -> Project Setting -> Modules. Check if the engine version in the cache is the same as the engine version that needs to be compiled, and if it is, copy it without compiling. If compilation is required, perform the task of packaging the engine according to the engine interface. Copy the compiled js file and save the engine's modification time. When compiling the engine, you can view the output log information. Please refer to the log information documentation for the detail log viewing method. Rules for reusing engine files: The packaged engine files will be placed in the bin/.cache/.editor-cache directory of the engine, according to the hash values generated by the parameters that affect the engine compilation. And the .watch-file.json file contains the modification times for the individual engine files. engine-folder |--bin |--.cache |--.editor-cache |-- 1dc4a547f9...63a43bb8965.watch-files.json |-- 1dc4a547f9...63a43bb8965 |-- 1dc4a547f9...63a43bb8965.map ... As soon as any of the engine's build options change, the engine will recompile. Specifically affecting the engine build are: debug: Whether in debug mode includeModules: Setting engine modules sourceMaps: Whether or not to enable sourceMap platform: Build platform the modification times for the engine files. build JSON: Serialized JSON is merged based on the JSON grouping and written to the file system (placed in the res/import directory). If in release mode, compression is also performed on the uuid in the serialized JSON. General assets copy: Some of the original assets (rawAssets) in the library are copied directly into the res/raw-assets folder generated after the build. MD5 Cache: Add the MD5 suffix to all the assets in the res folder and organize the data to record in settings. Generate main.js template file: Configure project settings into the main.js folder according to the the developers specified options. Generate them in the build output directory. Organizing the data of settings The main thing is to prepare the necessary configuration information for the game start based on the data of previous asset collation. About the structure of settings: { debug: boolean; // Whether in debug mode designResolution: { // Canvas resolution width: number; // The width of canvas resolution height: number; // The height of canvas resolution policy: number; // Full screen aspect adapted mode }; launchScene: string; // URL of the initial scene platform: string; // Platform rawAssets: { [index: string]: { [uuid: string]: string[] } }; // Store the asset URL and type loaded in assets // Example: \"bba00d3a-2f17-4511-b47c-0d584b21b763@6c48a\": [\"test/right/texture\", \"cc.Texture2D\", \"bba0...@6c48a\"] // \"bba0...@6c48a\": [\"test/right/texture\", 1, 1] scenes: Array; // The array of scenes information involved in the run scriptPackages: Array; // Script message array jsList: string[]; // Script plugin array moduleIds: string[]; // Information on all user script components packedAssets: Record; // json grouping information md5AssetsMap: { [index: string]: Array }; // It is not available until md5Cache is checked, and the array is stored in the format of [uuid_1, md5_1, uuid_2, md5_2, ...]. If uuid_1 is a simple number, it means that the uuid index in the uuids array is stored. uuids: string[]; // Arrays of uuid, only takes effect in release mode assetTypes?: string[]; // Arrays of asset types, only takes effect in release mode subpackages?: Record; // Subpackage asset information renderPipeline: string; // renderPipeline information } The structure here only lists the settings structure under the general build process, and actually adds configurations as needed when packaging for different platforms. Compression and writing of settings uuid During the asset packaging process, the uuid of all assets involved in the build are continuously collected and then organized into setting.js. setting.js will be written to the build/src directory, which isgenerated after the build. The uuid in the file will be compressed or not, depending on whether it is in debug mode or not. Organize all used uuid and store the uuid that appear more than twice in the uuids array, and replaced with indexes. All assetType that appear more than twice are also stored in the assetTypes array, and replaced with indexes. Build assets At this stage, the editor will arrage the scenes assets that selected in Build panel and all assets in the assets directory. All assets will be deserialized by engine to find out the dependent assets in deep. Before deserialization, editor will load all the scripts（expect plugin scripts) in the project, if the script is written illegally and fails to load, it will make this build task stop immediately. If any dependent asset is missing during the deserialization process, a warning info will be print, but editor will continue to build. When warning info is printed, we recommend you to read and try to resolve it, otherwise it may cause some unexpect errors after build. During the packaging process, the assets will be re-compressed and serialized after deserialization to reduce the package size. Also, all serialized files will be sorted into deferent JSON groups to reduce the size of game package. Assets that perform deserialization during the packing process will recompress the serialization to reduce the package size after packing. The serialized files of the texture assets are all packaged into a single JSON file, and the other serialized files are subpackaged according to the build options configuration. Build scripts The scripts in the editor are divided into plugin script and non-plugin script. The plugin script will copy the source file to the build/src directory generated after the build based on the original directory structure, so the plugin script does not support any script that needs to be compiled, such as TS or JS written in ES6. The asset information of the plugin script is written to the jsList array in settings. The non-plugin script will package the source files into project.js (project.dev.js in debug mode) in the corresponding src directory. Platform Adaptation Process The build provides a partial lifecycle hook function that facilitates the developer's involvement in the build during the different processing periods of the build. The build also provides a way for developers to add build options directly, as well as to modify the UI interface of the build panel, data verification, etc. At the moment these features are not open to the public, only briefly described here, but the platform building plugins within the editor have been developed in this way. Frequently asked questions The entire build process is in a separate worker, so if you want to see the log information during the build, please refer to the Build Log. Please make sure that the scenes involved in the build can be previewed properly before the build, some of the scenes asset loss, script compilation failure problems can be exposed in the preview stage. Building on the premise of a normal preview allows for better troubleshooting and saves time. Assets loading with a 404 In this case, please copy the uuid in the lost asset error message to Assets to find the corresponding asset, and then see if all the assets on which the asset depends are normal. Assets loading with a 404 usually occurs in the following situations: Assets that are not in resources are dynamically loaded in the script Reason: Only the assets in the resources directory and those involved in building the scene will be packaged into the final release package. And only the asset url in the resources directory will be written to settings.js, if an asset is used in the script but not in the resources directory, then a 404 will appear when it is loaded. Solution: Move the used assets to the resources directory. The loaded asset had a problem when it was imported, causing the data to not be generated properly into the library Reason: All raw data during the build is obtained by reading the asset file in the library, and if the import fails, the correct corresponding asset information will not be obtained. Solution: Find the corresponding asset through Assets panel, right click it, and select Reimport Asset in the menu. Lost assets Reason: asset builds look for dependencies through engine deserialization, and the most frequent problem is that the dependent asset is accidentally deleted during the project iteration, resulting in the loss of the asset. The loss of these assets may not normally be noticed, but will be exposed once the build is executed. Solution: Use the Code Editor to find out which assets the uuid is referenced by, and then modify the corresponding assets. Script asset load error The scripting environment needs to be configured for the build. If the error message is related to the script, please refer to the error message to modify the script. If it is not clear which script is reporting the error, you can find the uuid of the corresponding script in the error message's call stack, and then look for the location in Assets. Find the image merged from Auto Atlas The Auto Atlas prints the uuid information of the original small image and the merged large image during the build process, the uuid can be found in the Build devTools, then the large image can be found by searching in the res/raw-assets folder generated after the build using the uuid of the found large image. If there are too many images, you can search for uuid directly in the build log. Engine compilation failed. If it's a custom engine compilation failure, check your modified code, or custom engine path. "},"editor/publish/publish-alipay-mini-game.html":{"url":"editor/publish/publish-alipay-mini-game.html","title":"Publishing to Alipay Mini Games","keywords":"","body":"Publishing to Alipay Mini Games Note: Some platforms only have Chinese documentation available when visiting the platforms website. It may be necessary to use Google Translate in-order to review the documentation. Cocos Creator 3D officially supports the release of games to the Alipay Mini Games. Environment Configuration Download Alipay Mini Program Studio on the PC and install it. Download Alipay and install it on your phone. The minimum supported version of Alipay on Android is 10.1.75, on iOS is 10.1.78. Release Process First, use Cocos Creator 3D to open the project that needs to be released. Select Alipay Mini Game in the Platform dropdown of the Build panel, and then click Build. The specific filling rules for the relevant parameter configuration are as follows: Polyfills - Polyfills are optional. If this option is checked at build time, the resulting release package will have the corresponding polyfills in it, and will also increase the size of the package. Developers can choose polyfills on demand, but only Async Functions are currently available. Remote URL - Remote URL is optional. For details, please refer to the Resource Management for Alipay Mini Game Environment section below. Second, after the build is completed, click the folder icon button below the alipay-mini-game build task to open the build release path. If the Build Task Name is alipay-mini-game, you can see that the Alipay Mini Game's project folder alipay-mini-game is generated in the build directory, which has included Alipay Mini Game environment configuration file game.json. Third, use Alipay Mini Program Studio to open alipay-mini-game directory. Next, you can open alipay mini game project to preview and debug game content. Resource Management for Alipay Mini Game Environment Alipay Mini Game is similar to WeChat Mini Game. There are restrictions on the package size. Assets more than 4MB must be downloaded via a network request. It is recommended to only save script files in the mini-game packages, while other assets are uploaded to the remote server, and downloaded from the remote server as needed. The download, cache, and version management of remote assets, Cocos Creator 3D has already done it for you. The specific implementation logic is similar to the WeChat Mini Game. Please refer to the Resource Management for WeChat Mini Game Environment documentation for details. Specifically, developers need to: Set the Remote URL in the Build panel. And then click Build. When the build is complete, upload the build/alipay-mini-game/res folder to the server. Delete the res folder under the local release package directory. Alipay Mini Games Known issues Currently, our adaptation of Alipay Mini Games has not been completely completed, and the following modules are still not supported: WebView VideoPlayer Subpackage Loading Custom Font The above functions are expected to be gradually supported in future updates. "},"editor/publish/publish-baidugame.html":{"url":"editor/publish/publish-baidugame.html","title":"Publishing to Baidu Mini Games","keywords":"","body":"Publishing to Baidu Mini Games Note: Some platforms only have Chinese documentation available when visiting the platforms website. It may be necessary to use Google Translate in-order to review the documentation. Cocos Creator 3D officially supports the release of games to the Baidu Mini Games. The runtime environment of the Baidu Mini Game is an extension of the Baidu Smart Mini Program. This provides a WebGL interface encapsulation based on the mini program environment. This greatly improves the rendering capabilities and performance. However, since these interfaces are encapsulated by the Baidu team, they are not equivalent to the browser environment. On the engine side, in order to make the developers' workload as easy as possible, our main tasks for developers include the following: The engine framework adapts to the Baidu Mini Game API, pure game logic level, developers do not need any additional modifications. The Cocos Creator 3D editor provides a fast packaging process, released directly as a Baidu Mini Game, and automatically evokes the Baidu DevTools. Automatically load remote assets, cache assets, and cache asset version control. Please refer to the Baidu Mini Game Developer Documentation documentation to review the game submission, the review, and the release process for a Baidu Mini Game. Publish Baidu Mini Games with Cocos Creator 3D Prerequisites Download and install Baidu DevTools in Baidu DevTools Documentation. Download and install the Baidu App in the app store of your phone. Log in to Baidu Smart Mini Progame Platform and find App ID. Release process Select the Baidu Mini Game in the Platform of the Build panel, fill in the appid, and then click Build. After a build is completed, a baidu-mini-game folder will be generated in the project's build directory (the name of the folder is based on the Build Task Name), which already contains the configuration files game.json and project.swan.json of the Baidu Mini Games environment. Use the Baidu DevTools to open the baidu-mini-game folder to preview and debug the game. Please refer to the Baidu DevTools documentation for details. About how ​​to use Baidu DevTools, please refer to Baidu DevTools Documentation for details. Note: When previewing and debugging, if a prompt appears stating: The current version of the developer tool can't publish mini program, please update to the latest devtools. This means the appid filled in the Build panel is the appid of the Baidu Smart Mini Program, not the appid of the Baidu Mini Game, please re-apply for the appid of the Baidu Mini Game. asset Management for Baidu Mini Game Environment Baidu Mini Game is similar to WeChat Mini Game. There are restrictions on the package size. Assets more than 4MB must be downloaded via a network request. It is recommended to only save script files in the mini-game packages, while other assets are uploaded to the remote server, and downloaded from the remote server as needed. The download, cache, and version management of remote assets, Cocos Creator 3D has already done it for you. The specific implementation logic is similar to the WeChat Mini Game. Please refer to the asset Management for WeChat Mini Game Environment documentation for details. When the MD5 Cache feature of the engine is enabled, the URL of the file will change as the content of the file changes. When the game releases a new version, the assets of the old version will naturally become invalid in the cache, and only the new assets can be requested from the server, which achieves the effect of version control. Specifically, developers need to do the following: When building, check the MD5 Cache in the Build panel. Set Remote server address in the Build panel and then click Build. After the build is complete, upload the build/baidu-mini-game/res folder to the server. Delete the res folder under the local release package directory. Note: When Baidu loads the assets on the remote server on the physical device, it only supports access via HTTPS, so the asset file must be placed on HTTPS, otherwise the loading of the asset will fail. Note: If the cache asset exceeds the environment limit of Baidu, you need to manually clear the asset. You can use the remoteDownloader.cleanAllCaches() and remoteDownloader.cleanOldCaches() interfaces to clear the cache in Baidu mini game. The former will clear all cache assets in the cache directory, please use it with caution. The latter will clear the cache assets that are not used in the current application in the cache directory. Baidu Mini Game Subpackage Loading The subpackage loading method of Baidu Mini Game is similar to WeChat, with the following package restrictions: The size of all subpackages of the entire Mini Game can not exceed 8MB. The size of a single subpackage / main package can not exceed 4MB. Please refer to the SubPackage Loading documentation for details. Platform SDK Access In addition to pure game content, the Baidu Mini Game environment also provides a very powerful native SDK interface. These interfaces only exist in Baidu Mini Game environment, equivalent to the third-party SDK interface of other platforms. The porting of such SDK interfaces still needs to be handled by developers at this stage. Here are some of the powerful SDK capabilities offered by Baidu Mini Game: User interface: login, authorization, user information, etc. Baidu cashier payment Forwarding information File upload and download Other: images, locations, ads, device information, etc. Baidu Mini Games known issues Currently, the adaptation work of Baidu Mini Game is not completely finished, and the following components are not supported for the time being: VideoPlayer WebView If needed, you can directly call Baidu's API as needed. Reference documentation Note: Some platforms only have Chinese documentation available when visiting the platforms website. It may be necessary to use Google Translate in-order to review the documentation. Baidu Mini Game Registration Guide Baidu DevTools documentation Baidu Mini Game API documentation "},"editor/publish/publish-bytedance-mini-game.html":{"url":"editor/publish/publish-bytedance-mini-game.html","title":"Publishing to ByteDance Mini Games","keywords":"","body":"Publishing to ByteDance Mini Games Note: Some platforms only have Chinese documentation available when visiting the platforms website. It may be necessary to use Google Translate in-order to review the documentation. ByteDance Mini Games are developed based on ByteDance full products, which do not require users to download. This is a brand-new game type that can be played on tap. The game submission, review and release process of a mini-game needs to comply with the requirements and standard processes of the Byte official specification. For specific information, please refer to the links at the end of this document. Publishing to ByteDance with Cocos Creator 3D Download the ByteDance DevTools on ByteDance Official Website. Log in to Developer Platformto find your mini game appid. For details, please refer to the official Access Guide documentation. Select the ByteDance Mini Game in the Platform in the Build panel, fill in the mini game appid, and then click Build Preview game Following this process, a bytedance-mini-game folder will be generated in the project's build directory (the name of the folder is based on the Build Task Name), then you can open your game with the ByteDance DevTools. Build Options Options Optional or not Default Explanation appid Required testId The appid of the ByteDance Mini Games, it will be written to project.config.json file. Remote server address Optional Empty The remote server address. Resources will then be obtained from this address. Open data context root Optional Empty If an Open Data Context exists, use this root to specify the relative path of the Open Data Context folder in the build directory so that the directory is not overwritten or modified during the build. Orientation Required landscape Device orientation, it will be written to game.json file. Asset Management for ByteDance Mini Game Environment In a ByteDance Mini Game environment, asset management is the most special part. It differs from the browser in the following four points: The size of the ByteDance Mini Game package cannot exceed 4MB, including all the code and assets. Additional assets must be downloaded via web request. For files downloaded from a remote server, the ByteDance Mini Game environment does not have the browser's caching and outdated update mechanism. For the assets in the ByteDance Mini Game package, they are not loaded on demand in the mini game environment, but rather all the assets in the package are loaded at once, and then the game page is launched. You cannot download script files from a remote server. This brings up two key issues, home page loading speed and remote asset caching and version management. For the home page loading speed, we recommend that developers only save the script file in the ByteDance Mini Game package, and all other assets are downloaded from the remote server. As for downloading, caching and version management of remote assets, Cocos Creator 3D has done the job for developers. Specifically, developers need to do the following: When building, enable the MD5 Cache in the Build config panel. Set the Remote service address, and then click Build. When the build is complete, upload the res folder in the mini game release package to the server. Delete the res folder inside the local release package. For the test phase, you may not be able to deploy to the official server, you need to use the local server to test, then open the details page in the WeChat DevTools, check the Does not verify valid domain names, web-view (business domain names), TLS versions and HTTPS certificates option in the Local Settings. Reference documentation Note: Some platforms only have Chinese documentation available when visiting the platforms website. It may be necessary to use Google Translate in-order to review the documentation. ByteDance Mini Game Developer Document Guide ByteDance Developer Platform ByteDance Mini Game API Documentation ByteDance DevTools Download ByteDance DevTools Documentation "},"editor/publish/publish-cocos-play.html":{"url":"editor/publish/publish-cocos-play.html","title":"Publishing to Cocos Play","keywords":"","body":"Publishing to Cocos Play Note: Some platforms only have Chinese documentation available when visiting the platforms website. It may be necessary to use Google Translate in-order to review the documentation. Cocos Creator 3D officially supports the release of games to the Cocos Play. Publish Cocos Play with Cocos Creator 3D Prerequisites Download and install the Cocos Play Self-test Tools on your Android device (recommended Android Phone 6.0 or above). Build Use Cocos Creator 3D to open a project. Select Cocos Play in the Platform dropdown of the Build panel, and then click Build. The specific filling rules for the relevant parameter configuration are as follows: tinyPacketMode This item is optional. The in-package volume of the game contains code and assets that cannot exceed 10M, and assets can be loaded via network requests. tinyPacketMode is to help developers keep the script files in the game package, other assets are uploaded to the remote server, and downloaded from the remote server as needed. And the download, cache and version management of remote assets, Cocos Creator 3D has already helped the developer. What the developer needs to do is the following steps: When building, check the tinyPacketMode and fill in the tinyPacketModeServer. First game asset package into the game package, this item is optional. In the tinyPacketMode, due to too many assets on the launch scene, downloading and loading assets for a long time may result in a short black screen when entering the game for the first time. If First game asset package into the game package is checked, you can reduce the black screen time when you first enter the game. However, it should be noted that the res/import asset does not support split asset downloading at this time, and the entire import directory is also packaged into the first package. Developers can choose whether to check this item according to their needs. Then click on Build. After the build is complete, click the Open button after the Build Path to upload the res directory under the release path to the server. For example, if the default release path is build, the Build Task Name is cocos-play, you need to upload the /build/cocos-play/res directory. At this point, the res directory will no longer be included in the built-up cpk, and the assets in the res directory will be downloaded from the filled tinyPacketMode Server Path through the network request. The build parameters when publishing from the command line: tinyPackageMode: false, tinyPackageServer: '', packFirstScreenRes: false, After the build is completed, click the folder icon button below the cocos-play build task to open the build release path. If the Build Task Name is cocos-play, you can see that a cocos-play folder is generated in the build directory. This folder is the exported Cocos Play game project and cpk, the cpk package is in the build/cocos-play directory. Access testing Developers must use the Cocos Play Self-test Tools to test access without problems before submitting to the platform for review. The size of the package is not required for the self-test, but if it is to be submitted for review, the package size cannot exceed 10M. The Self-test Tools can launch the game and provide features such as game login, payment, etc. By reading the game configuration parameters, you can determine the type of game to start and how the game will start. For details, please refer to the Self-test Tools documentation. Open the previously installed Self-test Tools, then click the Configure Game button at the top left of the Self-test Tools to enter the game configuration page. Configure parameters as required and click Save. Parameters Parameters Function Explanation gameId Game ID, which can be obtained from the background. gameKey Game key, which can be obtained from the background. gameSecret Game secret key, which can be obtained from the background. gameType Game type, including Versus and non-Versus. You can see how to use it in the Start Game section below. gameMode Game mode, please select Runtime. lodeType Game load type, which is how the game starts. Includes both File and Url. Please refer to the Start Game section below. path Game load address, needs to be used with lodeType. Please refer to the Start Game section below. Start Game There are two ways to start the game through the Self-test Tools. Load the game package as a file from the specified location (The game lodeType is File). Copy the .cpk file generated after the build to the device directory, if it is copied to the sdcard directory of device, you need to create a new folder (named cocosplay) in the sdcard directory and copy the .cpk to the cocosplay folder. Select File in the lodeType of the game configuration page. Fill in the path to the cocosplay folder where the .cpk file is placed in the path option. Such as /cocosplay/game.cpk. Click on Save after the configuration is complete, then click on Start Game to open the game. Open the game as a web page from the specified URL (The game lodeType is Url). Upload the .cpk file to the server. Select Url in the lodeType of the game configuration page. Fill in path, such as: http://192.168.0.1:8080/game.cpk. Click on Save after the configuration is complete, then click on Start Game to open the game. Reference documentation Note: Some platforms only have Chinese documentation available when visiting the platforms website. It may be necessary to use Google Translate in-order to review the documentation. Cocos Play Center Cocos Play Documentation Center Cocos Play API Documentation Cocos Play Self-test Tools Cocos Play Self-test Tools Download "},"editor/publish/publish-huawei-mini-game.html":{"url":"editor/publish/publish-huawei-mini-game.html","title":"Publishing to Huawei Quick Games","keywords":"","body":"Publishing to Huawei Quick Games Note: Some platforms only have Chinese documentation available when visiting the platforms website. It may be necessary to use Google Translate in-order to review the documentation. Cocos Creator 3D officially supports the release of games to the Huawei Quick Games. Environment Configuration Download the Huawei Quick APP Loader and install it on your Android device (Android Phone 6.0 or above is recommended) Install nodejs-8.1.4 or above, globally. Release Process Use Cocos Creator 3D to open the project that needs to be released. Select Huawei Quick Game in the Platform dropdown of the Build panel. Click on the huawei-mini-game below to expand the parameter configuration of Huawei Quick Game. The specific filling rules for the relevant parameter configuration are as follows: Game Package Name Game Package Name is filled in according to the developer's needs. It's required. Desktop Icon Desktop Icon is required. Click the search icon button at the back of the input box to select the icon you want. When building, the Desktop Icon will be built into the Huawei Quick Game project. It is suggested that the Desktop Icon is a .png image. Game Version Name This item is required. Game Version Name is the real version, such as: 1.0.0. Game Version Number This item is required. Game Version Number is different from the Game Version Name, and the Game Version Number is mainly used to distinguish the version update. Each time when you submit audit, the game version number is at least 1 higher than the value of the last submitted audit. It must not be equal to or less than the value of the last submitted audit, and it is recommended that the Game Version Number be recursively incremented by 1 each time when the audit is submitted Note: The Game Version Number must be a positive integer. Supported Minimum Platform Version Number This item is required. According to the requirements of Huawei Quick Games, this value must be greater than or equal to 1035. Custom manifest file path (optional) This is an optional item, which is the expansion function of Huawei Quick Game. When used, you need to select a JSON file, and the data type in the file is required to be in JSON format. Note: The JSON data is not available when the key value are package, appType, name, versionName, versionCode, icon, minPlatformVersion, config, display, otherwise it will be overwritten by data such as Game Package Name, Game Name, Desktop Icon, Game Version Name, Game Version Number during the build. Build Sub Package This option is enabled by default. For details, please refer to Subpackage at the end of this document. Small Packet Mode This item is optional. The in-package volume of the mini-game contains code and assets that cannot exceed 10M, and assets can be loaded via network requests. Small Packet Mode is to help developers keep the script files in the mini game package, other assets are uploaded to the remote server, and downloaded from the remote server as needed. And the download, cache and version management of remote assets, Cocos Creator 3D has already helped the developer. What the developer needs to do is the following steps: When building, check the Small Packet Mode and fill in the Small Packet Mode Server Path. First game asset package into the game package, this item is optional. In the Small Packet Mode, due to too many assets on the launch scene, downloading and loading assets for a long time may result in a short black screen when entering the game for the first time. If First game asset package into the game package is checked, you can reduce the black screen time when you first enter the game. However, it should be noted that the res/import asset does not support split asset downloading at this time, and the entire import directory is also packaged into the first package. Developers can choose whether to check this item according to their needs. Then click on Build. After the build is complete, click the Open button after the Build Path to upload the res directory under the release path to the small packet mode server. For example, if the default release path is build, the Build Task Name is huawei-mini-game, you need to upload the /build/huawei-mini-game/res directory. At this point, the res directory will no longer be included in the built-up rpk, and the assets in the res directory will be downloaded from the filled Small Packet Mode Server Path through the network request. Keystore When you check the Keystore, the default is to build the rpk package with a certificate that comes with Creator 3D. This certificate is used only for debugging. Note: When the rpk package is to be used to submit an audit, do not check the Keystore to build it. If you don't check the Keystore, you need to configure the signature files certificate.pem path and private.pem path, where you build a rpk package that you can publish directly. The user can configure two signature files by using the search icon button to the right of the input box. There are two ways to generate a signature files: Generated by the New button after the certificate.pem path in the Build panel. Generated by the command line. The user needs to generate the signature file private.pem, certificate.pem through tools such as openssl. # Generate a signature file with the openssl command tool openssl req -newkey rsa:2048 -nodes -keyout private.pem -x509 -days 3650 -out certificate.pem Note: openssl can be used directly in the terminal in Linux or Mac environment, and in the Windows environment you need to install openssl and configure system environment variables. Restart Cocos Creator 3D after the configuration is complete. 2. Build After the relevant parameters of the Build panel are set, click Build. When the build is complete, click the folder icon button below the corresponding build task to open the build release path, you can see that a directory with the same name as the Build Task Name is generated in the default release path build directory, which is the exported Huawei Quick Game project directory and rpk, rpk package are in the dist directory. 3. Run the built rpk to the phone Copy the rpk package generated by the build to the sdcard directory of the Android device. Open the Huawei Quick APP Loader that has been installed before, clicking the back button on the Android device will bring up a list, select the Local Install, select the path of place rpk, and then you can run the rpk on the Android device. 4. Subpackage rpk Subpackage rpk can be used according to your needs. Subpackage loading, that is, splitting the game content into several packages according to certain rules, only downloading the necessary packages when starting up for the first time. This necessary package is called main package. And the developer can trigger in the main package to download other sub-packages, which can effectively reduce the time spent on the first boot. To use this function, you need to set the Subpackage Configuration in Cocos Creator 3D, and the package will be automatically subpackaged when the setting is completed. After the build is complete, the generated subpackages and main package are merged into one rpk, which is in the /build/huawei-mini-game/dist directory. Note: Currently, Huawei Quick Game does not support downloading multiple subpackages at the same time, please download them in order if you need to download multiple subpackages. Reference documentation Note: Some platforms only have Chinese documentation available when visiting the platforms website. It may be necessary to use Google Translate in-order to review the documentation. Huawei Quick Game development documentation "},"editor/publish/publish-oppo-mini-game.html":{"url":"editor/publish/publish-oppo-mini-game.html","title":"Publishing to OPPO Mini Games","keywords":"","body":"Publishing to OPPO Mini Games Note: Some platforms only have Chinese documentation available when visiting the platforms website. It may be necessary to use Google Translate in-order to review the documentation. Cocos Creator 3D officially supports the release of games to the OPPO Mini Games. Environment Configuration Download OPPO Mini Game Debugger and install it on your Android device (Android Phone 6.0 or above is recommended) Install nodejs-8.1.4 or above, globally Determine whether you need to install the Debugging Tools according to your own development needs. Release Process Use Cocos Creator 3D to open the project that needs to be released. Select OPPO Mini Game in the Platform dropdown of the Build panel. Click on the oppo-mini-game below to expand the parameter configuration of OPPO Mini Game. The specific filling rules for the relevant parameter configuration are as follows: Game Package Name: is filled in according to the user's needs. It's required. Desktop Icon: is required. Click the search icon button at the back of the input box to select the icon you want. When building, the Desktop Icon will be built into the OPPO Mini Game project. It is suggested to use PNG images for the Desktop Icon. Game Version Name: is required. Game Version Name is the real version, such as: 1.0.0. Game Version Number: is required. Game Version Number is different from the Game Version Name, and the Game Version Number is mainly used to distinguish the version update. Each time when you submit audit, the game version number is at least 1 higher than the value of the last submitted audit. It must not be equal to or less than the value of the last submitted audit, and it is recommended that the Game Version Number be recursively incremented by 1 each time when the audit is submitted. Note: The Game Version Number must be a positive integer. Supported Minimum Platform Version Number: is required. According to the requirements for OPPO Mini Games, this value must be greater than or equal to 1031. Small Packet Mode: is optional. The in-package volume of the mini-game contains code and assets that cannot exceed 10M, and assets can be loaded via network requests. Small Packet Mode is to help users keep the script files in the mini game package, other assets are uploaded to the remote server, and downloaded from the remote server as needed. And the download, cache and version management of remote assets, Cocos Creator 3D has already helped the developer. What the developer needs to do is the following steps: When building, check the Small Packet Mode and fill in the Small Packet Mode Server Path. First game asset package into the game package, this item is optional. In the Small Packet Mode, due to too many assets on the launch scene, downloading and loading assets for a long time may result in a short black screen when entering the game for the first time. If First game asset package into the game package is checked, you can reduce the black screen time when you first enter the game. However, it should be noted that the res/import asset does not support split asset downloading at this time, and the entire import directory is also packaged into the first package. Developers can choose whether to check this item according to their needs. Then click on Build. After the build is complete, click the Open button after the Build Path to upload the res directory under the release path to the small packet mode server. For example, if the default release path is build, the Build Task Name is oppo-mini-game, you need to upload the /build/oppo-mini-game/res directory. At this point, the res directory will no longer be included in the built-up rpk, and the assets in the res directory will be downloaded from the filled Small Packet Mode Server Path through the network request. Build Sub Package: this option is enabled by default. For details, please refer to Subpackage at the end of this document. Keystore: when you check the Keystore, the default is to build the rpk package with a certificate that comes with Creator 3D, which is used only for debugging. Note: When the rpk package is to be used to submit an audit, do not check the Keystore to build it. If you don't check the Keystore, you need to configure the signature files certificate.pem path and private.pem path, where you build a rpk package that you can publish directly. The user can configure two signature files by using the search icon button to the right of the input box. There are two ways to generate a signature files: Generated by the New button after the certificate.pem path in the Build panel. Generated by the command line. The user needs to generate the signature file private.pem, certificate.pem through tools such as openssl. # Generate a signature file with the openssl command tool openssl req -newkey rsa:2048 -nodes -keyout private.pem -x509 -days 3650 -out certificate.pem Note: openssl can be used directly in the terminal in Linux or Mac environment, and in the Windows environment you need to install openssl and configure system environment variables. Restart Cocos Creator 3D after the configuration is complete. 2. Build After the relevant parameters of the Build panel are set, click Build. When the build is complete, click the folder icon button below the corresponding build task to open the build release path, you can see that a directory with the same name as the Build Task Name is generated in the default release path build directory, which is the exported OPPO Mini Game project directory and rpk, rpk package are in the dist directory. 3. Run the built rpk to the phone Copy the generated mini-game rpk file to the /sdcard/games/ directory on your phone's SD card. Then open the Mini Game Debugger that has been installed before on the Android device, click the OPPO Mini Game section, and then find the icon corresponding to the game name. If not found, click on the More -> Refresh button in the upper right corner to refresh. 4. Subpackage rpk Subpackage loading, that is, splitting the game content into several packages according to certain rules, only downloading the necessary packages when starting up for the first time. This necessary package is called main package, and the developer can trigger in the main package to download other sub-packages, which can effectively reduce the time spent on the first boot. To use this function, you need to set Subpackage Configuration in Cocos Creator 3D, and the package will be automatically subpackaged when the setting is completed. After the build is complete, the subpackage directory is in the dist directory. In this case, you need to create a new subPkg directory in the sdcard directory of the Android device, and then copy the .rpk file in the dist directory to the subPkg directory. Then switch to the Package Load section of OPPO Mini Game Debugger, click Refresh at the top right to see the game name of the subpackage, click Second Open to use the same as the normal packaged rpk. Note: Subpackage rpk needs to be copied to the /sdcard/subPkg/ directory of Android devices, and non-subpackage rpk needs to be copied to the /sdcard/games/ directory of Android devices, both of which cannot be mixed. Reference documentation Note: Some platforms only have Chinese documentation available when visiting the platforms website. It may be necessary to use Google Translate in-order to review the documentation. OPPO Mini Game Tutorial OPPO Mini Game API Documentation OPPO Mini Game Tool Download OPPO Mini Game Debugging "},"editor/publish/publish-vivo-mini-game.html":{"url":"editor/publish/publish-vivo-mini-game.html","title":"Publishing to vivo Mini Games","keywords":"","body":"Publishing to vivo Mini Games Note: Some platforms only have Chinese documentation available when visiting the platforms website. It may be necessary to use Google Translate in-order to review the documentation. Environment Configuration Download the Quick App & vivo Mini Game Debugger and vivo Mini Game Engine and install it on your Android device (recommended Android Phone 6.0 or above) Install nodejs-8.9.0 or above, globally: Note: After installing nodejs, you need to note whether the npm source address is https://registry.npmjs.org/ # View current npm source address npm config get registry # If not, reset the npm source address npm config set registry https://registry.npmjs.org/ Install vivo-minigame/cli globally: npm install -g @vivo-minigame/cli If vivo-minigame/cli installation fails, it may be caused by too low version of nodejs. Please check the version of node and upgrade. Release Process Use Cocos Creator 3D to open the project that needs to be released. Select vivo Mini Game in the Platform dropdown of the Build panel. Click on the vivo-mini-game below to expand the parameter configuration of vivo Mini Game. The specific filling rules for the relevant parameter configuration are as follows: Game Package Name: is required. it is filled in according to the developer's needs. Desktop Icon: is required. Click the search icon button at the back of the input box to select the icon you want. When building, the Desktop Icon will be built into the vivo Mini Game project. It is suggested to use PNG images for the Desktop Icon. Game Version Name: is required. Game Version Name is the real version, such as: 1.0.0. Game Version Number: is required. Game Version Number is different from the Game Version Name, and the Game Version Number is mainly used to distinguish the version update. Each time when you submit audit, the game version number is at least 1 higher than the value of the last submitted audit. It must not be equal to or less than the value of the last submitted audit, and it is recommended that the Game Version Number be recursively incremented by 1 each time when the audit is submitted. Note: The Game Version Number must be a positive integer. Supported Minimum Platform Version Number: is required. Please refer to Official Documentation to check the latest version number of vivo engine. Build Sub Package: is supported by v1.0.4 onwards and is enabled by default. For details, please refer to Subpackage Loading at the end of this document. Small Packet Mode: is optional. The in-package volume of the mini-game contains code and assets that cannot exceed 10M, and assets can be loaded via network requests. Small Packet Mode is to help developers keep the script files in the mini game package, other assets are uploaded to the remote server, and downloaded from the remote server as needed. And the download, cache and version management of remote assets, Cocos Creator 3D has already helped the developer. What the developer needs to do is the following steps: When building, check the Small Packet Mode and fill in the Small Packet Mode Server Path. First game asset package into the game package, this item is optional. In the Small Packet Mode, due to too many assets on the launch scene, downloading and loading assets for a long time may result in a short black screen when entering the game for the first time. If First game asset package into the game package is checked, you can reduce the black screen time when you first enter the game. However, it should be noted that the res/import asset does not support split asset downloading at this time, and the entire import directory is also packaged into the first package. Developers can choose whether to check this item according to their needs and then click Build. After the build is complete, click the Open button after the Build Path to upload the res directory under the release path to the small packet mode server. For example, if the default release path is build, the Build Task Name is vivo-mini-game, you need to upload the /build/vivo-mini-game/res directory. Note: If you are using the command line to compile small packet mode, remember to backup the build/vivo-mini-game/res directory, then delete the build/vivo-mini-game/res directory, and then perform command line compilation (npm run build). At this point, the res directory will no longer be included in the built-up rpk, and the assets in the res directory will be downloaded from the filled Small Packet Mode Server Path through the network request. Keystore: when you check the Keystore, the default is to build the rpk package with a certificate that comes with Creator 3D, which is used only for debugging. Note: When the rpk package is to be used to submit an audit, do not check the Keystore to build it. If you don't check the Keystore, you need to configure the signature files certificate.pem path and private.pem path, where you build a rpk package that you can publish directly. The developer can configure two signature files by using the search icon button to the right of the input box. There are two ways to generate a signature files: Generated by the New button after the certificate.pem path in the Build panel. Generated by the command line. The developer needs to generate the signature file private.pem, certificate.pem through tools such as openssl. # Generate a signature file with the openssl command tool openssl req -newkey rsa:2048 -nodes -keyout private.pem -x509 -days 3650 -out certificate.pem Note: openssl can be used directly in the terminal in Linux or Mac environment, and in the Windows environment you need to install openssl and configure system environment variables. Restart Creator 3D after the configuration is complete. 2. Build After the relevant parameters of the Build panel are set, click Build. When the build is complete, click the folder icon button below the corresponding build task to open the build release path, you can see that a directory with the same name as the Build Task Name is generated in the default release path build directory, which is the exported vivo Mini Game project directory and rpk, rpk package are in the dist directory. 3. Run the built rpk to the phone There are three ways to run rpk on your phone: Method One Click the Run button at the bottom right of the vivo-mini-game build task in the Build panel and wait for the QR Code interface to be generated: Then open the Quick App & vivo Mini Game Debugger that was installed before on your Android device. Click the Scan code install button to scan the QR Code to open the rpk. Method Two Copy the generated mini game rpk file (located in the dist directory) to the sdcard directory of the mobile phone. Open the Quick App & vivo Mini Game Debugger that has been installed before on your Android device, click Local Install, then find the rpk file from the sdcard directory of your mobile phone and select Open. Method Three Specify to the editor installation directory resources/tools/vivo-pack-tools in the command line, and execute the command npm run server to generate URL and QR code using the vivo Mini Game Packer Commands. # Specify to the editor installation directory. cd F:/CocosCreator3D/resources/tools/vivo-pack-tools # Generate URL and QR code npm run server Then open the Quick App & vivo Mini Game Debugger that was installed before on your Android device. Finally, click the Scan code install button to copy the URL generated in the first step to the browser, and then directly scan the QR code on the web page to open the rpk. Subpackage Loading The subpackage loading of vivo Mini Games, is similar to WeChat Mini Games. Please refer to the Subpackage Loading documentation for details. Reference documentation Note: Some platforms only have Chinese documentation available when visiting the platforms website. It may be necessary to use Google Translate in-order to review the documentation. vivo Mini Games Development Documentation vivo Mini Games API Documentation Quick App & vivo Mini Game Debugger Download "},"editor/publish/publish-wechatgame.html":{"url":"editor/publish/publish-wechatgame.html","title":"Publishing to WeChat Mini Games","keywords":"","body":"Publishing to WeChat Mini Games Note: Some platforms only have Chinese documentation available when visiting the platforms website. It may be necessary to use Google Translate in-order to review the documentation. The runtime environment of the WeChat Mini Game is an extension of the WeChat Mini Program, providing a WebGL interface encapsulation based on the mini program environment, greatly improving rendering capabilities and performance. However, since these interfaces are encapsulated by the WeChat team, they are not equivalent to the browser environment. On the engine side, in order to make the developers' workload as easy as possible, our main tasks for developers include the following: The engine framework adapts to the WeChat Mini Game API, pure game logic level, developers do not need any additional modifications. The Cocos Creator 3D editor provides a fast packaging process, released directly as a WeChat Mini Game, and automatically evokes the WeChat DevTools. Automatically load remote assets, cache assets, and cache asset version control. In addition, the game submission, review and release process of the WeChat Mini Game is no different from the WeChat Mini Program. Please refer to the WeChat Mini Game Developer documentation. Publishing WeChat Mini Games with Cocos Creator 3D Download the WeChat DevTools on WeChat Official Document Set the WeChatGame App Path in Cocos Creator 3D -> Preferences -> Native Develop. Log in to the WeChat public platform and find the appid Select the WeChat Game in the Platform of the Build panel, fill in the mini game appid, and then click Build Click Play to open the WeChat DevTools Note: The WeChat DevTools, if it has not been run on a Mac before, will show an error that states: Please ensure that the IDE has been properly installed. You need to manually open the WeChat DevTools once, before you can click Run. Preview deployment Following this process, a wechatgame folder will be generated in the project's build directory (the name of the folder is based on the Build Task Name), which already contains the configuration files game.json and project.config.json of the WeChat Mini Games environment. Build Options Options Optional or not Default Explanation appid Required wx6ac3f5090a6b99c5 The appid of the WeChat Mini Games, it will be written to project.config.json file. Remote server address Optional Empty The remote server address. assets will then be obtained from this address. Open data context root Optional Empty If an Open Data Context exists, use this root to specify the relative path of the Open Data Context folder in the build directory so that the directory is not overwritten or modified during the build. Orientation Required landscape Device orientation, it will be written to game.json file. Build Sub Package Optional Enabled Whether to enable the Subpackage function. asset Management for WeChat Mini Game Environment In a WeChat Mini Game environment, asset management is the most special part. It differs from the browser in the following four points: The size of the WeChat Mini Game package cannot exceed 4MB, including all the code and assets. Additional assets must be downloaded via web request. For files downloaded from a remote server, the WeChat Mini Game environment does not have the browser's caching and outdated update mechanism. For the assets in the WeChat Mini Game package, they are not loaded on demand in the mini game environment, but rather all the assets in the package are loaded at once, and then the game page is launched. You cannot download script files from a remote server. This brings up two key issues, home page loading speed and remote asset caching and version management. For the home page loading speed, we recommend that developers only save the script file in the WeChat Mini Game package, and all other assets are downloaded from the remote server. As for downloading, caching and version management of remote assets, Cocos Creator 3D has done the job for developers. In the WeChat Mini Game environment, we provide a wxDownloader object, and after setting the REMOTE_SERVER_ROOT property to it, the logic of the engine to download assets becomes: Check that assets are in the mini game package. If not present, query local cache assets. If no local cache assets are available, download from a remote server. Download and save them to the mini game application cache in backstage for re-access. Local cache storage has space limitation, if total space of cache exceeds the limit, there will be no more caching without disturbing game process. It should be noted that once the cache space is full, all the assets that need to be downloaded cannot be saved, only the temporary files for save download assets can be used, and WeChat will automatically clean up all temporary files after the mini game is exited. So the next time you run the mini game again, those assets are downloaded again and the process keeps looping.In addition, the problem of file saving failure due to cache space exceeding the limit does not occur on the WeChat DevTools, because the WeChat DevTools does not limit the cache size, so testing the cache needs to be done in a real WeChat environment. At the same time, when the MD5 Cache feature of the engine is enabled, the URL of the file will change as the content of the file changes, so that when a new version of the game is released, the assets of the old version will naturally become invalid in the cache, and only the new assets can be requested from the server, which achieves the effect of version control. Specifically, developers need to do: When building, check the MD5 Cache in the Build panel. Set the Remote service address, and then click Build. When the build is complete, upload the res folder in the mini game release package to the server. Delete the res folder inside the local release package. For the test phase, you may not be able to deploy to the official server, you need to use the local server to test, then open the details page in the WeChat DevTools, check the Does not verify valid domain names, web-view (business domain names), TLS versions and HTTPS certificates option in the Local Settings. Note: If the cache asset exceeds the WeChat environment limit, you need to manually clear the asset. And you can use wx.downloader.cleanAllAssets() and wx.downloader.cleanOldAssets() to clear the cache in WeChat Mini Games. The former clears all the cache assets in the cache directory, please use it carefully. While the latter clears cache assets that are currently unused in the cache directory in the application. WeChat Mini Game Subpackage Loading To achieve subpackage loading with WeChat Mini Game, please refer to Subpackage Loading documentation. Platform SDK Access In addition to pure game content, the WeChat Mini Game environment actually provides a very powerful native SDK interface, the most important of which are user, social, payment, etc. These interfaces are only available in the WeChat Mini Game environment, equivalent to third-party SDK interfaces for other platforms. The porting of such SDK interfaces still needs to be handled by developers at this stage. Here are some of the powerful SDK capabilities provided by WeChat Mini Games: User interface: login, authorization, user information, etc. WeChat payment Forward and get forwarding information File upload and download Media: pictures, recordings, cameras, etc. Other: location, device information, scan code, NFC, etc. WeChat Mini Games Known issues Cocos Creator 3D's adaptation of WeChat Mini Games has not been completely implemented. The following modules are still not supported: VideoPlayer WebView It is possible to use the missing functionality by calling the WeChat's API directly. Reference documentation Note: Some platforms only have Chinese documentation available when visiting the platforms website. It may be necessary to use Google Translate in-order to review the documentation. WeChat Mini Game Developer Document WeChat Public Platform WeChat Mini Game API Documentation WeChat DevTools WeChat DevTools Download WeChat Cache Space Overflow Case "},"editor/publish/wechatgame-plugin.html":{"url":"editor/publish/wechatgame-plugin.html","title":"WeChat Engine Plugin","keywords":"","body":"WeChat Mini Games Engine Plugin Instructions Note: Some platforms only have Chinese documentation available when visiting the platforms website. It may be necessary to use Google Translate in-order to review the documentation. The Game Engine Plugin is a new feature added to WeChat v7.0.7, which has the official version of the Cocos Creator 3D engine built in. If the plugin is enabled in the first game the player experiences, all games that also have the plugin enabled do not need to download the Cocos Creator 3D engine again, just use the same version of the engine directly from the public plugin library, or incremental update the engine. For example, when a player has played an A game developed using Cocos Creator 3D v1.0.2, and the A game already enabled this plugin. Then he played the B Game, also developed by v1.0.2, and would not have needed to redownload the Cocos Creator 3D engine if the B game had also enabled this plugin. Even if the B Game is developed using Cocos Creator 3D v1.0.3, WeChat only needs to incremental update the difference between the two engine versions. This will drastically reduce the download counts of mini games, and improve the startup speed of mini games by 0.5-2s for a better user experience. How to use Cocos Creator 3D has supported this feature since v1.0.2. Simply check the Separate Engine option in the Build panel, and then build and release as normal, without additional manual operation. (This feature is only available when the built-in engine is used and the build is in non-debug mode.) FAQ Q: Does the engine plugin feature support engine customization? A: Not supported. If the version does not match or the engine customization is enabled during the build, the built package will not actually use the engine plugin feature properly, although the editor will continue to build after an error occurs. Q: The project enable the engine module clipping, should I need to disable it when using the engine plugin? A: No, the project can continue to use the engine module clipping as before. The engine plugin provides a complete engine that is compatible with all clipping settings without affecting the original project package. Q: After the engine plugin is enabled, will the engine code still be counted into the first package? A: According to WeChat's rules, it will still be counted. Q: After the engine plugin is enabled, can I remove all modules in Project Setting -> Modules of editor to reduce the package size? A: No, because WeChat only supports engine plugin since v7.0.7, if the engine is clipped randomly, the game may not be able to run on a lower version of WeChat. Q: When the engine plugin is enabled, prompt \"Code package unpacking failed\" or \"Login user is not the developer of the Mini Program\" in the WeChat DevTools, while the physical device previews correctly? A: The default appid in the Build panel is a common test id, and according to WeChat's rules, you need to fill in the appid applied for yourself to test the engine plugin. Q: When the engine plugin is enabled, prompt \"Unauthorized plugin, Add plugin\" in the WeChat DevTools? A: Click the Add plugin in the prompt, then select add CocosCreator3D plugin and recompile. If prompt \"There are no plugins to add\" when you add the plugin, you can select the Clear Cache -> Clear All option in the WeChat DevTools and try again. Reference documentation Note: Some platforms only have Chinese documentation available when visiting the platforms website. It may be necessary to use Google Translate in-order to review the documentation. WeChat Mini Games Engine Plugin Development Documentation "},"editor/publish/publish-xiaomi-quick-game.html":{"url":"editor/publish/publish-xiaomi-quick-game.html","title":"Publishing to Xiaomi Quick Games","keywords":"","body":"Publishing to Xiaomi Quick Games Note: Some platforms only have Chinese documentation available when visiting the platforms website. It may be necessary to use Google Translate in-order to review the documentation. Cocos Creator 3D officially supports the release of games to the Xiaomi Quick Games platform. Environment Configuration Install Node.js 8.1.4 or above, globally. Make sure the npm version that Node.js comes with is 5.2.0 minimum. Upgrade the npm command as follows: # View the npm version npm -v # If the lowest version of npm is below 5.2.0, you can upgrade npm using the following command. npm install npm@latest -g Download Xiaomi Quick Game Debugger and Xiaomi Quick Game Runtime Environment, and install it on your Xiaomi device (recommended MIUI 8.5.0 or above). Release Process Use Cocos Creator 3D to open the project that needs to be released. Select Xiaomi Quick Game in the Platform dropdown of the Build panel. Click on the xiaomi-quick-game below to expand the parameter configuration of Xiaomi Quick Game. The specific filling rules for the relevant parameter configuration are as follows: App Package Name: the format of the App Package Name is com.yourcompany.projectname. This option is required and will be filled in according to the developer's needs. Note: Starting from the platform version number 1062, Xiaomi Quick Game needs to use the official App Package Name, otherwise the error of Data loading exception, please click retry will be reported during debugging. You can refer to the Xiaomi Quick Game App Package Name Application documentation for details. Desktop Icon: is required. Click the search icon button at the back of the input box to select the icon you want. When building, the Desktop Icon will be built into the Xiaomi Quick Game project. It is suggested to use a PNG image for the Desktop Icon. App Version Name: is required. App Version Name is the real version, such as: 1.0.0. App Version Number: is required. App Version Number is different from the App Version Name, and the App Version Number is mainly used to distinguish the version update. Each time when you submit audit, the App Version Number is at least 1 higher than the value of the last submitted audit. It must not be equal to or less than the value of the last submitted audit, and it is recommended that the App Version Number be recursively incremented by 1 each time when the audit is submitted. Note: The App Version Number must be a positive integer. Supported Minimum Platform Version Number: is required. According to the requirements of Xiaomi Quick Games, this value must be greater than or equal to 1050. Build Sub Package: is enabled by default. For details, please refer to Subpackage rpk at the end of this document. Small Packet Mode: is optional. The in-package volume of the quick-game contains code and assets that cannot exceed 10M, and assets can be loaded via network requests. Small Packet Mode is to help developers keep the script files in the quick game package, other assets are uploaded to the remote server, and downloaded from the remote server as needed. And the download, cache and version management of remote assets, Cocos Creator 3D has already helped the developer. What the developer needs to do is the following steps: When building, check the Small Packet Mode and fill in the Small Packet Mode Server Path. First game asset package into the game package, this item is optional. In the Small Packet Mode, due to too many assets on the launch scene, downloading and loading assets for a long time may result in a short black screen when entering the game for the first time. If First game asset package into the game package is checked, you can reduce the black screen time when you first enter the game. However, it should be noted that the res/import asset does not support split asset downloading at this time, and the entire import directory is also packaged into the first package. Developers can choose whether to check this item according to their needs. Then click on Build. After the build is complete, click the Open button after the Build Path to upload the res directory under the release path to the small packet mode server. For example, if the default release path is build, the Build Task Name is xiaomi-quick-game, you need to upload the /build/xiaomi-quick-game/res directory. Note: If you are using the command line to compile small packet mode, remember to backup the build/xiaomi-pack-tools/res directory, then delete the build/xiaomi-pack-tools/res directory, and then perform command line compilation (npm run build). At this point, the res directory will no longer be included in the built-up rpk, and the assets in the res directory will be downloaded from the filled Small Packet Mode Server Path through the network request. Keystore: when you check the Keystore, the default is to build the rpk package with a certificate that comes with Cocos Creator 3D, which is used only for debugging. Note: When the rpk package is to be used to submit an audit, do not check the Keystore to build it. If you don't check the Keystore, you need to configure the signature files certificate.pem path and private.pem path, where you build a rpk package that you can publish directly. The developer can configure two signature files by using the search icon button to the right of the input box. Note: These two signature files are not recommended to be placed in the build/xiaomi-quick-game directory of the release package, otherwise the build directory will be emptied each time when it is built, resulting in file loss. There are two ways to generate a signature file: Generated by the New button after the certificate.pem path in the Build panel. After clicking the New button, fill in the information in the Packages panel that pops up. After the information is filled in, click Generate button, the log Generate certificate is complete! will be output in the Console panel, indicating that the signature file is generated. Generated by the command line. The developer needs to generate the signature file private.pem, certificate.pem through tools such as openssl. # Generate a signature file with the openssl command tool openssl req -newkey rsa:2048 -nodes -keyout private.pem -x509 -days 3650 -out certificate.pem Note: openssl can be used directly in the terminal in Linux or Mac environment, and in the Windows environment you need to install openssl and configure system environment variables. Restart Cocos Creator 3D after the configuration is complete. 2. Build After the relevant parameters of the Build panel are set, click Build. When the build is complete, click the folder icon button below the corresponding build task to open the build release path, you can see that a directory with the same name as the Build Task Name (e.g xiaomi-quick-game) is generated in the default release path build directory, which is the exported Xiaomi Quick Game project directory and rpk, rpk package are in the /build/xiaomi-quick-game/dist directory. 3. Run the built rpk to the phone There are three ways to run rpk on your phone: Method One Click the Run button at the bottom right of the xiaomi-quick-game build task in the Build panel and wait for the QR Code interface to be generated: Then open the Xiaomi Quick Game Debugger that was installed before on your Xiaomi device. Click the Scan code install button to scan the QR Code to open the rpk. Method Two First open Settings-> Additional settings-> Developer options on Xiaomi device, turn on Developer options and USB debugging. Use a USB cable to connect your computer to your Xiaomi device. Copy the generated quick game rpk file (located in the build/xiaomi-quick-game/dist directory) to the sdcard directory of the Xiaomi device. Open the Xiaomi Quick Game Debugger that has been installed before on your Xiaomi device, click Local Install, then find the rpk file from the sdcard directory of your Xiaomi device and select Open. Debugging The debugging must be based on the physical device and must follow the strict run the game first and start the debugging function sequence. After starting the game, leave Xiaomi device in the interface where the game is open to run. Then use the USB cable to connect your computer to the Xiaomi device, and the Xiaomi device needs to enable Developer options and USB Debugging. Debugging can currently be initiated from the command line. Specify to the editor installation directory resources/tools/xiaomi-pack-tools in the command line, and execute the command npm run debug. And the debugging interface will start automatically in Chrome. If you want to open the debug interface manually, execute the command npm run debug -- --print-only and copy the generated URL address into Chrome to enable the debugging interface. # Specify to the editor installation directory. cd F:/CocosCreator3D/assets/tools/xiaomi-pack-tools # Automatically opens the debug interface on Chrome. npm run debug # manually opens the debug interface on Chrome. npm run debug -- --print-only 4. Subpackage rpk Subpackage rpk can be used according to your needs. Subpackage loading, that is, splitting the game content into several packages according to certain rules, only downloading the necessary packages when starting up for the first time. This necessary package is called main package. And the developer can trigger in the main package to download other sub-packages, which can effectively reduce the time spent on the first boot. To use this function, you need to set Subpackage Configuration in Cocos Creator 3D, and the package will be automatically subpackaged when the setting is completed. Note: The size of a single subpackage/main package must not exceed 5M, and the sum of all packages must not exceed 10M. When the build is complete, an .rpk file is generated in the /build/xiaomi-quick-game/dist directory. Reference documentation Note: Some platforms only have Chinese documentation available when visiting the platforms website. It may be necessary to use Google Translate in-order to review the documentation. Xiaomi Quick Game Reference documentation "},"concepts/scene/":{"url":"concepts/scene/","title":"Scene and Environment","keywords":"","body":"Scenes A Scene is an abstract collection of environmental factors in a game. It is a local unit that creates a game environment. We can understand that game developers and designers make a scene in the editor to represent part of the world content in a game. This section includes the following: -Coordinate system -Scene Structure -Node -Skybox Continue to the Coordinate System documentation. "},"concepts/scene/coord.html":{"url":"concepts/scene/coord.html","title":"Coordinate system","keywords":"","body":"Coordinate System World coordinate system Cocos Creator 3D's world coordinate system uses a Cartesian right-handed coordinate system with the origin occuring at the lower left corner, x to the right, y to the top, and z to the outside. Screen coordinate system The origin of the screen coordinate system is the bottom left corner of the screen, with x to the right and y to the top. Continue to the Scene Structure documentation. "},"concepts/scene/scene.html":{"url":"concepts/scene/scene.html","title":"Scene","keywords":"","body":"Scene structure Cocos Creator 3D adds a 3D scene structure to Creator’s EC (entity component) framework. The 3D scene is represented by RenderScene. The corresponding Component in the EC structure references the Model, Camera, and Light are maintained in RenderScene. Other elements are also linked together through Node, including the Transformations in RenderScene is also manipulated through the Node API. Note: the differences between Scene in EC structure and RenderScene in a 3D scene structure. Scene in EC structure is the logical organization structure of the Node hierarchy. RenderScene in 3D is the organization structure of scene rendering elements. Elements in EC scene's contain references to the correspond rendering objects in RenderScene. The relationship between EC structure and 3D scene structure is shown in the following figure: The entire 3D scene structure is encapsulated under Component, and the organizational relationship is established through Node. This is completely transparent relationship between EC structure and a 3D scene. Continue to the Node documentation. "},"concepts/scene/node.html":{"url":"concepts/scene/node.html","title":"Node","keywords":"","body":"Node Nodes are the basic building blocks of a scene. Nodes are organized in a tree-like relationship. Each Node can have multiple child nodes and correspond to a parent node at the same time. Nodes have the following characteristics: Nodes contain a set of basic information (displacement, rotation, scaling), and Nodes are organized together through a set of relative transformation relationships. The previous transform information of a Node is relative to it's parent node. The update order between Nodes follows the tree hierarchy order. The update of child nodes depends on the parent node, and the world transformation of child nodes is the combination of their local transformation and the world transform of their parent node. The parent/child relationship is very important. Components can be added to Nodes to associate multiple components with Nodes In short, Nodes are the basic means of organizing the structure of any game. We can classify multiple elements through Nodes, and perform hierarchical operations on Nodes, or perform batch operations on a group of Nodes, such as: transform, delete, or hiding and showing them as needed, etc. Continue to the Skybox documentation. "},"concepts/scene/skybox.html":{"url":"concepts/scene/skybox.html","title":"Skybox","keywords":"","body":"Skybox Skybox, in video games, is a cube that wraps the entire scene. The Skybox can render the atmosphere of the entire environment and express the environment of the entire scene. The Skybox is also a very important part in the PBR-based workflow. The Skybox in Cocos Creator 3D, is shown below: Enabling Skybox Enabling the Skybox effect in Cocos Creator 3D, takes just one step: The Skybox panel is on the Scene node's Properties panel. Check the Enabled property to enable the Skybox. Note: When the Envmap property of Skybox is empty, the default pixel map will be used and displayed. Modify the environment map of the Skybox Modifying the environment map of the Skybox in Cocos Creator 3D is done by setting a asset of type TextureCube. Importing from a asset into a TextureCube and setting it into a Skybox can be done in the following steps: Import picture assets. Note: Here is an example of a panorama, we will introduce how to make a CubeMap later in this documentation. Select the imported panorama asset and set it to the TextureCube type in the Inspector panel on the right, as shown in this figure: Drag the TextureCube asset to the Envmap property on the Skybox's Inspector Panel. Skybox panel The following describes all the properties of the Skybox panel: Properties Explanation enabled whether to enable Skybox envmap environment map, type is TextureCube isRGBE whether the pixel format of the environment map is RGBE useIBL whether to use ambient light CubeMap CubeMap is a kind of environment map asset for a Skybox. It is composed of map assets of six faces on a cube. It can be used as a TextureCube asset. Making and applying a CubeMap To make a CubeMap in Cocos Creator 3D and set it to a Skybox, follow these steps: Create a new CubeMap asset, and import the six texture map assets prepared in advance, and set these texture assets to the Texture type. Drag the imported texture assets into the corresponding input box, and click the green check button when you are finished. Finally, drag the completed CubeMap asset into the Envmap property box of the Skybox. This completes the application of a CubeMap. Note: Faces that are not mapped in CubeMap. It will be filled with a default texture. "},"concepts/scene/light.html":{"url":"concepts/scene/light.html","title":"Lighting","keywords":"","body":"Light sources Light source in game development represents a light-emitting object that can illuminate the surrounding environment Physically Based Lighting Cocos Creator 3D uses optical measurement units to describe light source parameters. Based on optical measurement units, we can convert all relevant parameters of the light source into physical values in the real world. In this way, the designer can adjust the light intensity, color, range and other parameters according to the industrial standards of parameters and the physical parameters of a real environment. The overall lighting effect is more in line with the real natural environment. For a detailed introduction, please read: Physically Based Lighting Cocos Creator 3D supports three types of light sources: Directional Light Spherical Light Spotlights Continue to the Physically Based Lighting documentation. "},"concepts/scene/light/pbr-lighting.html":{"url":"concepts/scene/light/pbr-lighting.html","title":"Physically based lighting","keywords":"","body":"Physically Based Lighting Light sources in the real world Physically based lighting describes light sources in the real world. In real environments, the light sources we see have their own industrial parameters. Let’s first look at a light bulb.💡 From the product packaging, we can understand several important industrial parameters of this bulb: luminous power color temperature size These three important parameters affect the performance of the light source in the real world. Let's focus on the physical meaning of these three parameters. Luminous power Luminous power is what we usually call the light sources intensity. Cocos Creator 3D uses photometric units to measure light source intensity: Luminous Power: Unit Lumens (lm) Describes the total amount of light emitted by the light source from all directions. Changing the size of the light source will not affect the lighting effect of the scene. Luminance: Unit Candela per square meter (cd/m2 or nits) Describes the intensity of the light source when light is measured from a point on the surface of the light source to a point on the receiving surface. Changing the size of the light source will affect the lighting effect of the scene Illuminance: Unit lux (lx) Describes the total amount of light from a light source measured at the receiving surface. This value is affected by the distance the light travels. In the real world, because the important physical parameters describing light sources are different, we usually use luminous power and luminance to describe light sources that illuminate areas commonly used in life. Color Temperature Color temperature refers to the color of the absolute black body after it has been heated from absolute zero (-273° C). Color temperature is an important attribute that affects the color of the light source. It is an optional attribute. When color temperature is enabled, the color temperature also contributes to the color of the light source. In a real world environment, the ambient color temperature at different times of the day also changes dynamically: Please refer to the following table: Light source size Light sources in the real world have real physical dimensions. At the same time, the size of the light source also affects the intensity of the light source. Continue to the Direct Direction Light documentation. "},"concepts/scene/light/dir-light.html":{"url":"concepts/scene/light/dir-light.html","title":"Directional lighting","keywords":"","body":"Main Directional Light There is only one main directional light in Cocos Creator 3D. The main directional light can be understood as the dominant light source in the scene, usually the sunlight in outdoor scenes. The main directional light also affects the shadow projection. Parameter name Description Color Light Source Color Use Color Temperature Whether to enable color temperature Color Temperature Color Temperature Illumiance Illumination, unit lux (lx) of nits Continue to the Sphere light documentation. "},"concepts/scene/light/sphere-light.html":{"url":"concepts/scene/light/sphere-light.html","title":"Spherical lighting","keywords":"","body":"Spherical Lighting Cocos Creator 3D uses spherical light instead of point lighting, because physical light sources in the real world have light source size attributes. Parameter Description Color Light source color UseColorTemperature Whether to enable color temperature ColorTemperature Color temperature Size Light source size Range Lighting impact range Term Selected unit for light intensity Spherical light supports two unit system: luminous power and luminance LuminousPower Luminous power in lumens (lm) When Term is specified as LUMINOUS_POWER, lumen is used to indicate the light intensity Luminance Brightness, unit Candela per square meter (cd/m2) When Term is specified as LUMINANCE, brightness is used to indicate light intensity Continue to the Spotlight documentation. "},"concepts/scene/light/spot-light.html":{"url":"concepts/scene/light/spot-light.html","title":"Spot lighting","keywords":"","body":"Spotlights Spotlights are used to express the focus of a light beam. You can control the spot size by adjusting the focusing angle. Parameter Description Color Light source color UseColorTemperature Whether to enable color temperature ColorTemperature Color temperature Size Light source size Range Lighting impact range SpotAngle Condensing angle Term Selected unit for light intensity Spherical light supports two unit system: luminous power and luminance LuminousPower Luminous power in lumens (lm) When Term is specified as LUMINOUS_POWER, lumen is used to indicate the light intensity Luminance Brightness, unit Candela per square meter (cd/m2) When Term is specified as LUMINANCE, brightness is used to indicate light intensity Continue to the Shadows documentation。 "},"concepts/scene/shadow.html":{"url":"concepts/scene/shadow.html","title":"Shadows","keywords":"","body":"Shadow In the 3D world, light and shadows have always been extremely important components. They can enrich the entire environment, good-quality shadows can achieve the effect of false realization, and make the entire world have a three-dimensional feel to it. Here is an example of a shadow from Cocos Creator 3D: Turning on shadows Cococs Creator 3D currently supports the highly efficient Planar Shadow. More Shadow types will be available later. It only takes two steps to enable a Planar Shadow in Cococs Creator 3D: Select the Scene node on the level manager, you can see the following panel, check the Enabled property of planarShadows. Set ShadowCastingMode to ON in the model that needs to display shadows. Note: Planar Shadow will only be cast on the shadow surface. Adjusting the directional light angle can adjust the shadow projection. PlanarShadows panel The following describes all the properties of the panel: Properties Explanation enabled whether to enable planar shadows normal normals to vertical and shadow planes distance the distance of the shadow plane from the coordinate origin in the direction of the normal shadowColor color value of the resulting shadow Continue to the Ambient Light documentation. "},"concepts/scene/ambient.html":{"url":"concepts/scene/ambient.html","title":"Ambient lighting","keywords":"","body":"Ambient light In life, the intricate light patterns and uneven surfaces reflect each other, so that the entire environment is illuminated, as if the entire scene is enveloped by a layer of ambient light. Adjusting the amount of ambient light is the most direct way to adjust the overall illumination of the environment. It is also one way to effectively express the atmosphere of the environment. Ambient light in Cocos Creator 3D, as shown below: Ambient light panel The following describes all the properties of the panel: Properties Explanation groundAlbedo ground reflected light skyColor sky color skyIllum sky brightness Return to the Lighting documentation. "},"material-system/overview.html":{"url":"material-system/overview.html","title":"Materials System","keywords":"","body":"Material System Overview The material system plays an essential role in any game engine infrastructure: it controls the way everything is drawn on screen and much more. The general structure of the system is as follows: EffectAsset EffectAsset is a shading procedure description file, written by both engine and game developers. It contains the mathematical calculations and algorithms for calculating the color of each pixel rendered. When the builtin effects are not the best fit for your need, writing your own effect can give you all the capabilities to customize the rendering process. Detailed syntax instructions can be found here. After an effect file is created, the in-editor effect compiler automatically steps in to compile it. Also using builtin-unlit.effect as an example, the compiler output for this file will look like this: { \"name\": \"builtin-unlit\", \"techniques\": [ {\"name\":\"opaque\", \"passes\":[{\"program\":\"builtin-unlit|unlit-vs:vert|unlit-fs:frag\", \"properties\":{\"mainTexture\":{\"value\":\"grey\", \"type\":28}, \"tilingOffset\":{\"value\":[1, 1, 0, 0], \"type\":16}, \"mainColor\":{\"value\":[1, 1, 1, 1], \"editor\":{\"type\":\"color\"}, \"type\":16}, \"colorScale\":{\"value\":[1, 1, 1], \"type\":15, \"handleInfo\":[\"colorScaleAndCutoff\", 0, 15]}, \"alphaThreshold\":{\"value\":[0.5], \"editor\":{\"parent\":\"USE_ALPHA_TEST\"}, \"type\":13, \"handleInfo\":[\"colorScaleAndCutoff\", 3, 13]}, \"color\":{\"editor\":{\"visible\":false}, \"type\":16, \"handleInfo\":[\"mainColor\", 0, 16]}, \"colorScaleAndCutoff\":{\"type\":16, \"editor\":{\"visible\":false, \"deprecated\":true}, \"value\":[1, 1, 1, 0.5]}}, \"migrations\":{\"properties\":{\"mainColor\":{\"formerlySerializedAs\":\"color\"}}}}]}, ], \"shaders\": [ { \"name\": \"builtin-unlit|unlit-vs:vert|unlit-fs:frag\", \"hash\": 2093221684, \"glsl4\": { \"vert\": \"// glsl 460 vert source, omitted here for brevity\", \"frag\": \"// glsl 460 frag source, omitted here for brevity\", }, \"glsl3\": { \"vert\": \"// glsl 300 es vert source, omitted here for brevity\", \"frag\": \"// glsl 300 es frag source, omitted here for brevity\", }, \"glsl1\": { \"vert\": \"// glsl 100 vert source, omitted here for brevity\", \"frag\": \"// glsl 100 frag source, omitted here for brevity\", }, \"attributes\": [ {\"name\":\"a_dyn_batch_id\", \"type\":13, \"count\":1, \"defines\":[\"USE_BATCHING\"], \"location\":1}, {\"name\":\"a_position\", \"type\":15, \"count\":1, \"defines\":[], \"location\":0}, {\"name\":\"a_weights\", \"type\":16, \"count\":1, \"defines\":[\"USE_SKINNING\"], \"location\":2}, {\"name\":\"a_joints\", \"type\":16, \"count\":1, \"defines\":[\"USE_SKINNING\"], \"location\":3}, {\"name\":\"a_color\", \"type\":16, \"count\":1, \"defines\":[\"USE_VERTEX_COLOR\"], \"location\":4}, {\"name\":\"a_texCoord\", \"type\":14, \"count\":1, \"defines\":[\"USE_TEXTURE\"], \"location\":5} ], \"varyings\": [ {\"name\":\"v_color\", \"type\":16, \"count\":1, \"defines\":[\"USE_VERTEX_COLOR\"], \"location\":0}, {\"name\":\"v_uv\", \"type\":14, \"count\":1, \"defines\":[\"USE_TEXTURE\"], \"location\":1} ], \"builtins\": {\"globals\":{\"blocks\":[{\"name\":\"CCGlobal\", \"defines\":[]}], \"samplers\":[]}, \"locals\":{\"blocks\":[{\"name\":\"CCLocalBatched\", \"defines\":[\"USE_BATCHING\"]}, {\"name\":\"CCLocal\", \"defines\":[]}, {\"name\":\"CCSkinningTexture\", \"defines\":[\"USE_SKINNING\", \"ANIMATION_BAKED\"]}, {\"name\":\"CCSkinningAnimation\", \"defines\":[\"USE_SKINNING\", \"ANIMATION_BAKED\"]}, {\"name\":\"CCSkinningFlexible\", \"defines\":[\"USE_SKINNING\"]}], \"samplers\":[{\"name\":\"cc_jointsTexture\", \"defines\":[\"USE_SKINNING\", \"ANIMATION_BAKED\"]}]}}, \"defines\": [ {\"name\":\"USE_BATCHING\", \"type\":\"boolean\", \"defines\":[]}, {\"name\":\"USE_SKINNING\", \"type\":\"boolean\", \"defines\":[]}, {\"name\":\"ANIMATION_BAKED\", \"type\":\"boolean\", \"defines\":[\"USE_SKINNING\"]}, {\"name\":\"CC_SUPPORT_FLOAT_TEXTURE\", \"type\":\"boolean\", \"defines\":[\"USE_SKINNING\", \"ANIMATION_BAKED\"]}, {\"name\":\"USE_VERTEX_COLOR\", \"type\":\"boolean\", \"defines\":[]}, {\"name\":\"USE_TEXTURE\", \"type\":\"boolean\", \"defines\":[]}, {\"name\":\"FLIP_UV\", \"type\":\"boolean\", \"defines\":[\"USE_TEXTURE\"]}, {\"name\":\"CC_USE_HDR\", \"type\":\"boolean\", \"defines\":[]}, {\"name\":\"USE_ALPHA_TEST\", \"type\":\"boolean\", \"defines\":[]}, {\"name\":\"ALPHA_TEST_CHANNEL\", \"type\":\"string\", \"defines\":[\"USE_ALPHA_TEST\"], \"options\":[\"a\", \"r\", \"g\", \"b\"]} ], \"blocks\": [ {\"name\": \"TexCoords\", \"defines\": [\"USE_TEXTURE\"], \"binding\": 0, \"members\": [ {\"name\":\"tilingOffset\", \"type\":16, \"count\":1} ]}, {\"name\": \"Constant\", \"defines\": [], \"binding\": 1, \"members\": [ {\"name\":\"mainColor\", \"type\":16, \"count\":1}, {\"name\":\"colorScaleAndCutoff\", \"type\":16, \"count\":1} ]} ], \"samplers\": [ {\"name\":\"mainTexture\", \"type\":28, \"count\":1, \"defines\":[\"USE_TEXTURE\"], \"binding\":30} ] } ] } There is a lot to unpack here, but for the most part the details won't be of any concern to game deverlopers, and the key insight you need to remember is: All the necessary info for runtime shading procedure setup on any target platform (and even editor support) is here in advance to guarantee portability and performance. Redundant info will be trimmed at build-time to ensure minimum space consumption. Material Material defines how a surface should be rendered, by including references to textures it uses, tiling information, color tints and more. The available options for a Material depend on which EffectAsset it is using. Essential parameters for setting up a Material object are: effectAsset or effectName: effect reference: which EffectAsset will be used? (must specify) technique: inside the EffectAsset, which technique will be used? (default to 0) defines: what value the shader macros have? (for shader variants) (default all to 0, or in-shader specified default value) states: if any, which pipeline state to override? (defaul to nothing, keep everything the same as how they are specified in effect) const mat = new Material(); mat.initialize({ effectName: 'pipeline/skybox', defines: { USE_RGBE_CUBEMAP: true } }); With this information, the Material is properly initialized, and ready to use in any Renderable Component. Knowing which EffectAsset is currently using, we can specify all the shader properties: mat.setProperty('cubeMap', someCubeMap); console.log(mat.getProperty('cubeMap') === someCubeMap); // true These properties are assigned inside the material, which is just an asset by itself, and hasn't connected to any model. To apply the material on a specific model, it needs to be attached to a RenderableComponent. Any component that accepts a material parameter (ModelComponent, SkinningModelComponent, etc.) is inherited from it. const comp = someNode.getComponent(ModelComponent); comp.material = mat; comp.setMaterial(mat, 0); // same as last line According to the number of sub-models, RenderableComponent may reference multiple Materials: comp.setMaterial(someOtherMaterial, 1); // assign to second sub-model The same Material can be attached to multiple RenderableComponent too: const comp2 = someNode2.getComponent(ModelComponent); comp2.material = mat; // the same material above When one of the material-sharing models needs to customize some property, you need to get a copied instance of the material asset, aka. MaterialInstance, from the RenderableComponent, by calling: const mat2 = comp2.material; // copy constructor, now `mat2` is an `MaterialInstance`, and every change made to `mat2` only affect the `comp2` instance The biggest difference between Material asset and MaterialInstance is, MaterialInstance is definitively attached to one RenderableComponent at the beginning of its life cyle, while Material has no such limit. For an already initialized material, if you need to re-initialize it, just re-invoke the initialize function, to rebuild everything. mat.initialize({ effectName: 'builtin-standard', technique: 1 }); Specifically, if it is only the shader macros or pipeline states that you want to modify, there are more efficient ways: mat2.recompileShaders({ USE_EMISSIVE: true }); mat2.overridePipelineStates({ rasterizerState: { cullMode: GFXCullMode.NONE } }); But remember these can only be called on MaterialInstances, not Material asset itself. Updating shader properties every frame is a common practice, under situations like this, where performance matters, use lower level APIs: // Save these when starting const pass = mat2.passes[0]; const hColor = pass.getHandle('albedo'); const color = new Color('#dadada'); // inside update function color.a = Math.sin(director.getTotalFrames() * 0.01) * 127 + 127; pass.setUniform(hColor, color); Builtins Although the material system itself doesn't make any assumptions on the content, there are some built-in effects written on top of the system, provided for common usage: unlit, physically-based (standard), skybox, particle, sprite, etc. For a quick reference, here are all the properties and macros of the standard effect： Property Info tilingOffset tiling and offset of the model UV,xy channel for tiling, zw channel for offset albedo/mainColor albedo color, the main base color of the model albedoMap/mainTexture albedo texture, if present, will be multiplied by the albedo property albedoScale albedo scaling factor,weighting the whole albedo factor before the final output alphaThreshold test threshold for discarding pixels,any pixel with target channel value lower than this threshold will be discarded normalMap normal map texture, enhancing surface details normalStrenth strenth of the normal map, the bigger the bumpier pbrMap PBR parameter all-in-one texture: occlusion, roughness and metallicsample result will be multiplied by the matching constantssource channel specified by XX_CHANNEL macros metallicRoughnessMap metallic and roughness texturesample result will be multiplied by the matching constantssource channel specified by XX_CHANNEL macros occlusionMap independent occlusion texturesample result will be multiplied by the matching constantssource channel specified by XX_CHANNEL macros occlusion occlusion constant roughness roughness constant metallic metallic constant emissive emissive color emissiveMap emissive color texture, if present, will be multiplied by the emissive property,so remember to set emissive property more close to white(default black) for this to take effect emissiveScale emissive scaling factorweighting the whole emissive factor before the final output Accordingly, these are the available macros： Macro Info USE_BATCHING is dynamic batching enabled? USE_SKINNING is vertex skinning enabled? necessary for skinning models ANIMATION_BAKED is baked skinning animation enabled? OCCLUSION_CHANNEL specifies the occlusion source channel, default to R channel ROUGHNESS_CHANNEL specifies the roughness source channel, default to G channel METALLIC_CHANNEL specifies the metallic source channel, default to B channel HAS_SECOND_UV is the second UV set present? ALBEDO_UV specifies the uv set to use when sampling albedo texture, default to the first set EMISSIVE_UV specifies the uv set to use when sampling emissive texture, default to the first set ALPHA_TEST_CHANNEL specifies the source channel for alpha test, default to A channel USE_VERTEX_COLOR if enabled, vertex color will be multiplied to albedo factor as well USE_ALPHA_TEST is alpha test enabled? USE_ALBEDO_MAP is albedo texture enabled? USE_NORMAL_MAP is normal map enabled? USE_PBR_MAP is PBR parameter texture enabled? USE_EMISSIVE_MAP is emissive texture enabled? "},"material-system/yaml-101.html":{"url":"material-system/yaml-101.html","title":"YAML 101","keywords":"","body":"YAML 101 The parser used conforms to YAML 1.2 standard, this means full JSON compatibility, you can write JSON directly if you want to: \"techniques\": [{ \"passes\": [{ \"vert\": \"skybox-vs\", \"frag\": \"skybox-fs\", \"rasterizerState\": { \"cullMode\": \"none\" } # ... hash sign for comments }] }] But of course it would be cumbersome and error-prone, so what YAML provides is a much simpler representation of the same data: (you can always refer to any online YAML JSON converter to play around ideas) All quotation marks and commas can be omitted (but note, never omit the space after colon) key1: 1 key2: unquoted string Like python, indentation is part of the syntax, representing hierarchy of the data1 object1: key1: false object2: key2: 3.14 key3: 0xdeadbeef nestedObject: key4: 'quoted string' Array elements are represented by dash+space prefix - 42 - \"double-quoted string\" - arrayElement3: key1: punctuations? sure. key2: you can even have {}s as long as they are not the first character key3: { nested1: 'but no unquoted string allowed inside brackets', nested2: 'also notice the comma is back too' } With these in mind, the effect manifest at the beginning of this document can be re-write as follows: techniques: - passes: - vert: skybox-vs frag: skybox-fs rasterizerState: cullMode: none # ... Another YAML feature that might comes in handy is reference and inheritance. Take a look at reference first: object1: &o1 key1: value1 object2: key2: value2 key3: *o1 This is its corresponding JSON: { \"object1\": { \"key1\": \"value1\" }, \"object2\": { \"key2\": \"value2\", \"key3\": { \"key1\": \"value1\" } } } Next, inheritance: object1: &o1 key1: value1 key2: value2 object2: The corresponding JSON: { \"object1\": { \"key1\": \"value1\", \"key2\": \"value2\" }, \"object2\": { \"key1\": \"value1\", \"key2\": \"value2\", \"key3\": \"value3\" } } For our purposes, like when multiple pass has the same properties, etc. it could be really helpful: techniques: - passes: - # pass 1 specifications... properties: &props # declare once... p1: { value: [ 1, 1, 1, 1 ] } p2: { sampler: { mipFilter: linear } } p3: { inspector: { type: color } } - # pass 2 specifications... properties: *props # reference anywhere Finally, before writing any YAML, wrap it in a CCEffect block first: CCEffect %{ # YAML starts here }% References YAML on Wikipedia YAML.org Spec [1] The YAML standard doesn't support tabs, so the effect compiler will try to replace all the tabs in file with 2 spaces first, to avoid the trivial yet annoying trouble of accidentally inserting tabs somewhere. But overall, please try to avoid doing that completely to make sure the compilation goes smoothly. ↩ "},"material-system/effect-syntax.html":{"url":"material-system/effect-syntax.html","title":"Effect Syntax","keywords":"","body":"Effect Syntax Guide Writing your own effects provides all the capabilities to customize the rendering process. Cocos Effect is a single-source embedded domain-specific language, based on YAML and GLSL. The YAML part declares the general framework, while GLSL part specifies the actual shader. Together they form a complete specification for the rendering process. We recommend editing effect files using Visual Studio Code with the official Cocos Effect plugin from the marketplace. Note: This document is targeted at Technical Artists or Graphics developers. If you are a design artist who needs specific shader customizations, please contact your Technical Artist or Programmer for support. Framework Syntax Using builtin-unlit.effect as an example, it looks something like this: About the Effect Name Effect names can be directly used at runtime to acquire the EffectAsset: const effect = cc.EffectAsset.get('builtin-unlit'); // this is the EffectAsset resource instance const mat = new cc.Material(); mat.initialize({ effectName: 'builtin-standard' }); // now `mat` is a valid standard material And the names are automatically generated based on its file path (relative to the assets/effects folder in your project) and file name(extension excluded). The builtin effects are located directly inside the assets/effects folder in the internal database, so the effect names don't contain a path. About YAML YAML is a human-readable data-serialization language, with a flexible, minimal syntax and easily configurable, which makes it an ideal choice. However, the syntax maybe somewhat unique, at first for those who are unfamiliar with the language. There is a quick intro to the most commonly used syntaxes and language features here. Configurable Pass Parameters The shader entries are the only required fields, namely vert and frag, in the format of shaderChunkName:entryFunctionName. Normally the main function shouldn't be specified in shader, for version-specific wrappers will be inserted at compile-time. assigning the return value of the specified function to the ouput of current shader stage. (gl_Position or the final output color). You can find all of the optional parameters in the pass parameter list documentation. Shader Chunks Syntactically shader chunks are a superset of GLSL, all the extended features will be processed immediately at resource compile-time. It can either be written inside the CCProgram block in .effect file, or directly in a seperate .chunk file. We recommend limiting the syntax within GLSL version 300 ES range to maintain best portability, although you can always write your own porting using GLSL built-in macro __VERSION__. This section will introduce the 'domain-specific' extended features, all of which will be processed immediately at resource compile-time. Also feel free to look around the built-in effects, which are always excellent concrete examples. On top of GLSL, several c-style extensions are naturally introduced： Chunk Include Just like the include directive in C/C++, you can include other shader chunks： #include #include \"../headers/my-shading-algorithm.chunk\" Relevant details: The .chunk extension can be omitted; quotation marks and angle brackets means the same; Every included header is guaranteed to be expanded only once; so every module could (and in fact should) include all its dependencies, even if there are overlaps; Dead code elimination is done at compile-time too, so including lots of unused utility functions shouldn't be of concern; There are two ways to reference a external chunk file: using the relative path to current file ('relative path'), or the relative path to assets/chunks folder of current project ('project absolute path'). If the specified file interpreted under both rules are present, the latter is preferred; When including files from other databases (like the internal database), only project absolute path is supported; when there are multiple databases have the same specified file, the priority is: User Project DB > Plugin DB > Internal DB; The built-in chunks are located directly inside assets/chunks in internal database, so you can include these without path prefix; All CCProgram blocks in the same effect file can include each other; Pre-processing Macros Currently the effect system tends to take advantage of the language built-in pre-processing macros to create shader variants. The effect compiler will collect the macros that appear in shaders, and declarations will be inserted accordingly at runtime. So for the most part you can use them without thinking about the effect compiler, while material inspector will automatically integrate both macros and shader properties into a natual editting interface. Relevant details: To type check as many branches as possible at effect compile-time, the strategy currently taken is to set all macros to 1 (or its given default value) before doing the actual check; so make sure this combination works (or if not, maybe you need numerical macros, specified in the next section); All the macros that are not enabled at runtime will be explicitly given a value of 0, so please avoid using #ifdef or #if defined (except the GLSL built-in macros, like extension indicators with GL_ prefix), for they would alway be true； Hash values will be calculated for each macro combination at runtime. For a single shader, the process is the most efficient when there are less than 2^32 combinations (a standard integer range), that means 32 boolean macros switches (or less if there are numerical macros). So please try to keep in this range to maintain optimal performance; Macro Tags Although the effect compiler will try to be smart and collect all pre-processing branches, sometimes there are more complicated cases: // macro defined within certain numerical 'range' #if LAYERS == 4 // ... #elif LAYERS == 5 // ... #endif // multiple discrete 'options' float metallic = texture(pbrMap, uv).METALLIC_SOURCE; For these special usages, you'll have to explicitly declare the macro, using macro tags: Tag Tag Parameter Default Value Usage range A two-element array,specifying minimum and maximum value, both inclusive [0, 3] For macros with bounded rangeThe bound should be as tight as possible options An arbitrary-length array,specifying every possible options nothing For macros with discrete, explicit choices Declarations for the above case are： #pragma define LAYERS range([4, 5]) #pragma define METALLIC_SOURCE options([r, g, b, a]) The first line declares a macro named LAYERS, with possible range of [4, 5]. The second line declares a macro named METALLIC_SOURCE, with four possible options: 'r', 'g', 'b', 'a'. Note: every tag accepts a single parameter, in the syntax of YAML. Functional Macros Due to lack of native support in WebGL platform, functional macros are provided as an effect compile-time feature, all references will be expanded in the output shader. This is an good match for inlining some simple utility functions, or similar code repeating several times. In fact, many built-in utility functions are functional macros: #define CCDecode(position) \\ position = vec4(a_position, 1.0) #define CCVertInput(position) \\ CCDecode(position); \\ #if CC_USE_SKINNING \\ CCSkin(position); \\ #endif \\ #pragma // empty pragma trick to get rid of trailing semicolons at effect compile time Meanwhile, same as the macro system in C/C++, the mechanism does nothing on checking macro hygiene. Any issues will have to be dealt with by developers manually: // please do be careful with unhygienic macros like this #define INCI(i) do { int a=0; ++i; } while(0) // when invoking int a = 4, b = 8; INCI(b); // correct, b would be 9 after this INCI(a); // wrong! a would still be 4 Vertex Input1 To encapsulate in-shader data pre-processing like data decompression and vertex skinning, utility function CCVertInput is provided. For all shaders used to draw mesh assets, you need something like this: #include vec4 vert () { vec3 position; CCVertInput(position); // ... do your thing with `position` (models space, after skinning) } If normals are required, use the standard version: #include vec4 vert () { StandardVertInput In; CCVertInput(In); // ... now use `In.position`, etc. } This will acquire position, normal and tangent data, all after vertex skinning. Other vertex data (uv, color, etc.) can be declared directly. To support dynamic instancing & batching, use CCGetWorldMatrix: #include vec4 vert () { // ... // unlit version (when normal is not needed) mat4 matWorld; CCGetWorldMatrix(matWorld); // standard version mat4 matWorld, matWorldIT; CCGetWorldMatrixFull(matWorld, matWorldIT); // ... } You can find the complete built-in shader uniform list here. Fragment Ouput1 To encapsulate render pipeline complexities, use CCFragOutput. For unlit shaders: #include vec4 frag () { vec4 o = vec4(0.0); // ... do the computation return CCFragOutput(o); } so that the code can work in both the HDR and LDR pipelines. If lighting is involved, combine with CCStandardShading to form a surface shader structure: #include #include // note the header file change void surf (out StandardSurface s) { // fill in your data here } vec4 frag () { StandardSurface s; surf(s); vec4 color = CCStandardShading(s); return CCFragOutput(color); } Under the framework writing your own surface shader or even shading algorithm becomes staightforward. Note: the CCFragOutput function should not be overriden, unless using custom render pipelines. Custom Instancing Attribute Dynamic instancing is a very flexible batching framework, whcih allows user-defined instanced properties on top of the built-in ones. Here's how you can define them in shader: All the related code need to be wrapped inside the agreed upon macro, USE_INSTANCING: #if USE_INSTANCING // when instancing is enabled #pragma format(RGBA8) // normalized unsigned byte in vec4 a_instanced_color; #endif Relevant details: the actual data format can be specified using compiler hint format tag, which accepts a single parameter in the form of GFXFormat enum name2. 32-bytes float type will be assumed if the tag is omitted. All instanced properties are input attributes of the vertex shader, so if some property is needed in fragment shader, you need to pass it as varyings; Make sure the code works for all branches, regardless of the actual state of USE_INSTANCING; The instanced property value will be initialized to all zeros by default. Use the setInstancedAttribute on ModelComponent to assign new values: const comp = node.getComponent(ModelComponent); comp.setInstancedAttribute('a_instanced_color', [100, 150, 200, 255]); // should match the specified format Note: The instanced properties will be reset to all zeros whenever creating a new PSO (the most common case is when assigning a new material). WebGL 1 fallback Support The effect compiler provides fallback conversion from GLSL 300 ES to GLSL 100 automatically, for WebGL 1.0 only support GLSL 100 syntax. this should be transparent to developers for the most time. Currently the automatic conversion only supports some basic usage, and if some post-100 features or extensions were used, (texelFetch, textureGrad, etc.) Developers have to do your own porting using the language built-in __VERSION__ macro: vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) { #if __VERSION__ The effect compiler will finally split these compile-time constant branches into different output versions. About UBO Memory Layout First the conclusion, the final rules are, every non-sampler uniform should be specified in UBO blocks, and for every UBO block: there should be no vec3 typed members； for array typed members, size of each element should be no less than a vec4; any member ordering that introduces a padding will be rejected; These rules will be checked rigorously at effect compile-time and throws detailed, implicit padding related compile error. This might sound overly-strict at first, but it's for a few good reasons: First, UBO is a much better basic unit to efficiently reuse data, so discrete declaration is no longer an option. Second, currently many platforms, including WebGL 2.0 only support one platform-independent memory layout, namely std140, and it has many restrictions3: All vec3 members will be aligned to vec4：uniform ControversialType { vec3 v3_1; // offset 0, length 16 [IMPLICIT PADDING!] }; // total of 16 bytes Any array member with element size less than a vec4 is aligned to vec4 element-wise:uniform ProblematicArrays { float f4_1[4]; // offset 0, stride 16, length 64 [IMPLICIT PADDING!] }; // total of 64 bytes All UBO members are aligned to the size of itself4:uniform IncorrectUBOOrder { float f1_1; // offset 0, length 4 (aligned to 4 bytes) vec2 v2; // offset 8, length 8 (aligned to 8 bytes) [IMPLICIT PADDING!] float f1_2; // offset 16, length 4 (aligned to 4 bytes) }; // total of 32 bytes* uniform CorrectUBOOrder { float f1_1; // offset 0, length 4 (aligned to 4 bytes) float f1_2; // offset 4, length 4 (aligned to 4 bytes) vec2 v2; // offset 8, length 8 (aligned to 8 bytes) }; // total of 16 bytes This means lots of wasted space, and some driver implementation might not completely conform to the standard5, hence all the strict checking procedure help to clear some pretty insidious bugs. Note: the actual uniform type can differ from the public interfaces the effect exposes to artists and runtime properties. Through property target system, every single channel can be manipulated independently, without restriction of the original uniform. [1] Shaders for systems with procedurally generated mesh, like particles, sprites, post-effects, etc. may handle things a bit differently ↩ [2] Integer-typed attribute is not supported on WebGL 1.0 platform, so use the default float type if targeting this platform ↩ [3] OpenGL 4.5, Section 7.6.2.2, page 137 ↩ [4] In the example code, UBO IncorrectUBOOrder has a total size 32. Actually this is still a platform-dependent data, due to what it seems like an oversight in the GLSL specification. More discussions can be found here ↩ [5] Interface Block - OpenGL Wiki#Memory_layout) ↩ "},"material-system/pass-parameter-list.html":{"url":"material-system/pass-parameter-list.html","title":"Pass Params","keywords":"","body":"Optional Pass Parameters Default value is in bold, all parameters are case-insensitive. Name Options switch *undefined, could be any valid macro name that's not defined in the shader priority default(128), could be any number between max(255) and min(0) stage default, could be the name of any registered stage in your runtime pipeline properties *see the following section migrations *see the following section primitive point_list, line_list, line_strip, line_loop,triangle_list, triangle_strip, triangle_fan,line_list_adjacency, line_strip_adjacency,triangle_list_adjacency, triangle_strip_adjacency,triangle_patch_adjacency, quad_patch_list, iso_line_list dynamics [], an array containing any of the following:viewport, scissor, line_width, depth_bias, blend_constants,depth_bounds, stencil_write_mask, stencil_compare_mask rasterizerState.cullMode front, back, none depthStencilState.depthTest true, false depthStencilState.depthWrite true, false depthStencilState.depthFunc never, less, equal, less_equal, greater, not_equal, greater_equal, always blendState.targets[i].blend true, false blendState.targets[i].blendEq add, sub, rev_sub blendState.targets[i].blendSrc one, zero, src_alpha_saturate,src_alpha, one_minus_src_alpha,dst_alpha, one_minus_dst_alpha,src_color, one_minus_src_color,dst_color, one_minus_dst_color,constant_color, one_minus_constant_color,constant_alpha, one_minus_constant_alpha blendState.targets[i].blendDst one, zero, src_alpha_saturate,src_alpha, one_minus_src_alpha,dst_alpha, one_minus_dst_alpha,src_color, one_minus_src_color,dst_color, one_minus_dst_color,constant_color, one_minus_constant_color,constant_alpha, one_minus_constant_alpha blendState.targets[i].blendSrcAlpha one, zero, src_alpha_saturate,src_alpha, one_minus_src_alpha,dst_alpha, one_minus_dst_alpha,src_color, one_minus_src_color,dst_color, one_minus_dst_color,constant_color, one_minus_constant_color,constant_alpha, one_minus_constant_alpha blendState.targets[i].blendDstAlpha one, zero, src_alpha_saturate,src_alpha, one_minus_src_alpha,dst_alpha, one_minus_dst_alpha,src_color, one_minus_src_color,dst_color, one_minus_dst_color,constant_color, one_minus_constant_color,constant_alpha, one_minus_constant_alpha blendState.targets[i].blendAlphaEq add, sub, rev_sub blendState.targets[i].blendColorMask all, none, r, g, b, a, rg, rb, ra, gb, ga, ba, rgb, rga, rba, gba blendState.blendColor 0 or [0, 0, 0, 0] depthStencilState.stencilTest true, false depthStencilState.stencilFunc never, less, equal, less_equal, greater, not_equal, greater_equal, always depthStencilState.stencilReadMask 0xffffffff or [1, 1, 1, 1] depthStencilState.stencilWriteMask 0xffffffff or [1, 1, 1, 1] depthStencilState.stencilFailOp keep, zero, replace, incr, incr_wrap, decr, decr_wrap, invert depthStencilState.stencilZFailOp keep, zero, replace, incr, incr_wrap, decr, decr_wrap, invert depthStencilState.stencilPassOp keep, zero, replace, incr, incr_wrap, decr, decr_wrap, invert depthStencilState.stencilRef 1 or [0, 0, 0, 1] depthStencilState.stencil*Front/Back \\set above stencil properties for specific side* Switch Specifies a power switch for the current pass, if not enabled, the pass with be skipped completely. the macro name shouldn't collide with any existing macros inside the shader. This property doesn't exist by default, which means the pass is executed unconditionally. Priority Specifies the rendering priority of the current pass, the bigger the number, the lower the priority. The default is (128), min is (0), max is (255), arithmetic operations between these constants and integer constants are supported. Stage Specifies which render stage the current pass belongs to. Properties Specifies the public interfaces exposed to material instector and runtime API. It can be a direct mapping to shader uniforms, or specific channels of the uniform： albedo: { value: [1, 1, 1, 1] } # uniform vec4 albedo roughness: { value: 0.8, target: pbrParams.g } # uniform vec4 pbrParams offset: { value: [0, 0], target: tilingOffset.zw } # uniform vec4 tilingOffset # say there is another uniform, vec4 emissive, that doesn't appear here # so it will be assigned a default value of [0, 0, 0, 0] and will not appear in the inspector Runtime reference is straightforward: // as long as it is a real uniform // it doesn't matter whether it is specified in the property list or not mat.setProperty('emissive', cc.Color.GREY); // this works mat.setProperty('albedo', cc.Color.RED); // directly set uniform mat.setProperty('roughness', 0.2); // set certain component const h = mat.passes[0].getHandle('offset'); // or just take the handle, mat.passes[0].setUniform(h, new Vec2(0.5, 0.5)); // and use Pass.setUniform interface instead Shader uniforms that are not in the properties list will be given a default value. For quick setup and experiment, the __metadata__ feature is provided, which will be the 'base class' for all other properties: properties: __metadata__: { editor: { visible: false } } a: { value: [1, 1, 0, 0] } b: { editor: { type: color } } c: { editor: { visible: true } } Here a and b will no longer appear in the inspector, while c stays visible. Migrations Ideally the public interface of an effect should always be backward-compatible, but occasionally introducing breaking changes might become the only option as the project iterate. A smooth data transition would be much desired during the process, which leads to the migration system: After an effect with migrations is successfully compiled, all the dependent material assets will be immediately updated, new property will be automatically generated from existing data using specified rules. The migration process will not delete any data, and if the new data is visible in inspector, flag the source data as deprecated. If the new property already exists, no migration will be performed to prevent accidental data override. (except in force mode) For a existing effect, declares the following migration rules: migrations: # macros: # macros follows the same rule as properties, without the component-wise features # USE_MIAN_TEXTURE: { formerlySerializedAs: USE_MAIN_TEXTURE } properties: newFloat: { formerlySerializedAs: oldVec4.w } Say we have a dependent material, with the following data: { \"oldVec4\": { \"__type__\": \"cc.Vec4\", \"x\": 1, \"y\": 1, \"z\": 1, \"w\": 0.5 } } After the effect is compiled, the material will be automatically updated to: { \"oldVec4\": { \"__type__\": \"cc.Vec4\", \"x\": 1, \"y\": 1, \"z\": 1, \"w\": 0.5 }, \"newFloat\": 0.5 } And after the next save operation on this material: (say the content is actually not changed) { \"newFloat\": 0.5 } We are just using the w channel here, while in fact arbitrary shuffle is supported too: newColor: { formerlySerializedAs: someOldColor.yxx } Or even based on a target macro: occlusion: { formerlySerializedAs: pbrParams. } This means the new occlusion data will be extracted from pbrParams data, the specific channel depend on the OCCLUSION_CHANNEL macro of current pass, and default to channel z if macro data not present. If newFloat property already exists before migration, nothing will happen, unless in force mode: newFloat: { formerlySerializedAs: oldVec4.w! } Then the migration is guaranteed to execute, regardless of the existing data. Note: Migration in force mode will execute in every database event, which is basically every mouse click in editor. So use it as a quick-and-dirty test measure, and be sure not to submit effect files with force mode migrations into version control. Property Parameter List All parameters are optional, with its default value in bold. Param Options target undefined, (any valid uniform components, no random swizzle) value \\see the next section* sampler.minFilter none, point, linear, anisotropic sampler.magFilter none, point, linear, anisotropic sampler.mipFilter none, point, linear, anisotropic sampler.addressU wrap, mirror, clamp, border sampler.addressV wrap, mirror, clamp, border sampler.addressW wrap, mirror, clamp, border sampler.maxAnisotropy 16 sampler.cmpFunc never, less, equal, less_equal, greater, not_equal, greater_equal, always sampler.borderColor [0, 0, 0, 0] sampler.minLOD 0 sampler.maxLOD 0, \\remember to override this when enabling mip filter* sampler.mipLODBias 0 editor \\see the next section* editor.displayName (any string), *property name editor.type vector, color editor.visible true, false editor.tooltip (any string), *property name editor.range undefined, [ min, max, [step] ] editor.deprecated true, false, \\for any material using this effect, delete the existing data for this property after next saving* Default Values Type Default Value / Options int 0 ivec2 [0, 0] ivec3 [0, 0, 0] ivec4 [0, 0, 0, 0] float 0 vec2 [0, 0] vec3 [0, 0, 0] vec4 [0, 0, 0, 0] sampler2D black, grey, white, normal, default samplerCube black-cube, white-cube, default-cube For macros: Macros with explicit tag declaration default to the first element of the tag parameter. All other macros default to 0. "},"material-system/builtin-shader-uniforms.html":{"url":"material-system/builtin-shader-uniforms.html","title":"Builtin Shader Uniforms","keywords":"","body":"Built-in Shader Uniforms To use these built-in shader variables, you need to include the corresponding chunks first. All currently available built-in uniforms, grouped by the chunks they are located: cc-local.chunk Name Type Info cc_matWorld mat4 model to world transform matrix cc_matWorldIT mat4 inverse-transpose of model to world transform matrix cc-global.chunk Name Type Info cc_time vec4 x: seconds since engine started cc_screenSize vec4 xy: shading screen size zw: reciprocal of shading screen size cc_screenScale vec4 xy: screen scale zw: reciprocal of screen scale cc_nativeSize vec4 xy: canvas size zw: reciprocal of canvas size cc_matView mat4 view transform matrix cc_matViewInv mat4 inverse view matrix cc_matProj mat4 projection transform matrix cc_matProjInv mat4 inverse projection transform matrix cc_matViewProj mat4 view-projection transform matrix cc_matViewProjInv mat4 inverse view-projection transform matrix cc_cameraPos vec4 xyz: camera position cc_exposure vec4 x: camera exposure y: reciprocal of camera exposure z: is HDR enabled w: HDR-LDR scaling factor cc_mainLitDir vec4 xyz: direction of main directional light cc_mainLitColor vec4 xyz: color of main directional light, w: intensity cc_ambientSky vec4 xyz: ambient sky color w: intensity cc_ambientGround vec4 xyz: ambient ground color cc-environment.chunk Name Type Info cc_environment samplerCube IBL environment map cc-forward-light.chunk Name Type Info cc_sphereLitPos[MAX_LIGHTS] vec4 xyz: position of spherical lights cc_sphereLitSizeRange[MAX_LIGHTS] vec4 x: size of spherical lights y: range of spherical lights cc_sphereLitColor[MAX_LIGHTS] vec4 xyz: color of spherical lights w: intensity cc_spotLitPos[MAX_LIGHTS] vec4 xyz: position of spot lights cc_spotLitSizeRangeAngle[MAX_LIGHTS] vec4 x: size of spot lights y: range of spot lights z: angle of spot lights cc_spotLitDir[MAX_LIGHTS] vec4 xyz: direction of spot lights cc_spotLitColor[MAX_LIGHTS] vec4 xyz: color of spot lights w: intensity cc-shadow.chunk Name Type Info cc_matLightPlaneProj mat4 planar shadow transform matrix cc_shadowColor vec4 shadow color "},"audio-system/overview.html":{"url":"audio-system/overview.html","title":"Audio System","keywords":"","body":"Overview of sound systems There are two types of sounds available in the audio system: sound effects and music. Sound effects are short bursts of quick sounds that signal the player of the game making progress. A few examples of sound effects are gun noises, bullets firing, a character jumping, physics contact events and many others. Music is longer in length and usually played in a loop. A few examples of music are background music, cut scenes, successfully completing a milestone in the game and many others. All audio assets are imported into the editor in the format of audioClip assets. If you want to play audio, you first need to create AudioSourceComponent in the scene. For music, audioClip assets can be assigned directly to the clip property on AudioSourceComponent. If you want to play music you can set the playOnAwake property of the AudioSourceComponent to true or call its play method in the script. For sound effects, you can call the playOneShot method of AudioSourceComponent in the script, calling this method requires incoming sound clips and the volume of playback. Note that although the audioClip asset itself also has direct interface implementations such as play, but AudioSourceComponent is the usual entry point, try to use components to component the workflow. Audio related events All AudioClip asset objects are one EventTarget： The started event is sent when the audio starts to actually play. When the audio playback ends naturally, the ended event will be issued. Platform differentiation Web audio API, DOM audio, WeChat mini game audio are currently supported, although the audio interface implementations of each platform are not fully unified at runtime. There is, however, some incongruity in the engine: The DOM audio mode on iOS does not support adjusting the volume, and not all volume related attributes will not be available. Calling playOneShot multiple times causes the audio currently playing to stop and then replay the same audio. Only Web Audio mode supports multiple playback of the same audio. In other modes, to avoid repeated creation,the playing Most platforms have complied with the latest auto play policy. Even if playOnAwake is set, it will only start playing when user input is first received. "},"particle-system/overview.html":{"url":"particle-system/overview.html","title":"Particle System","keywords":"","body":"Particle System Overview The particle system is the basis of the game engine's special effects. It can be used to simulate natural phenomena such as fire, smoke, water, clouds, snow, and fallen leaves. It can also be used to simulate abstract visual effects such as luminous tracks and speed lines. Basic Structure The basic unit of a particle system is a particle. A particle generally has attributes such as position, size, color, velocity, acceleration, and life cycle. In each frame, the particle system generally performs the following steps: Generate new particles and initialize. Delete particles beyond the life cycle. Update the dynamic properties of particles. Render all valid particles. The general particle system will consist of the following parts: Emitter, used to create particles and initialize particle properties. Influencer, used to update the properties of particles. Renderer, render particles. Particle class, which stores the properties of particles. The particle system class manages the above modules. The Cocos Creator 3D particle system organizes functions in modules, including the following modules: Module Description ParticleSystemComponent It is used to store all the data displayed in the Inspector, manage the related modules of particle generation, update and destruction, and control the particle playback. ShapeModule Used to control particle emission, including emission direction and speed, and supports predefined emission directions including squares, circles, cones, balls, and hemispheres. AnimatorModule Used to control the state update after particle emission. The supported functions are: size, color, rotation, speed, acceleration, speed limit, texture animation. ParticleSystemRenderer Used to generate the data needed for particle rendering. Including control related to vb, ib, rendering state. There are two ways to add a particle system module: Add particle system components to nodes like other components (not recommended). Use the editor to add particle system components (recommended). Developers can add particles by clicking Add Component on the right Inspector panel, as shown below: You can also add a particle system component through the left-level hierarchy manager right-click-> Create -> Effects-> Particle System, as shown below: Continue to the Particle System Module documentation。 "},"particle-system/module.html":{"url":"particle-system/module.html","title":"Particle System Module","keywords":"","body":"Introduction to particle system. ParticleSystemComponent stores the initial state of particle emission. After particle emission, it updates the submodule through the state. Particle System Module ParticleSystemComponentShapeModuleColorOvertimeModuleSizeOvertimeModuleRotationOvertimeModuleVelocityOvertimeModuleLimitVelocityOvertimeModuleForceOvertimeModuleTextureAnimationModuleRendererTrailModule Resource Culling The modules of each particle system exist as independent objects, and each module stores some module-related data, so for the modules that are not checked for use, the recorded data is useless data. When developers do not need to dynamically open these unedited modules at runtime, they can check the EnableCulling option at the bottom of the Inspector panel of ParticleSystemComponent to remove these useless data to reduce resource consumption. "},"particle-system/main-module.html":{"url":"particle-system/main-module.html","title":"Main Module","keywords":"","body":"Particle System Component Properties Features duration Total running time of particle system. capacity The maximum number of particles that a particle system can generate. loop Whether the particle system loops. playOnAwake Whether the particle system automatically starts playing after loading. prewarm After being selected, the particle system will start playing after one round has been played (only valid when loop playback is enabled). simulationSpace Control the coordinate system where the particle coordinates are calculated. startDelay Delay time of particle emission. startLifetime The life cycle of particle. startColor The initial color of particle. scaleSpace Coordinate space for particle scaling, local based on local space scaling, world based on world space scaling. startSize The initial size of particle. startSpeed The initial velocity of particle. startRotation The initial rotation angle of particle. gravityModifier Gravity coefficient. rateOverTime Number of particles emitted per second. rateOverDistance Number of particles emitted per moving unit distance. bursts Emit a given number of particles at a certain point in time - time How long does the particle play after it starts to emit burst. - count Number of particles emitted. - repeatCount The number of burst triggers. - repeatInterval The time interval of each trigger. "},"particle-system/emitter.html":{"url":"particle-system/emitter.html","title":"Emitter","keywords":"","body":"ShapeModule Public attributes: Properties Features position Relative to the location of the installed node. rotation Rotation relative to the mounted node. scale Relative to the scale of the mounted node. sphericalDirectionAmount Represents the interpolation between the current emission direction and the connection direction from the current position to the center of the node. randomPositionAmount Indicates the offset from the current launch position. Box Properties Features shapeType Box emitFrom From which part of the block the particles are emitted, edge: border; shell: surface; volume: inside Shpere\\Hemisphere) Properties Features shapeType Shpere\\Hemisphere radius Sphere radius radiusThickness 0 means launch from the surface of the ball, 1 means launch from the inside of the sphere, and 0 ~ 1 means launch from the surface to the center of the sphere Circle Properties Features shapeType Circle radius Radius of circle radiusThickness 0 means launching from the circle, 1 means launching from inside the circle, and 0 ~ 1 means launching from the circle to the center of the circle. arc Represents emission in a sector of the circle. mode Represents the emission method of particles in the fan-shaped area, random: random position, loop: cyclic emission in a certain direction, the same direction every time, pingPong: cyclic emission, every time On the contrary spread: indicates that the particles are emitted at a certain interval, for example, 0 indicates that they can be emitted at any position, and 0.1 indicates that they are emitted every tenth of the circumference. speed Represents the speed of particles emitted along the circumference. spread It indicates where the particles are emitted in the arc when they are emitted along the circumference. For example, if arc is 120° and spread is 0.1, particles will be emitted every 12° from the arc. Cone Properties Features shapeType Cone angle Angle between cone axis and generatrix. radius Radius of the top of the cone. length The axial length of the top section of the cone from the bottom. radiusThickness 0 means launching from the circle, 1 means launching from inside the circle, and 0 ~ 1 means launching from the circle to the center of the circle. arc Represents emission in a sector of the circle. mode Represents the emission method of particles in the fan-shaped area, random: random position, loop: cyclic emission in a certain direction and the same direction every time, pingPong: cyclic emission, every time on the contrary, spread: indicates that the particles are emitted at a certain interval, for example, 0 indicates that they can be emitted at any position, and 0.1 indicates that they are emitted every tenth of the circumference. speed Represents the speed of particles emitted along the circumference. spread It indicates where the particles are emitted in the arc when they are emitted along the circumference. For example, if arc is 120° and spread is 0.1, particles will be emitted every 12° from the arc. "},"particle-system/color-module.html":{"url":"particle-system/color-module.html","title":"Color Module","keywords":"","body":"Color Overtime Module Properties Features color For the parameters whose color changes with time, different color change modes can be used. "},"particle-system/size-module.html":{"url":"particle-system/size-module.html","title":"Size Modulle","keywords":"","body":"Size Overtime Module Property Role separateAxes Whether the three axes are scaled separately. size The curve of the size change with time can be used in different calculation modes. It is valid when separateAxes is false. X Y Z The curve whose size changes with time, different zooms can be set on the three coordinate axes, and different calculation modes can be used. It is effective when separateAxes is true. "},"particle-system/rotation-module.html":{"url":"particle-system/rotation-module.html","title":"Rotation Module","keywords":"","body":"Rotation Overtime Module Property Role separateAxes Whether the three axes rotate separately. X Y Z The curve of the rotation with time can be set to different rotations on the three coordinate axes, and different calculation modes can be used. X and Y are only valid when separateAxes is true. "},"particle-system/velocity-module.html":{"url":"particle-system/velocity-module.html","title":"Velocity Module","keywords":"","body":"Velocity Overtime Module Property Role space In which coordinate system the speed is calculated. x,y,z Different calculation modes can be used for the velocity components in the three directions. speedModifier Speed correction factor. "},"particle-system/limit-velocity-module.html":{"url":"particle-system/limit-velocity-module.html","title":"Limit Velocity Module","keywords":"","body":"Limit Velocity Overtime Module Properties Features space In which coordinate system the speed is calculated. limit Lower speed limit. When the speed exceeds this value, the current speed is linearly interpolated with this speed. It is valid when separateAxes is false. dampen Interpolation of current speed and lower speed limit. separateAxes Whether the three axes are restricted separately. limit X,Y,Z The lower speed limits of the three axes are valid when separateAxes is true. "},"particle-system/force-module.html":{"url":"particle-system/force-module.html","title":"Force Module","keywords":"","body":"Force Overtime Module Properties Features space In which coordinate system the acceleration is calculated. x,y,z The acceleration components in the three directions, can be calculated in different modes. "},"particle-system/texture-animation-module.html":{"url":"particle-system/texture-animation-module.html","title":"Texture Animation Module","keywords":"","body":"Texture Animation Module Property Role mode A grid texture contains an animation frame for particle playback. numTilesX The number of animation frames in the x direction. numTilesY The number of animation frames in the y direction. animation WholeSheet plays all the frames in the texture, singleRow only plays one row. frameOverTime The frame of animation playing in a cycle and the curve of time change. startFrame Play from the first few frames, the time is the life cycle of the entire particle system. cycleCount The number of playback cycles in a life cycle. "},"particle-system/renderer.html":{"url":"particle-system/renderer.html","title":"Renderer","keywords":"","body":"Particle Renderer The particle rendering part is controlled by ParticleSystemRenderer, which is divided into CPU renderer and GPU renderer. The CPU renderer maintains all particles through an object pool, generates corresponding vb and ib data according to the current state of the particles, holds the materials to be rendered by the particles, and saves the relevant rendering state. The current version of the GPU renderer generates particles on the CPU side, and only submits the vb and ib data of initial parameter, but the calculations related to the module are in the form of pre-sampled data. The data is submitted once during initialization, and the subsequent module system extracts and simulates the data on the GPU side to reduce the computing pressure on the CPU side. The subsequent versions will continue to optimize and improve the particle system. The current GPU version does not support TrailModule and LimitVelocityOvertimeModule. Property Role renderMode Set a particle patch generation method, billboard particles always face the camera, stretchedBillboard particles always face the camera, but will be stretched according to the relevant parameters, horizontalBillboard particle patches are always in the xz plane Parallel, verticalBillboard The particle patch is always parallel to the Y axis, but will face the camera, and mesh particles are a model. velocityScale In stretchedBillboard mode, the particles are stretched according to the speed in the direction of motion. lengthScale In stretchedBillboard mode, the particles are stretched by the size of the particles in the direction of motion. mesh When renderMode is mesh, specify the model of particles to be rendered. particleMaterial The material used for particle rendering, when the CPU renderer is selected, that is, when useGPU is not selected, the effect used by the material can only be builtin-particle, and other effects are not supported. When the GPU renderer is selected, that is, when useGPU is checked, the effect used by the material can only be builtin-particle-gpu, and other effects are not supported. trailMaterial The material used for trail rendering. The effect of the material only supports builtin-particle-trail, not other effects. . useGPU Whether to use the GPU renderer for particle rendering, it is not selected by default. When this option is not checked, use the CPU renderer ParticleSystemRendererCPU to render particles. When this option is checked, use the GPU renderer ParticleSystemRendererGPU to render particles. "},"particle-system/trail-module.html":{"url":"particle-system/trail-module.html","title":"Trail Module","keywords":"","body":"Trail Module Property Role mode Particle forms a trailing effect on each particle's trajectory. LifeTime The life cycle of trail. MinParticleDistance The shortest distance traveled by the particle for each trailing node. Space The coordinate system where the tail is located, World runs in the world coordinate system, and Local runs in the local coordinate system. ExistWithParticles Whether the tail disappears with the particles. TextureMode The expanded form of the texture on the tail, the Stretch texture is overlaid on the entire tail, and the Repeat texture is overlaid on the tail. WidthFromParticle The trai width inherited from the particle size. WidthRatio Trail width, if it is inherited from particle, it is the ratio of particle size ColorFromParticle Whether the trail color is inherited from the particles. ColorOverTrail The color of the trail color changes gradually with the length of the trailing itself. ColorOvertime Color gradient of trail color over time. "},"engine/animation/":{"url":"engine/animation/","title":"Animation","keywords":"","body":"Animation overview Cocos Creator 3D has a built-in general animation system to realize animation based on key frames. Animation Clips are assets that contain animation information. Animation Clips can be reused, and their state is saved in an object called an Animation State. Animation State can play, pause, stop, and change the animation. The Animation Component manages Animation Clips and their states in a unified manner, allowing users to implement animation functions at the component level. In the editor, one can easily produce animation clip assets. For example, through the Animation Editor, or using external assets already containing Animation Clip assets. The Animation Components documentation describes how to use Animation Components and Animation Clips to control the playback of animations. The Animation Clip documentation describes the composition of Animation Clips_ or creating _Animation Clips programmatically. The Skeletal Animation documentation describes how to use this common but special type of animation. "},"engine/animation/animation-component.html":{"url":"engine/animation/animation-component.html","title":"Animation Components","keywords":"","body":"Animation component Animation components control the playback of animations. Animation components are added to nodes in exactly the same way as other components: import { AnimationComponent, Node } from \"cc\"; function (node: Node) { const animationComponent = node.addComponent(AnimationComponent); } The animation component manages a set of animation clips. Before the animation component begins, it creates a corresponding animation state object for each animation clip. The animation state controls the playback process of an animation clip at a node, and an animation clip can be used by multiple animation states at the same time. In an animation component, the animation state is identified by name. The default name of each animation state is the name of its animation clip. Playing and switching animations play() causes the animation component to start playing the specified animation: animationComponent.play('idle'); // play animation state 'idle' When playing, the old animation will be stopped immediately, this switch is very abrupt. In some cases, we want this switch to fade in and out. The crossFade() method can be used to achieve this. crossFade() will complete the switch smoothly within the specified period: animationComponent.play('walk'); /* ... */ // When you need to switch to running animation animationComponent.crossFade('run', 0.3); // Smoothly switch from walking animation to running animation in 0.3 seconds The crossFade() fade-in and fade-out mechanism makes it possible for more than one animation state to play at the same time. Therefore, the animation component has no concept of the current animation. The animation component still provides pause(), resume() and stop() methods. These calls pause, continue, and stop all animation states that are playing, however, they also pause, resume, and stop switching animations. Animation State Sometimes it is necessary to perform other operations on the animation state, for example, to set its speed. You can get the animation state through getState(): const animationComponent = node.getComponent(AnimationComponent); animationComponent.clips = [ idleClip, runClip ]; // Get the status of `idleClip` const idleState = animationComponent.getState(idleClip.name); You can set the speed of the animation playback: animationComponent.getState('idle').speed = 2.0; // Play standby animation at double speed The animation state also provides play(), pause(), resume() and stop(). These control common playback functions. When these common playback controls cannot meet your requirements, it is also possible to manipulate the playback of the animation state in a custom way. Default animation When the animation component's playOnLoad is true, it will automatically play the default animation clip, defaultClip, the first time it runs. Frame events You can add events for each time point of the animation. The events of an AnimationClip contains all event descriptions for the animation, and each event description has the following properties: { frame: number; func: string; params: any[]; } frame represents the time point at which the event was triggered, in seconds. For example, 0.618 means that the event will be triggered when the animation reaches 0.618 seconds. func represents the method name that is called back when the event is triggered. When the event is triggered, a search for a method named func on all components of the current node, once found, it is called with params passed to it. Example: import { AnimationComponent, Component } from \"cc\"; class MyScript extends Component { constructor() { } public start() { const animationComponent = this.node.getComponent(AnimationComponent); if (animationComponent && animationComponent.defaultClip) { const { defaultClip } = animationComponent; defaultClip.events.push({ frame: 0.5, // trigger event on the 0.5 second func: 'onTriggered', // name of event to be called params: [0], // parameters passed to `func` }); defaultClip.updateEventDatas(); } } public onTriggered(arg: number) { console.log(`I'm triggered!`); } } The above code indicates that the default animation clip of the animation component at the node where the MyScript component is located. At the 0.5th second, it will call the test() method of the MyScript component and pass the parameter 0. "},"engine/animation/animation-clip.html":{"url":"engine/animation/animation-clip.html","title":"Animation Clips","keywords":"","body":"Animation clip An Animation Clip is a set of Animation Curves that contains all animation data. Animation Curve The Animation Curve describes the change of a certain attribute value on an object with time. Internally, the Animation Curve stores a series of time points, and each time point corresponds to a (curve) value, called a frame, or key frame. When the animation system is operating, the Animation Component calculates the (result) value at the specified time point according to the current animation state and assigns it to the object to complete the attribute change; this calculation process is called sampling. The following code snippet demonstrates how to create Animation Clips programmatically: import { AnimationClip, animation, js } from \"cc\"; const animationClip = new AnimationClip(); animationClip.duration = 1.0; // The cycle of the entire animation // clip. No frame time should be greater than this attribute. animationClip.keys = [ [ 0.3, 0.6, 0.9 ] ]; // Frame time shared by // all curves of this animation clip animationClip.curves = [{ // he property curve on the component modifiers: [ // The target is the current node // \"Body\" child node new animation.HierarchyPath('Body'), // `MyComponent` new animation.ComponentPath(js.getClassName(MyComponent)), // `value` attribute 'value', ], data: { keys: 0, // Index to `AnimationClip.keys`, ie [0.3, 0.6, 0.9] values: [ 0.0, 0.5, 1.0 ], }, }]; The above Animation Clip contains a curve to control the value property of the MyComponent component of the Body sub-node. The curve has three frames, so that the value property becomes 0.5 at 0.3 seconds and 0.5 at 0.6 seconds and then becomes 1.0 at 0.9 seconds. Note: the frame time of the curve is indexed into the AnimationClip.keys array by reference. Multiple curves can share the frame time. This will bring additional performance optimizations. Target The target of the Animation Curve can be any JavaScript object. The modifiers field specifies how runtime addresses the current node object to the target object. modifiers is an array, each element of it expresses how to address from the object at the upper level to another object. The object addressed by the last element is the target object of the curve. This behavior is like a file system path, so each element is called a target path. When the target path is string/number, this indicates the attribute addressed to the upper-level object, which itself specifies the attribute name. Otherwise, the target path must be an object that implements the interface animation.TargetPath. Cocos Creator 3D has the following built-in classes that implement the self-interface animation.TargetPath: animation.HierarchyPath treats the upper-level object as a node and addresses it to one of its child nodes; animation.ComponentPath treats the upper-level object as a node and addresses it to one of its components. Target paths can be combined arbitrarily, as long as they have the correct meaning: // The target object is modifiers: [ // \"nested_1\" child node \"nested_2\" child node \"nested_3\" child node new animation.HierarchyPath('nested_1/nested_2/nested_3'), // `BlahBlahComponent` component new animation.ComponentPath(js.getClassName(BlahBlahComponent)), // of the `names` attribute 'names', // The first element 0, ] When your target object is not a property, but must be returned from a method, custom target path is useful: class BlahBlahComponent extends Component { public getName(index: number) { return _names[index]; } private _names: string[] = []; } // The target object is modifiers: [ // \"nested_1\" child node \"nested_2\" child node \"nested_3\" child node new animation.HierarchyPath('nested_1/nested_2/nested_3'), // `BlahBlahComponent` component new animation.ComponentPath(js.getClassName(BlahBlahComponent)), // of the `names` attribute { get: (target: BlahBlahComponent) => target.getName(0), }, ] If you want your custom target paths to be serializable, declare them as classes: @ccclass class MyPath implements animation.TargetPath { @property public index = 0; constructor(index: number) { this.index = index; } get (target: BlahBlahComponent) { return target.getName(this.index); } } // Target modifiers: [ \"nested_1\" child node \"nested_2\" child node \"nested_3\" child node new animation.HierarchyPath('nested_1/nested_2/nested_3'), // `BlahBlahComponent` component new animation.ComponentPath(js.getClassName(BlahBlahComponent)), // // of the `names` attribute new MyPath(0), ] The addressing of the target object is done at runtime, this feature allows Animation Clips to be reused on multiple objects. Assignment When the value is sampled, the assignment operator = will be used to set the value to the target object by default. Sometimes, however, it is not possible use the assignment operator to set values. For example, when the uniform of a Material object needs to be set, it cannot be performed through the assignment operator. This is because the Material object only provides setUniform(uniformName, value) method to change the uniform. For this case, the curve field valueAdapter provides a mechanism for you to customize how the value to the target object is set. Examples are as follows: class BlahBlahComponent { public setUniform(index: number, value: number) { /* */ } } { // Curve valueAdapter: { // Called when the curve is instantiated forTarget(target: BlahBlahComponent) { // do something useful here return { // Called every time the value of the target // object is set set(value: number) { target.setUniform(0, value); } }; } }, }; If you want your custom assignments to be serializable, declare them as classes: @ccclass class MyValueProxy implements animation.ValueProxyFactory { @property public index: number = 0; constructor(index: number) { this.index = index; } // Called when the curve is instantiated public forTarget(target: BlahBlahComponent) { // do something useful here return { // Called every time the value of the target object // is set set(value: number) { target.setUniform(0, value); } }; } } animation.UniformProxyFactory is one such example of a custom assignment class, that implements the uniform value of setting the material: { // the target object modifiers: [ // `ModelComponent` Component new animation.ComponentPath(js.getClassName(ModelComponent)), // `sharedMaterials` attribute 'sharedMaterials', // The first material 0, ], valueAdapter: new animation.UniformProxyFactory( 0, // Pass index 'albedo', // Uniform name ), }; Sampling If the sampling time point is exactly equal to the time point of a key frame, the animation data on the key frame is used. Otherwise, when the sampling time is between two frames, the resulting value should be affected by the two frames of data at the same time. The ratio of the sampling time point to the time interval of two key frames ([0,1]) reflects the degree of influence. Cocos Creator 3D allows this ratio to be mapped to another ratio to achieve different gradient effects. These mapping methods are called gradient methods. After the ratio is determined, the final result value is calculated according to the specified interpolation method. Both the gradient and interpolation methods affect the smoothness of the animation. Gradient method You can specify the gradient method for each frame, or you can specify a uniform gradient method for all frames. The gradient method can be the name of the built-in gradient method or the Bezier control point. The following lists several commonly used gradient methods. linear keeps the original ratio, that is, linear gradient; this method is used by default when no gradient method is specified. constant always uses a scale of 0, i.e. no gradient; similar to the interpolation method Step; The gradient of quadIn changes from slow to fast. The gradient of quadOut changes from fast to slow. The gradient of quadInOut changes from slow to fast to slow again. The gradient of quadOutIn changes from fast to slow to fast. IBezierControlPoints Expand comparison Curve value and interpolation method Some interpolation algorithms require additional data to be stored in the curve value of each frame. Therefore, the value type of the curve value and the target attribute are not necessarily the same. For numeric types or value types, Cocos Creator 3D provides several general interpolation methods. Also, custom interpolation method can be defined. When the interpolate property of the curve data is true, the curve will try to use the interpolation function: If the type of curve value is number, Number, linear interpolation will be applied; If the curve value inherits from ValueType, the lerp function of ValueType will be called to complete the interpolation. Most of the value types built into Cocos Creator 3D implement its lerp as linear interpolation. If the curve value is interpolable, the curve value's lerp function will be called to complete the interpolation 2. If the curve value does not satisfy any of the above conditions, or when the interpolate property of the curve data is false, there will be no interpolation operation. Always use the curve value of the previous frame as the result. import { AnimationClip, color, IPropertyCurveData, SpriteFrame, v3 } from \"cc\"; const animationClip = new AnimationClip(); const keys = [ 0, 0.5, 1.0, 2.0 ]; animationClip.duration = keys.length === 0 ? 0 : keys[keys.length - 1]; animationClip.keys = [ keys ]; // All curves share a list of frame times // Linear interpolation using values const numberCurve: IPropertyCurveData = { keys: 0, values: [ 0, 1, 2, 3 ], // The interpolate property is turned on by default /* interpolate: true, */ }; // Use lerp() of value type Vec3 const vec3Curve: IPropertyCurveData = { keys: 0, values: [ v3(0), v3(2), v3(4), v4(6) ], interpolate: true, }; // No interpolation (because interpolation is explicitly disabled) const colorCuve: IPropertyCurveData = { keys: 0, values: [ color(255), color(128), color(61), color(0) ], interpolate: false, // 不进行插值 }; // No interpolation (because SpriteFrame cannot interpolate) const spriteCurve: IPropertyCurveData = { keys: 0, values: [ new SpriteFrame(), new SpriteFrame(), new SpriteFrame(), new SpriteFrame() ], }; The following code shows how to customize the interpolation algorithm: import { ILerpable, IPropertyCurveData, Quat, quat, Vec3, v3, vmath } from \"cc\"; class MyCurveValue implements ILerpable { public position: Vec3; public rotation: Quat; constructor(position: Vec3, rotation: Quat) { this.position = position; this.rotation = rotation; } /** this method will be called for interpolation * @param this starting curve value * @param to target curve value * @param t to target curve value * @param dt he frame time interval between the start curve value and the target curve value */ lerp (to: MyCurveValue, t: number, dt: number) { return new MyCurveValue( // The position attribute is not interpolated this.position.clone(), // Rotate property uses Quat's lerp() method this.rotation.lerp(to.rotation, t), ); } /** This method is called without interpolation. * It is optional, if this method is not defined, the curve value itself (ie `this`) is used as the result value. */ getNoLerp () { return this; } } /** * A curve is created, which realizes a smooth rotation but a sudden change of position throughout the cycle. */ function createMyCurve (): IPropertyCurveData { const rotation1 = quat(); const rotation2 = quat(); const rotation3 = quat(); vmath.quat.rotateY(rotation1, rotation1, 0); vmath.quat.rotateY(rotation2, rotation2, Math.PI); vmath.quat.rotateY(rotation3, rotation3, 0); return { keys: 0 /* frame time */, values: [ new MyCurveValue(v3(0), rotation1), new MyCurveValue(v3(10), rotation2), new MyCurveValue(v3(0), rotation3), ], }; } Both the gradient and interpolation methods affect the smoothness of the animation. Loop Mode You can set different loop modes for Animation Clips by setting AnimationClip.wrapMode(). The table below represents several commonly used looping modes: AnimationClip.wrapMode Effects WrapMode.Normal Stop after playing to the end. WrapMode.Loop Loop playback. WrapMode.PingPng After playing from the beginning to the end of the animation, play backwards from the end to the beginning, and so on For more looping modes, see WrapMode. 1The node of the Animation Clip is the node attached to the Animation Component that guides the use of the Animation State object of the Animation Clip. ↩ 2 For numerical values, quaternions, and various vectors, Cocos Creator 3D provides corresponding interpolable classes to implement cubic spline interpolation. ↩ "},"engine/animation/skeletal-animation.html":{"url":"engine/animation/skeletal-animation.html","title":"Skeletal Animation","keywords":"","body":"Skeletal animation Skeletal Animation is a common but special type of animation. Two different systems are provided and each is optimized for different purposes. Seamless switching between these two systems can be as simple as toggle the useBakedAnimation switch on SkeletalAnimationComponent, even at runtime. when enabled, the pre-baked system will be used, or the real-time calculated system if otherwise. Pre-baked Skeletal Animation System The dominant purpose of this system is performance, and some sacrifices in expressiveness are also considered acceptable. Cocos Creator 3D has made many low-level optimizations in a targeted manner. The current runtime process is roughly as follows: All animation data will be pre-sampled in advance according to the specified frame rate and baked onto a global-managed joint texture atlas. Depending on whether the operating platform supports floating-point textures, the corresponding texture format will be RGBA32F, or automatically fallback to RGBA8 if not available (The rendering results should be identical, it is only the fail-safe approach for really low-end devices, and shouldn't be of any concern for game developers). Each Skeletal Animation Component (SkeletalAnimationComponent) is responsible for maintaining the current playback progress, stored in the form of UBO (a vec4). Each skinning model component (SkinningModelComponent) holds a pre-baked skinning model class (BakedSkinningModel). Based on the bounding box information pre-baked in the same way to do frustum culling, update the UBO, and get the current data from the texture atlas on the GPU to complete the skinning. Real-time calculated Skeletal Animation System The dominant purpose of this system is expressiveness, ensuring the correct display of all details, and complete program control capabilities. The current runtime process is roughly as follows: All animation data are calculated dynamically according to the current global time. Animation data will be output to the skeleton node tree of the scene. Users and any other system can affect the skin effect by manipulating this node tree. Each Skinning Model Component (SkinningModelComponent) holds a common Skinning Model class (SkinningModel). Extract the transformation data from joint node tree, do frustum culling, upload the complete joint transformation information of the current frame to UBO, and complete the skinning in the GPU. This provides the fundamental support for all the following functions: Blendshape support Mixing and masking of any number of Animation Clips Inverse kinematics, secondary physics Explicit procedural control over any joint tranformations Selection and best practice of two systems After importing all model assets, all prefabs use the pre-baked system by default to achieve the best performance. It is recommended that you only use the real-time calculated system if you clearly feel that the performance of the pre-baked system cannot reach the standard. Although the two systems can be switched seamlessly at runtime, try to do this as less frequent as possible, because each switch involves the reconstruction of the underlying rendering data. Skinning algorithm We have two built-in common standard skinning algorithms, which have similar performance and only affect the rendering results: LBS (Linear Blend Skinning): joint information is stored in the form of a 3x4 matrix, and the matrix is ​​interpolated directly to achieve skinning, and there are well-known problems such as volume loss, etc. DQS (Dual Quaternion Skinning): The joint information is interpolated in the form of dual quaternions, which is more accurate and natural for the skeleton animation without scaling transformation, but for performance reasons, there are pragmatic approximation measures for scaling animations. The engine uses LBS by default. You can switch the skinning algorithm by modifying the updateJointData function reference of the engine skeletal-animation-utils.ts and the header file reference in cc-skinning.chunk. It is recommended that projects with higher pursuit of skin animation quality can try to enable DQS, but since there is no fma instruction before GLSL 400, operations such as cross cannot bypass floating-point cancellation on some GPUs, and the error is relatively high. This may introduce some visible defects. Socket system If you need to attach some external nodes to the specified joint joints, you need to use the Socket system of the Skeleton Animation Component: Create a new child node directly under the node of SkeletalAnimationComponent to be attached to. Add an array element in the sockets list of the SkeletalAnimationComponent. Select the path of the joint to be attached to from the drop-down list (note that the defaultClip property of the SkeletalAnimationComponent must be a valid clip, the content of the drop-down list depend on this), and specify the target as the child node just created. This child node becomes a socket node, you can put any node under and it will follow the transformations of the specified joint. FBX or glTF assets will be automatically adapted to use this socket system at import time, without any manual interference. About Dynamic Instancing Based on the framework of the pre-baked skeletal animation system, the instancing of the skin model has also become a function within reach, but to ensure correctness, you need to collect some relatively low-level information. The fundamental problem here is that the joint texture atlass used by each model in the same drawcall must be the same. If they are not the same, the display effect will be completely messy. The way to distribute all the animation data used at runtime to each joint texture atlases becomes a project-specific information, thus needs developer's input. See the joint texture layout panel documentation for more details on how to configure this. Note: Instancing is only supported under the pre-baked system. Although we do not strictly prohibit instancing under the real-time calculated system (will only trigger some warnings in the editor), there will be problems with the rendering results. Depending on the asset allocation situation at the time, all the instances could be playing the same clip at best, or more often, completely mad rendering results. Note: For models with instancing turned on in the material, the planar shadow system will also automatically draw using instancing. In particular, the shadow of the skin model has a higher requirement for the layout of the joint texture atlas, because the pipeline state of the shadow is unified, all the animation of the skin model with the shadow turned on needs to be put into the same texture (Compared to when drawing the model itself, only the instances in the same drawcall need to be put into the same texture). Batched Skinning Model Component The joint texture uploaded by the GPU on the bottom layer has been globally automatically batched and reused. The upper layer data can currently be combined with all the sub-skin models controlled by the same joint animation component by using the BatchedSkinningModelComponent: The batch version of the effect is relatively complicated to write, but it can basically be based on the common effects used by the sub-materials, adding some relatively direct preprocessing and interface changes. The built-in assets in the editor (util/batched-unlit) provide a The integrated version of builtin-unlit can be referenced. Note: Only using the Batched Skinning Model Component under the pre-baked system can guarantee the correctness. Although it can also be used under the real-time calculated system, there will be rendering problems when the number of joints after the merger exceeds 30 (the maximum number of Uniform arrays). "},"tween/":{"url":"tween/","title":"Tween","keywords":"","body":"Tweening In order to be fully compatible with and maintain the experience of the Cocos Creator 2D easing system, all the Cocos Creator 2D functions are transplanted in Cocos Creator 3D. Note: action has been abandoned, please use tween. Note: Starting from v1.0.3 there is no longer a dependency on tween.js. If you use the relevant features of tween.js, please adapt. Note: In v1.0.4 the onStart, onUpdate, onComplete callbacks were added to the optional attributes of to and by. The difference from the previous tween.js is mainly optional attributes, explained as follows: The value definition of easing has been changed (compatibility is done here). In addition to easing, onStart, onUpdate, onComplete, other properties are not supported yet (checked here, the console will have a corresponding warning). Example import { _decorator, Component, Vec3, tween } from \"cc\"; @ccclass(\"tween-test\") export class tweentest extends Component { private _pos: Vec3 = new Vec3(0, 0, 0); start () { /** Easing _pos */ tween(this._pos) .to(3, new Vec3(10, 10, 10), { easing: 'bounceInOut' }) .to(3, new Vec3(0, 0, 0), { easing: 'elasticOut' }) .union() .repeat(2) // 执行 2 次 .start(); /** Easing Node, here will ease the Node's position property */ tween(this.node) .to(3, { position: new Vec3(10, 10, 10) }, { easing: 'bounceInOut' }) .to(3, { position: new Vec3(0, 0, 0) }, { easing: 'elasticOut' }) .union() .repeat(2) // execute 2 times .start(); } } Precautions repeat semantics Previously, the semantics of repeat was repeated several times. In order to fully maintain the design of Cocos Creator 2D, repeat is executed several times, that is, repeat(1) stands for one execution. Restrictions In-order to reduce the frequency of updating the Node Transform information, Node maintains a dirty state. Only when an interface that may change the Node Transform information is called, will dirty be set to the state that needs to be updated. Note: the current interface has certain restrictions, for example position obtained through this.node.position is a generic Vec3. When this code this.node.position.x = 1 is executed, only the getter of position is executed, and the setter of position is not executed. Since dirty is not updated, it will cause the Transform information of the nodes used during rendering not to be updated. Such calls are not supported, but the use of setPosition or position is encouraged. Example: let _pos = new Vec3(0, 1, 0); this.node.position = _pos; // here will pass the position setter this.node.setPosition(_pos); // here will setPosition through interface The right way of easing In the new Tween module, you can obtain properties with getter and setter, such as the position property of node (in the simple example above). During the easing process, the corresponding interface will be carried out, making setting changes to ensure that dirty is updated normally. Note: pay attention to stop the corresponding slow motion when switching scenes. Tween interface introduction Interface Explanation to Add an interval action that calculates the absolute value of the attribute by Add an interval action to calculate the relative value of the attribute set Add a momentary action that sets the target property directly delay Add an instant action of delay time call Add an instant action of call callback target Add a instant action to directly set the slow-motion target union Package the easing action of the context into one then Insert a Tween into the easing queue repeat Execution several times (previously repeated several times, if using, please adapt) repeatForever Always repeat execution sequence Add a sequential slow motion parallel Add a simultaneous easing start Start slow motion stop Stop slow motion clone Clone Easing show To enable rendering on the node chain, the slowing target needs to be Node hide Disable rendering on the node chain, the slowing target needs to be Node removeSelf Move the node out of the scene tree, the slowing target needs to be Node Optional attributes of to and by The definition is as follows: interface ITweenOption { easing?: TweenEasing | ((k: number) => number); progress?: (start: number, end: number, current: number, ratio: number) => number; onStart?: (target: object) => {}; onUpdate?: (target: object, ratio: number) => {}; onComplete?: (target: object) => {}; } The difference with Cocos Creator 2D is the addition of properties such as onStart, onUpdate, and onComplete. These properties are callback functions, which will be passed into the easing target when called. In addition, an additional value of the current easing will be passed in when onUpdate is called, and the range is (0-1). Example of using callback Taking onUpdate as an example, the following code eases a position, and then setting it to multiple objects in onUpdate, this demonstrates batch easing. import { Node, tween, Vec3 } from \"cc\"; const nodeArray: Node[] = []; // Replace here with your node array const tweenTagertVec3 = new Vec3(); tween(tweenTagertVec3) .by(1, new Vec3(1, 1, 1), { 'onUpdate': (target: Vec3, ratio: number) => { for (let i = 0; i Automatic destruction Starting from v1.0.4 when the easing target is Node, it will listen to its destruction event for automatic destruction of the easing. This calls the target method and also automatically updates the listener. Note: related test cases are located on GitHub. Note: Please refer to Using the Tween System documentation. "},"physics/physics.html":{"url":"physics/physics.html","title":"Physics","keywords":"","body":"Physics Introduction Cocos Creator 3D currently supports the lightweight collision detection system builtin and the physics engine cannon.js with physical simulation, and the asm.js/wasm version ammo.js of the powerful physics engine bullet, also we provides users with efficient component-based workflow and convenient methods of use. Physics World And Elements Elements in the physics world can be divided into rigid body. We can adding physics elements by adding a collider (Collider) or rigid body (RigidBody) component to the game object. The physics system will perform calculations on these elements to make their behaviors the same with the real world. Note: The rigid body here doesn't refer to the RigidBody component. The RigidBody component is used to control the properties related to the physical behavior of the rigid body. Adding a Physical Element Adding a physical element to the world can be divided int the following steps： Create a new shape Cube； Click Add Component on the Inspector panel witch is on the right of editor； Select BoxColliderComponent under the Physics menu, and adjust the parameters； add a RigidBodyComponent component in order to make it have physical behavior。 In this way we get a physical element that has both a collider and a physical behavior. Perfecting The Physics World We can add a ground to the world. Following the steps 1,2,and 3, you can add another Plane with collider only. Then, adjust the view of the camera (select the camera and press the shortcut Ctrl + Shift + F to align the camera view to screen). Finally, click the run button, you can see the changes of physical elements in the scene. The final scene is shown in the following figure: Note: You can see the new preview result on the browser you just ran by clicking the refresh button directly after adjusting the property value of the component. Composition Of Physical Elements A physical element can be composed of the following ways: A RigidBody component One or more Collider components One RigidBody component plus one or more collider components More Detailed Modules Additional physics system will be introduced in more detail through the following modules: Module Description Physics Options Introduces the optional options of low-level physics engine in Cocos Creator 3D Physics System Introduces the physics system and a series of properties and interfaces of the physics system. Physics Component Introduces some physics components and a series of properties on the panel. Physics Usage Further introduces the use of physics, events, group masks, etc. Continue to the Physics Options documentation。 "},"physics/physics-item.html":{"url":"physics/physics-item.html","title":"Physics Options","keywords":"","body":"Choosing The Physics System Suitable For Your Project In the panel Project -> Project Settings -> Module Options of the Editor, you can choose a physics engine suitable for the needs of the project for development. Note: The default is cannon.js physics engine。 Note: The physics engine can be switched at will during development。 Collision Detection:builtin builtin only has the function of collision detection. Compared with other physics engines, it has no complicated physical simulation calculations. If your project does not require the physical simulation of this part, you can consider using builtin, which will make the size of game's package smaller. If you use builtin for development, please note the following: builtin only has events of type trigger. RigidBodyComponent is invalid. isTrigger in ColliderComponent is a trigger regardless of whether the value is true or false. Physics Engine: cannon.js cannon.js is an open source physics engine, which uses js language to develop and implement more comprehensive physics functions, if your project needs more complex physical functions, then you can consider using cannon.js. The size of the cannon.js module is 141KB. Physics Engine: ammo.js ammo.js is the asm.js/wasmVersion (currently only asm.js version) of the bullet physics engine, it is compiled by emscripten tool. Bullet has perfect physical functions, and we will put more work here in the future. It should be noted that currently the ammo.js module has a size of about 1MB. Do Not Use Physics If you don't need to use any physics related components and interfaces, you can uncheck the yellow box, so that you can get a smaller package when publishing. Note: If it is unchecked, the project will not be able to use physics related components and interfaces, otherwise an error will be reported during runtime. Continue to the physics system documentation. "},"physics/physics-system.html":{"url":"physics/physics-system.html","title":"Physics System","keywords":"","body":"Physics System The physics system is used to manage all physics related functions. Currently, it is responsible for synchronizing physical elements, triggering physics events and scheduling iterations of the physical world. Physics World When the physics world iterates, physical calculations will be made on physical elements, such as calculating whether each object collides and the force of the object. When the calculation is completed, the physics system will update the physics world to the scene world, so that the game objects will generate corresponding physical behaviors. The current physics execution flow of Coccos Creator 3D: trigger physics events -> sync scene data to physics -> physics world iteration -> sync physics data to scene. Note: There is only a single physical world, and the functional support of the multi-physics world will be discussed later. Scene World And Physics World: Physics System Properties The properties of the physics system can only be set through the code for the time being. A setting panel will be added in the future, please pay attention to the update announcement. Properties Description enable Whether to enable the physics system, the default is true allowSleep Whether to allow the physics system to automatically sleep, the default is true useFixedTime Whether the physical simulations used a fixed time(the number of steps will be fixed to 1), the default is true maxSubStep The maximum number of physical simulation sub-steps per frame, the default is 2 deltaTime The time spent in each step of physical simulation, the default is 1/60, note that is not every frame gravity The gravity value of the physical world, the default is (0, -10, 0) defaultMaterial Get the default physics material (read only) Obtain the instance of physics system using: PhysicsSystem.instance Continue to the physics component documentation. "},"physics/physics-component.html":{"url":"physics/physics-component.html","title":"Physics Component","keywords":"","body":"Physics Component Cocos Creator 3D currently provides users with a variety of collider components, common rigid body components, as well as tool-type constant force components. Collider Component The collider component is used to represent the shape of the collision body of a rigid body. Different geometric shapes have different properties. BoxColliderComponent Properties Description material The physics material referenced by the collider (the default physics material was referenced when it is empty) isTrigger Whether it is a trigger, the trigger will not generate physical feedback center The origin of the shape in the local coordinate system size The size of the box, ie length, width, height SphereColliderComponent Properties Description (Other reference box colliders) radius Radius of the sphere CylinderColliderComponent Properties Description (Other reference box colliders) direction The reference axis of the cylinder's extended direction height The total height of the cylinder radius The radius of the circular surfaces at both ends of the cylinder Note: builtin does not currently support cylindrical components. CapsuleColliderComponent Properties Description（Other reference cylinders and box colliders） cylinderHeight The height of the cylinder in the capsule radius The radius of the sphere in the capsule Note: cannon.js does not support capsule components. It is recommended to use two spheres and cylinders and piece them together. MeshColliderComponent Properties Description (Other reference box colliders) mesh The mesh asset referenced by the mesh collider, used to initialize the mesh collision volume Note: builtin does not currently support the mesh collider component. Note: cannon.js has poor support for the mesh collider component, and only allows detection with the sphere collider**. Note: ammo.js currently only supports static mesh colliders (mass is 0 or without a RigidBody component). RigidBodyComponent In order to more easily simulate physical behavior, Cocos Creator 3D provides users with rigid body components. Properties Description (The property values ​​in the above picture are all default values) mass The mass of the object (when the mass is 0, it represents a static rigid body, which is the same as the effect without the rigid body component) linearDamping Linear damping, used to reduce the linear velocity of an object angularDamping Angular damping, used to reduce the rotation rate of objects isKinematic Whether the rigid body is controlled by the user, regardless of the physics engine useGravity Whether the rigid body is affected by gravity fixedRotation Whether it is necessary to fix the object's rotation during collision linerFactor Linear factor, which can affect the change of linear velocity in each axis angularFactor Rotation factor, which can affect the change of the rotation speed of each axis Note: builtin does not currently support RigidBodyComponent. ConstantForce This is a tool component that depends on a RigidBodyComponent and will apply a given force and torque to a rigid body every frame. Properties Description force The force applied to the rigid body in the world coordinate system localForce The force applied to the rigid body in the local coordinate system torque Torque applied to the rigid body in the world coordinate system localTorque Torque applied to the rigid body in the local coordinate system Note: builtin does not currently support Hengli components*. Continue to the using physics documentation. "},"physics/physics-use.html":{"url":"physics/physics-use.html","title":"Using Physics","keywords":"","body":"Using Physics In order to introduce how to use physics better, the following modules will be introduced: Module Description Collision Component Introduces the design of the Collider component and its relationship with the RigidBody component Physics Material Introduced physics material assets in Cocos Creator 3D Rigid Body Component Introduces some code usage examples of the RigidBody component Physics Event Introduced the physics events in Cocos Creator 3D Group Mask Introduces the use of group and mask in physics filter detection Raycast Detection Introduces the ray detection function of the physics collider Continue to the Collision Components documentation. Or go back to Physics Introduction documentation. "},"physics/physics-collider.html":{"url":"physics/physics-collider.html","title":"Physics Collider","keywords":"","body":"Collision Component Getting the Collider Component The following code works in both JavaScript and TypeScript: this.getComponent('cc.BoxColliderComponent') - or - this.getComponent(cc.BoxColliderComponent) Collider and Trigger The Collider component has an isTrigger attribute. When isTrigger is true, it is represented as a trigger, otherwise it is a collider. Note: to learn more about he differences between colliders and triggers please review the Physics Event documentation. The relationship between Collider and RigidBody The Collider and RigidBody components are meant to serve physical elements, and control a part of the attributes on the physical elements respectively. This also means that to understand the relationship between them, you need to first understand how the physical elements in Cocos Creator 3D are composed. How Elements Are Composed In the Introduction to Physics documentation, it is introduced that a physical element is composed of a Collider and RigidBody components. This indicates that there can only be one or zero physical elements RigidBody components, and there can be multiple Collider components. It is easy to see if there is a physical element for a single node, but if we consider the node chain as a single unit, it will be difficult to see which nodes and which components the physical element is composed of. There are two ways to consider viewing the the node chain: As long as each node has a physics component, it is an element, which means that the components of the parent and child nodes have no dependencies and require multiple shapes. Add the corresponding Collider component to the node. Start searching from the own node to the parent chain node. If the RigidBody component is found, bind its own Collider component to the node, otherwise the Collider component on the entire chain will share a RigidBody component, the node corresponding to the element is the node corresponding to the topmost Collider component. These two ideas have their pros and cons: Idea 1 is not intuitive enough. Multiple shapes can only be added to one node. To display the shape, you need to add a child node model. When adjusting the parameters in Idea 1, two places need to be adjusted, namely the position information of the child node and the data information of the corresponding Collider component on the parent node. Idea 2 adds the coupling of node. When a node is updated, the corresponding dependent node needs to be updated. When the node chain is destroyed, more content needs to be maintained, and the node chain needs to deal with complex logic when it is repeatedly destroyed in Idea 2. Note: the physics engine in Cocos Creator 3D is currently using idea 1, which may be adjusted in the future. attachedRigidbody property of Collider The Collider component has an attachedRigidbody property. This property can get the RigidBody component bound to the current Collider component, but please note the following points: When there is no RigidBody component in its own node, this property is returned as null. attachedRigidbody is a read-only property. Auto-Scaling Each component is bound to a node, some components dynamically update their data based on the bound node, collider components update their data based on the node The information automatically updates the corresponding shape data, allowing collision bodies to more easily fit the rendered model. Updating data to model components as an example. The model component automatically updates the model's world matrix according to the bound nodes, thus changing the node's position, scaling, rotation, etc. , which allows the rendered model to have a corresponding affine transformation. However, some properties of collider shape lead to a different treatment of scaling. Collider shape are generally described by their geometry structure. Most of the collider shape are of the convex hull type. These properties restrict transformations such as tangential, non-uniform scaling, etc., taking the sphere collider as an example. Assume that the scaling information of the bound nodes is (1,2,1) (non-uniform scaling), since the structure described by the model and the collider is not same, the sphere model is represented using multiple primitives (e.g., triangles) that, when scaled, model shape into a pebble-like shape; however, the sphere collider is described by the size of the radius, which is scaled in the dimension with the largest value (to ensure that the collision body can be as large as possible of the enclosing model), but scaled it is still a sphere. PhysicsMaterial The collision body has physics material properties. Related content is described in detail in the physics materialdocumentation. The difference between shared and non-shared interfaces is mainly introduced. The Collider component provides two properties to get and set. These are material and sharedMaterial, and their differences are as follows: Setting sharedMaterial or material has the same effect. It is in a shared state before calling these interfaces. When it is found that the set and the current reference are not the same instance, obtaining a material later will not generate a new material instance. At this time, it is a non-shared state. Under the premise of shared state, obtaining material will generate a new material instance to ensure that only the current collision body references the material, so that the modification will not affect other collision bodies, and then it will be in the non-shared state. Obtaining sharedMaterial does not generate a new one, but directly returns a reference. Continue to the physics material documentation. "},"physics/physics-material.html":{"url":"physics/physics-material.html","title":"Materials","keywords":"","body":"Physics Material In Cocos Creator 3D, the physics material is a asset, which records the surface information of the object. This is used to calculate the friction and elastic force of the colliding object. Properties of Materials The properties of Physics Materials are shown below: Properties Description friction Coefficient of friction restitution Coefficient of restitution When in contact with other surfaces, these coefficients are used to calculate the corresponding friction and elastic forces. Creating Physics Materials Physics Materials can be created in two ways: Create in editor Code instantiation The way to create with the editor is shown below: Instantiated in the code: let newPmtl = new PhysicMaterial(); newPmtl.friction = 0.1; newPmtl.restitution = 0.1; Application of materials The physics material is set in units of collision bodies, and each Collider has a material property (when not set, Collider will refer to the default physics material in the physics system). The application to Collider is also divided into editor operation and code operation. To operate in the editor, just drag the asset into the cc.PhysicMaterial property box, as shown in the following figure: Operation in the code: const collider = this.node.getComponent(ColliderComponent); collider.material = newPmtl; Because of the design of Material Sharing, you can actually do this directly in the code (because an instance will be created when you get material) collider.material.friction = 0.1; collider.material.restitution = 0.1; Continue to the rigid body component documentation. "},"physics/physics-rigidbody.html":{"url":"physics/physics-rigidbody.html","title":"Rigid Body","keywords":"","body":"Rigid Body Components Obtaining a RigidBodyComponent An example using TypeScript: const rigidBody = this.getComponent(RigidBodyComponent); Rigid Body Types Rigid bodies are generally divided into three types, static, dynamic, and kinematic. static, which means a static rigid body, like a stone with a huge mass, specifically a mass with a mass of 0, or only physical elements with collision components. dynamic, which means that a dynamic rigid body can be subjected to forces, specifically those with a mass greater than 0 and isKinematic being false. kinematic, which means kinematic rigid body, the user controls the movement of the rigid body, specifically the mass is greater than 0 and isKinematic is true. Center Of Mass Currently the center of mass is fixed to the node to which the rigid body component is bound, and the center of mass is relative to the collider shape. By adjusting the collider shape offset (center), the center of mass can be shifted in shape. Note: In order to make it easier to fit collider shape to the model, methods for changing mass centers may be added in the future, as well as methods for dynamically calculating mass centers mechanism. Sleeping And Waking a Rigid Body An example using TypeScript: if (rigidBody.isAwake) { rigidBody.sleep(); } if (rigidBody.isSleeping) { rigidBody.wakeUp(); } Allowing The Rigid Body To Move To move a rigid body, you need to change the speed of the rigid body. Currently, there are several ways to change the speed of the rigid body: By Gravity The rigid body component provides the useGravity property, set it to true and the rigid body will be affected by gravity. By Applying Force The rigid body component provides an applyForce interface with the signature: applyForce (force: Vec3, relativePoint?: Vec3). According to Newton's second law F = m * a, a force is applied to a certain point of the rigid body, so that there is acceleration, and the speed will change with the acceleration with time, which will cause the rigid body to move. Example: rigidBody.applyForce(new Vec3(200, 0, 0));` By Applying Torsional Force The rigid body component provides the applyTorque interface with the signature: applyTorque (torque: Vec3). Through this interface, you can apply torque to the rigid body, because it only affects the rotation axis, so no longer need to specify the point of action. By Applying Impulse The rigid body component provides the applyImpulse interface, with the signature: applyImpulse (impulse: Vec3, relativePoint?: Vec3). According to the equation of conservation of momentum F * Δt = m * Δv, impulse is applied to a certain point of the rigid body. Since the mass of the object is constant, the speed will change immediately and the rigid body will move. Example: rigidBody.applyImpulse(new Vec3(5, 0, 0));` By Directly Changing The Speed Linear speed The rigid body component provides the setLinearVelocity interface, which can be used to change the linear velocity. The signature is: setLinearVelocity (value: Vec3). Spinning speed The rigid body component provides the setAngularVelocity interface, which can be used to change the rotation speed. The signature is: setAngularVelocity (value: Vec3). An example using TypeScript: rigidBody.setLinearVelocity(new Vec3(5, 0, 0)); rigidBody.setAngularVelocity(new Vec3(5, 0, 0)); Limit Movement Of Rigid Body By Sleeping When sleeping the rigid body, all the force and speed of the rigid body will be emptied, which will stop the rigid body. Note: Currently application of force or impulse, and changing the speed will wake up the rigid body again, and subsequent adjustments may be made, please pay attention to the version update announcement. By Damping The rigid body component provides linearDamping and angularDamping properties, which are used to set linear and rotational damping, respectively. The damping parameter can range from 0 to infinity, 0 means no damping, and infinite means full damping. By Fixed Rotation The rigid body component provides the fixedRotation property. The default is false. Setting it to true can be used to fix the rigid body so that it does not rotate. By Factor The rigid body component provides the linearFactor and angularFactor properties, which are used to set the linear and rotation factors, respectively. The factor is the type of Vec3. The value of the corresponding component is used to scale the speed change of the corresponding axis. The default value is 1, which means that the scaling is 1 times, that is, no effect. Note: Set a certain component value of the factor to 0, you can fix a certain axis of movement or rotation, if you want to completely fix the rotation, please use fixedRotation. Continue to the physics event documentation. "},"physics/physics-event.html":{"url":"physics/physics-event.html","title":"Physics Events","keywords":"","body":"Physics Events The physics event system in Cocos Creator 3D includes trigger events and collision events. Triggers And Colliders When colliding, the collider will produce physical a behavior, however the trigger will not. Therefore, the trigger is a collider that only performs collision detection. The collider is a collider that performs both collision detection and physical simulation. The difference between them: Triggers will not perform more detailed detection with other triggers or colliders. Colliders will do more detailed detection with other colliders and will generate collision data, such as collision points, normals, etc. Note: the isTrigger property determines whether the Collider component is a trigger or not. Trigger Events And Collision Events Trigger Events Trigger events are generated by triggers, which are currently divided into three types onTriggerEnter, onTriggerStay, and onTriggerExit. These represent the trigger start, trigger stay, and trigger end events. In order to add listeners to the trigger event, you need to add the corresponding callback by registering the event: Get ColliderComponent through this.getComponent(ColliderComponent) Register the callback of the corresponding event through the on or once method of ColliderComponent Code example: public start () { let Collider = this.getComponent(ColliderComponent); Collider.on('onTriggerStay', this.onTrigger, this); } private onTrigger (event: ITriggerEvent) { console.log(event.type, event); } Collision Events Collision events are generated based on collision data. Collision data only affects dynamic rigid bodies. Therefore, a dynamic rigid body is required to generate collision events. Collision events are divided into three types: onCollisionEnter, onCollisionStay, and onCollisionExit, which respectively represent the start of the collision, collision hold, and the end of the collision. In order to add a listener to the collision event, you need to add the corresponding callback by registering the event: Get ColliderComponent through this.getComponent(ColliderComponent) Register the callback of the corresponding event through the on or once method of ColliderComponent Code example: public start () { let Collider = this.getComponent(ColliderComponent); Collider.on('onCollisionStay', this.onCollision, this); } private onCollision (event: ICollisionEvent) { console.log(event.type, event); } Note: ColliderComponent is the parent class of all collision components. Note: Collision events are in physical elements, and all collider components on this element will receive collision events. The difference between them: Trigger events are generated by triggers, and collision events are generated based on collision data. The trigger event can be generated by the trigger with another trigger or another collider. Collision events need to be generated by two colliders and at least one dynamic rigid body. Continue to the Group and Mask documentation. "},"physics/physics-group-mask.html":{"url":"physics/physics-group-mask.html","title":"Group Masks","keywords":"","body":"Groups And Masks In Cocos Creator 3D, some physics components (there are currently rigid body components and collider components) provide interfaces for Groups and Masks. How does it work? Physics elements and nodes are currently in a one-to-one relationship. The group and mask belong to the physics elements. The physics components on a single node modify the group and mask of the physics elements corresponding to the nodes. As long as the following conditions are true, it will be detected (GroupA & MaskB) && (GroupB & MaskA) For example: two physical elements A and B. The group value of A is 1 and the mask value is 3 The group value of B is 2, and the mask value is 2 The formula (1 & 2) && (2 & 3) is false, so here A will not be detected with B. Here according to the mask value of B is 2, we can know that the detectable group of B is 1, and the group of A is 0, so it is not detected. Note: The expression depends on bit operation, the bit operation of javascript is limited to 32 bits, and the last bit is the sign bit. To avoid exceeding the operation range, it is recommended that the range of the group is [0, 31 ). Groups Setting a Group Value The following group value is 3, and the binary value is 11, which means it is in the 0, 1 group (starting from 0) const group = (1 Obtaining a Group Value Use getGroup(). Collider.getGroup(); Adding a Group Based on the above code, after the following code, the grouping value is 7, and the binary value is 111, so it means that it is in the 0, 1, and 2 groups. const group = 1 Removing a Group Based on the above code, after the following code, the grouping value is 3, so in the 0, 1 group. const group = 1 Note: It is recommended to fix in a group, you can use the node's layer property as a group. Note: The receiving parameters of the above methods are all decimal numbers. For easy understanding, binary explanation is used here. Developers can also directly input decimal numbers for group operation after they are familiar**. Masks Setting a Mask Value The value of the following mask is 3, the binary value is 11, indicating that the detectable group is 0, 1. const mask = (1 Obtaining a Mask Value Use getMask() console.log(Collider.getMask()); Adding a Mask On the basis of the above code, after the following code, a detectable group 3 was added. const mask = 1 Removing a Mask The following code removes a detectable group 3. const mask = 1 Note: The addition and subtraction operation have higher priority than the shift operation. Note: Flexible use of group and mask can reduce the cost of additional detecting. Note: The group and mask of the physics system may continue to use the Layer property of Node and provide a setting panel, please pay attention to the update announcement. Examples Here is a simple example of usage: Defining a Group Method 1: Defined in an object export const PHY_GROUP = { Group0: 1 Method 2: Defined in an enum (typescript only) enum PHY_GROUP { Group0 = 1 Note: You can consider to reuse the preset layers in Layer. In order to be able to set up groups on the panel, you need to register the defined groups to the editor Enum(PHY_GROUP) through the Enum function exported by the cc module. Note: For historical reasons, the Enum function has special treatment for -1. If you are not familiar with it, do not define an attribute with a value of -1. Using a Mask The mask can be defined according to grouping, for example: Define a mask(const maskForGroup1 = PHY_GROUP.Group1;) that only detects Group1 Define a mask(const maskForGroup01 = PHY_GROUP.Group0 + PHY_GROUP.Group1;) that can detect Group0 and Group1 Define a mask(const maskForNone = 0;) that is not detected by all groups Define a mask(const maskForAll = -1;) for all groups to detect View Binary By executing (value >>> 0).toString(2) in the running environment of JavaScript, you can see the binary string representation. Continue to the Raycast detection documentation. "},"physics/physics-raycast.html":{"url":"physics/physics-raycast.html","title":"Raycast","keywords":"","body":"Raycast Detection Raycast detection is a very important function and is often used to judge various situations. The essence is to make a intersection judgment between a ray and another shape, as shown in the figure below. Constructing a Ray The ray is under the geometry namespace of the cc module, so in order to access to ray, we need to import geometry: import { geometry } from \"cc\"; The ray is composed of start point and direction. There are the following common methods to construct a ray: Via start point++direction, such as ray constructor or static interface create: import { geometry } from \"cc\"; const { ray } = geometry; // Construct a ray starting from (0, -1, 0) and pointing to the Y axis // The first three parameters are the starting point, the last three parameters are the direction const outRay = new ray(0, -1, 0, 0, 1, 0); // Or through the static method create const outRay2 = ray.create(0, -1, 0, 0, 1, 0); Via start point +another point on the ray, for example the static interface fromPoints in the ray: import { geometry, Vec3 } from \"cc\"; // Construct a ray starting from the origin and pointing to the Z axis const outRay = new geometry.ray(); geometry.ray.fromPoints(outRay, Vec3.ZERO, Vec3.UNIT_Z); Use the camera to construct a ray emitted from the origin of the camera to a point on the screen (or the near plane of the camera): Note: First you need to get a reference to a camera component or camera instance. Note: The order of the interface parameters exposed by both the camera component and the camera instance is not the same. import { geometry, CameraComponent } from \"cc\"; const { ray } = geometry; // It is assumed here that there is already a reference to cameraCom const cameraCom: CameraComponent; const cameraCom: CameraComponent; // Get a ray emitted by the screen coordinates (0, 0) const outRay = new ray(); cameraCom.screenPointToRay(0, 0, outRay); Interface Introduction Cocos Creator 3D provides a set of ray detection functions based on the physics engine in the v1.0.1 version. However, it should be noted that the detected object is a physics collider, and the corresponding collider component on the inspector panel, such as BoxColliderComponent. Currently, the interface is provided by PhysicsSystem, which has the following two categories: raycastAll : Detect all colliders and return a Boolean value to indicate whether the detection was successful. raycastClosest : Detect all colliders and return Boolean value as well. Parameter explanation: worldRay : Rays in world space mask : Mask for filtering, you can pass in the packets to be detected maxDistance : Maximum detection distance, please do not pass Infinity or Number.MAX_VALUE queryTrigger : Whether to detect triggers Getting Results To get the detection results of the above interfaces, you need to use the following methods separately: Get the detection results of raycastAll: PhysicsSystem.instance.raycastResults Get the detection result of raycastClosest: PhysicsSystem.instance.raycastClosestResult Note: The returned object is read-only and reused, and the corresponding result will be updated after each call to the detection interface. Information Stored By Results The information is stored by PhysicsRayResult, which mainly has the following information: collider : Collider that is hit distance : The distance between the hit point and the starting point of the ray hitPoint : hit point (in world coordinate system) hitNormal :The normal of the hit point's face (in the world coordinate system) (supported in v1.1 version, currently there is no such information in builtin) Related test cases can be found here. Return to the using physics documentation. "},"ui-system/components/engine/":{"url":"ui-system/components/engine/","title":"UI","keywords":"","body":"UI Architecture The UI uses a tree-based rendering structure, and the entire UI is rendered based on the Canvas node (a node with CanvasComponent) as the root node. That is, the final root node of the UI node must be the Canvas node before it can be rendered by the Canvas. The UITransformComponent is the necessary condition that each UI node must have for a click or alignment strategy, etc. to take effect. In terms of overall rendering, the UI uses a separate render pipeline with the highest priority, the entire render pipeline will rendering 3D part before rendering the UI. And then the UI determines the rendering order by the priority property on the CanvasComponent of the Canvas node. The UI also supports model rendering, the only condition being that a node with the model components (such as ModelComponent/SkinningModelComponent) must add UI/Model component before it can be rendered on the same pipeline as the UI. The UI rendering process as follows: Get Started with UI The UI is a necessary interaction part of game development. The buttons, labels, backgrounds and so on in the game are usually made through the UI. When you start making a UI, the first thing you need to confirm is the size of the display area (Design resolution) of the current design, which can be set in the Project -> Project Setting -> General panel of the menu bar: Now that your design resolution is setup, you can start creating the UI elements. All UI elements are contained under the Canvas node, you can create a Canvas node by clicking the + button at the top left of the Hierarchy panel, and then select the UI -> Canvas. There is a CanvasComponent on the Canvas node, which automatically creates a camera inside. You can achieve true interspersed rendering between 3D camera and 2D camera by adjusting the RenderMode property on CanvasComponent. And then adjust the display priority between multiple Canvas with the priority property on CanvasComponent. Note: There can be more than one Canvas node in a scene, but the Canvas should not be nested under another Canvas or its child nodes. Note: Changes to the x property will take effect at runtime, and the editor still displays the rendered content in the order of the Canvas nodes Note: The change to the priority property takes effect at runtime, and the editor still displays the rendered content in the order of the Canvas nodes After introducing the key contents of the UI, you can then create the UI nodes under the Canvas nodes according to the project structure. There are several UI nodes that come with the editor by default: You can view UI components by checking the node and then clicking on the Add Component in the Inspector panel. The components in UI -> Render belong to the UI renderer component and the others are UI functional components. The UI renderer component uses Breadth-First Sorting scheme, that is, the order of child nodes under the Canvas already determines the subsequent Rendering Order, but you can modify the rendering order with priority property of the renderer component. For nodes without renderer component, you can add a component with only sorting function to sort by selecting Add Component -> UI -> Reorder in the Inspector panel. In general game development, the necessary UI elements are usually Sprite, Label, Mask, Layout, Widget, etc. Sprite and Label are used for rendering image and text. Mask is mainly used to limit the display content, some commonly used places are chat boxes and backpacks, and so on. Layout is mainly used for layout, generally used for single arrangement of buttons, neat arrangement of props in backpacks, etc. The last more important is the Widget, which is mainly used for display alignment. This may involve the multi-resolution adaptation function. When we design the UI and publish it to different platforms, the actual device resolution of the platform will inevitably be different from our design resolution. In order to adapt, we need to do Some trade-offs. For example, the headshot frame cannot be scaled, but we also hope that it will not be greatly affected by the device. Then you can add a Widget component and always ensure that it is aligned at the upper left of our design resolution. Please refer to the Widget Alignment and Widget Component documentation for details. When our interface is finished, you may find out how the display effects of iPhone7 and iPhoneX are different. This is actually a problem with the device resolution we mentioned above. When you design at the design resolution and publish at the device resolution, because the design resolution of different mobile phones may be different, the problem of pixel deviation may occur. Therefore, you also need to do screen adaptation. As you can see on the Project -> Project Setting -> General -> Default canvas setting page of the menu bar, there are two other options, Fit Width and Fit Height. According to the screen adaptation rules provided by Cocos Creator 3D, and combined with the Widget component, you can easily adapt to different devices. Please refer to the Multi-Resolution Adaptation documentation for details. UI Rules Introduction Rendering Order Multi-Resolution Adaption Widget Alignment Label Layout Auto Layout Container List with data Stretchable UI Sprite UI Static Batching "},"ui-system/components/engine/priority.html":{"url":"ui-system/components/engine/priority.html","title":"Rendering Order","keywords":"","body":"Rendering Order 1. UI node ordering The rendering order of the UI uses the Breadth-First Sorting scheme, and each rendered component (i.e SpriteComponent) has a priority property. Sorting starts from the child nodes under the root node, and determines the overall rendering structure according to the priority of the child nodes, that is, the rendering order of the child nodes under the root node has determined the final rendering order. The priority property of all child nodes under each node is used to determine the rendering order under the current node. For example: It can be seen from the figure that although some nodes have no renderer components, their children can participate in sorting, so these nodes also need to participate in sorting. The overall rendering order is B -> b1 -> C -> A -> a1 -> a2, and the rendering state on the screen is a2 -> a1 -> A -> C -> b1 -> B. Since we will eventually sort the nodes based on the priority, the order of the nodes that are ultimately presented to you is the final rendering order. For nodes that don't have a renderer component but also need to be sorted, you can use the UIReorderComponent. 2. Mixed camera sorting The UI camera has the highest priority when it was originally designed, that is, the UI camera content is only drawn after all 3D content is drawn. However, this will cause a problem. Once the UI camera has a background or large icon, it will block the 3D content. Therefore, a mixed sorting function between cameras is essential. The key factor of the mixed sorting of the UI camera and the 3D camera is here in the UI camera. Therefore, the CanvasComponent on the root node of the UI, which is the Canvas node, provides a property called RenderMode to distinguish the sorting method.Next, talk about the role of the RenderMode option: When the selection mode is OVERLAY, it means that the UI camera will always be behind the 3D camera, which means will always cover the rendering content of the 3D camera. Multiple UI cameras select this mode, and you can use the attribute Priority to sort between UI cameras. When the selection mode is INTERSPERSE, it is possible to mix and sort with the 3D camera. The sorting method between UI camera and the 3D camera is done by setting Priority on the CanvasComponent. Detailed Explanation Sorting is a very simple function, but the final rendering is based on the rendering capabilities provided by different platforms. Therefore, explain here. If you encounter an error in UI rendering, such as flickering or unwanted artifacts or other please consider the following. The first thing to check is the ClearFlag of all cameras (CameraComponent and CanvasComponent) in the scene, and make sure that the lowest Canvas or Camera's ClearFlag property is set to SOLID_COLOR in each scene. To set the ClearFlag property, please refer to the following situations: If there is only one 2D Canvas or 3D Camera in the scene, then the ClearFlag property is set to Solid_Color. If the scene contains 2D background layer, 3D scene layer, 2D UI layer, then: 2D background layer: ClearFlag property is set to Solid_Color. 3D scene layer: ClearFlag property is set to Depth_Only. 2D UI layer: If the model is included, the ClearFlag property is set to Depth_Only to avoid a model splash screen. If no model is present, the ClearFlag property can be set to Dont_Clear/Depth_Only. "},"ui-system/components/engine/ui-batch.html":{"url":"ui-system/components/engine/ui-batch.html","title":"UI Batch","keywords":"","body":"UI Batch Rules UI batching adopts the same hash material and same image principle for batching. The same hash means that even if the same material is used, if their hash values ​​are different, the batch will be interrupted. For example, the macros enabled by the two materials involve the use of Uniform, resulting in failure to batch. Sprite and text are the same because their images are different. Of course, it can be done under strict control, but this is another story. UI rendering data collection is based on the Hierarchy, so in the process of recursive Hierarchy, if you encounter the three components UIModelComponent, MaskComponent and GraphaicsComponent, it will definitely interrupt the batch. If the images used before and after are different, the batch will be interrupted. Therefore, we recommend that the images of different modules be batched separately to reduce DrawCall. However, if you want to batch a large amount of data, you need to strictly layout the nodes. "},"ui-system/components/engine/multi-resolution.html":{"url":"ui-system/components/engine/multi-resolution.html","title":"Multi-Resolution Adaption","keywords":"","body":"Auto fit for multi-resolution In the overall design of Cocos Creator 3D, it follows Cocos Creator's solution about adapting to screens with various resolutions with one set of assets. Generally speaking, we realize the adaptation scheme for multi-resolution through the following technology: Canvas component immediately obtains the actual resolution of the device screen and appropriately adjusts the size of all the render elements in the scene. Widget is put on rendering elements, which can align the element with different referential positions of the parent node according to different needs. Label component has a built-in function that provides various dynamic layout modes. When the bounding box of labels change because of the alignment requirement of the Widget, labels will present the perfect layout effect according to your needs. Sliced Sprite provides images whose size can be arbitrarily designated. Simultaneously, it can meet various alignment requirements and display images with high definition on screens of any resolution. Next, start off by getting to know the concepts of design resolution and screen resolution, then we will go on to learn the zooming in/out function of the Canvas component. Design resolution and screen resolution Design resolution is the resolution sample used by content creators when creating the scene. But screen resolution is the actual resolution of the device that the game is running on. Normally, design resolution will use the screen resolution of the device that is being used the most by the targeted group on the market, such as: screen resolutions of 800x480 and 1280x720 that are being used by Android devices currently, or screen resolutions of 1136x640 and 960x640 that are being used by iOS devices. Therefore, after designers or directors set up the scene by using design resolution, the game will automatically adapt to the device used by the major targeted group. Then when the design resolution is different from the screen resolution, how could Cocos Creator 3D adapt to the device? Supposing the design resolution is 800x480, designers will create a background image of the same resolution. When design resolution and screen resolution have the same aspect ratio When design resolution and screen resolution have the same aspect ratio, supposing the screen resolution is 1600x960, enlarging the background image to 1600/800 = 2 times will perfectly fit the screen. This is the simplest situation, which will not be discussed in detail here. When the aspect ratio of design resolution is larger than that of screen resolution, the height should be adjusted to avoid black borders Supposing the screen resolution is 1024x768, a red frame is used in the following picture to indicate the visible area of the device screen. We use Fit Height mode provided by the Canvas component to make the height of the design resolution automatically cover the height of the screen, i.e., enlarging the scene image to 768/480 = 1.6 times. This is a fairly good adaptation mode when the aspect ratio of the design resolution is larger than that of the screen resolution. As illustrated above, although some parts of the background image will be cut down on the two sides of the screen, it can be ensured that no goof or black borders will appear in the visible area of the screen. Then the position of UI elements can be adjusted by the Widget, which makes sure that the UI elements will appear in the visible area of the screen. We will introduce this in detail in the next section Widget Align. When the aspect ratio of the design resolution is larger than that of the screen resolution, the width should be adjusted to avoid black borders Supposing the screen resolution is 1920x960, a red frame is also used in the following picture to indicate the visible area of the device screen. We use Fit Width mode provided by the Canvas component to make the width of the design resolution automatically cover the width of the screen, i.e., enlarging the scene to 1920/800 = 2.4 times When the aspect ratio of the design resolution is relatively small, the use of this mode will cut down some parts of the background image on the upper/lower sides of the screen. No matter how much the aspect ratio of the screen is, all the contents of design resolution will be completely displayed, and black borders are permitted. In the last example, supposing the screen has a resolution of 640 x 960. If you want to make sure the background image is completely displayed on the screen, you need to simultaneously open Fit Height and Fit Width in the Canvas component. The zooming in/out proportion of the scene image is calculated according to the smaller dimension in the screen resolution. In the example in the following picture, because the aspect ratio of the screen is less than 1, the zoom ratio will be calculated based on the width, that is, 640/800 = 0.8 times. Under such a displaying mode, there might be black borders on the screen or scene image that exceed the design resolution (goof). Although developers try their best to avoid black borders in general, if you want to make sure all the contents within the scale of design resolution are displayed on the screen, you can use this mode too. According to the screen aspect ratio, 'Fit Width' or 'Fit Height' will be automatically selected If there is no strict requirement for the content that may be cropped down on the four sides of the screen, you can not enabled any adaptation mode in the Canvas component. At this time, Fit Width or Fix Height will be automatically selected according to the screen aspect ratio to avoid black border. In other words, when the aspect ratio of the design resolution is greater than the screen resolution, Fit Height will be automatically opened (as in the first picture above); when the aspect ratio of the design resolution is less than the screen resolution, Fit Width will be automatically opened (as in the second picture above). Canvas component doesn't provide a fit mode that can respectively zoom in/out of the x axis and the y axis, which will distort the image In the Cocos engine, there is a fit mode called ExactFit, which doesn't have black borders, or cut down the image within the scale of design resolution. But the price is the zooming in/out ratio of the scene image to the direction of the x/y axis is different, which will distort the image. Design resolution can only be configured in the project settings The current design mode does not include a multi-resolution adaptation method, so the design resolution of multiple Canvas in the project still uses the same set of design resolution and adaptation scheme, and you can configure it in Project -> Project Setting -> General -> Default canvas setting. "},"ui-system/components/engine/widget-align.html":{"url":"ui-system/components/engine/widget-align.html","title":"Widget Alignment","keywords":"","body":"Alignment Strategy To achieve a perfect multi-resolution fit effect, presenting UI elements according to the positions stipulated in the design resolution is not enough. When the width and height of the screen change, UI elements must be able to intelligently sense the positions of the borders of the screen to make sure that they are presenting themselves in the visible area of the screen and being distributed in suitable positions. We can do this with the Widget component. Next, we categorize different alignment workflows according to the categories of elements that need to be aligned: Aligning Buttons and Small Elements with the Border For elements with relatively small areas like a pause menu, in-game gold coins, etc., normally, aligning them by the borders of the screen would be enough. Only a few simple steps are needed: Set these elements as child nodes of the Canvas node in Hierarchy Add the Widget component to element nodes To align something with the bottom left corner of the screen for example, check the Left and Bottom tick boxes in the Widget component. Then set up the distance between the node and the borders of the screen. In the picture below, the left margin is set as 40px, the bottom margin is set as 30px. After setting up the Widget component like this, no matter what the actual screen resolution is, this node element will remain at the bottom left corner of the screen. The distance between the left side of the node's bounding box and left border of the screen remains at 40px. The distance between the bottom of the node's bounding box and the bottom of the screen remains at 30px. Note: The alignment distance provided by the Widget component refers to the border of the bounding box that is located in the same direction as the child node and parent node. For example, Left is ticked on in the above example to align the element with the left border, then the distance between the left border of the child node's bounding box and the left border of the parent node's (i.e., Canvas node, whose bounding box is constantly the same size as the screen) bounding box is the set value 40px. Nest Alignment Elements We just showed how to align something with the border of the screen in the example above. Because the default alignment reference of Widget is the parent node, we can add different node hierarchies and make the nodes on every hierarchy use the auto alignment function. Here is a simple example to explain it. Suppose we have a node hierarchy as follows: In the example above, parent is a panel, and button is a button. We can add Widget component to both of these nodes, and respectively set their alignment distance. For the parent node, the distance of aligning the top left corner of the Canvas node remains at 80px: For the button node, the distance of aligning the top left corner of the parent node remains at 50px: With a workflow like this, we can group UI elements according to their display areas or functions, and elements of a different hierarchy can be aligned according to design. Automatically zooming in/out the size of a node according to alignment requirements In the above example, two borders that simultaneously align on one axis in opposite directions don't exist. If we want to make a panel that fully covers the width of the whole screen, we can simultaneously tick off the alignment switches Left and Right: When simultaneously ticking off the alignment switches in opposite directions, Widget obtains the ability of modifying the Size of the node according to alignment requirements. In the picture above, we ticked off the left and right directions and set up margins, then Widget can dynamically set up the Width property of the node according to the width of the parent node. As a result, no matter how wide the screen is, the distance between the panel and the left & right borders of the screen remains at 100px permanently. Create a node whose size is in accordance with the size of screen Making use of the features of a node that can automatically zoom in/out, we can make the size of the node the same with that of the screen by setting up the Widget component of the node. Therefore, we don't have to put all the UI elements that need to align with the borders of screen under the Canvas node, but group them according to the requirements of function and logic. To make such a node, we should first make sure that the size of the parent node of this node remains the same with that of the screen. The Canvas node is the best choice. Next, set up the Widget component of this node according to the following method: Therefore the size of the node will remain constantly the same with that of the Canvas node when running, i.e., the same as the size of the screen. After being set up like this, the child node of this node can transmit the same screen size by the same settings. What needs to be noted is that because the Canvas node itself has the function of remaining the same size as that of the screen, there is no need to add the Widget component to the Canvas node. Set up percentage alignment distance After the alignment in a certain direction is enabled on the Widget component, in addition to specifying the margin in pixels, we can also input a percentage value (For example: by clicking the symbol circled in the box), therefore, Widget will multiply the width or height of the parent node on the corresponding axis by the input percentage to get the value of the actual margin. Let's take a look at a real example. Take a child node that has been directly put under Canvas as an example. We hope this node panel remains on the right side of the screen and constantly covers 60% of the total height of screen. Therefore, setting up the Widget component according to the following picture will realize this effect: When inputting the margin value when opening alignment direction, Widget can use the pixel unit together with percentage unit according to various needs. For example, input 50% on the Left direction that needs to align with the center line of the screen and input 20px on the Right direction that needs to align with the borders of the screen; when calculating the position and size of the child node at last, all the margins will be positioned after being converted to pixcel distance according to the size of the parent node. Making use of the percentage alignment distance, we can create UI elements that can zoom in/out infinitely according to the size of the screen. Exerting your imagination, fitting a thousand types of Android phones with one set of resources will be a piece of cake! Update alignment and optimization strategies for every frame at runtime Widget component is generally used to locate the position of each element when the scene is initialized on the target device, but once the scene is initialized, we often do not need to use the Widget component for alignment. The alignOnce property is used to ensure that the Widget component only performs alignment and positioning at initialization, and no longer consumes time for alignment at runtime. If the alignOnce is selected, and the alignment is performed once when the component is initialized, the engine will automatically set the enabled property of the Widget component to false to disable the automatically update for subsequent every frame to avoid repeated positioning. If you need real-time positioning at runtime, you need to manually disable the alignOnce (set to false). Or when you need to update and align each frame at runtime, manually traverse the Widget that need to be aligned and set their enabled property to true. For scene with many UI elements, ensuring that the alignOnce option of the Widget component is enabled can greatly improve the running performance of the scene. Limitation on the position and size of node When the Widget component enables one or more alignment settings, the position, width and height properties of the node may be restricted and cannot be freely modified through the API or Animation panel. If you need to modify the position or size of the alignment node at runtime, please refer to the Widget Component: Limitation on node position control for details. "},"ui-system/components/engine/label-layout.html":{"url":"ui-system/components/engine/label-layout.html","title":"Label Layout","keywords":"","body":"Label Layout The Label component is one of the key rendering components. You need to learn about how to set up label layout in order to have a perfect display when the UI system adapts to various resolutions and sets up alignment. Alignment of labels in the bounding box Like other renderer components, the layout of the Label component is also based on the size information (contentSize) possessed by the UITransform component, that is, the range specified by the Bounding Box. What is shown in the picture above is the display effect of labels rendered by Label in the blue bounding box. The following properties in Label determines the position of labels in the bounding box: Horizontal Align: the horizontal alignment of labels in the bounding box, which can be chosen from 3 positions: Left, Right, Center. Vertical Align: the vertical alignment of labels in the bounding box, which can be chosen from 3 positions: Top, Bottom, Center. In the figure above, the horizontal alignment position is set to Right, and the vertical alignment position is set to Bottom. It can be seen that the label appears at the bottom of the Bounding Box and is aligned to the right. The developer can modify the two properties above to make other combinations, labels will appear on the corresponding position of the blue bounding box according to the settings. Label Size and Line Height Font Size determines the display size of labels. Its unit is Point (it can also be called 'pound'), which is the size unit for fonts commonly used in most image editing softwares and font editing softwares. For dynamic fonts, Font Size can be zoomed in losslessly. But the display of bitmap fonts will be more and more vague when the set value of Font Size exceeds the font size stipulated by the font. Line Height determines the height occupied by each line when multiple lines of labels display, the unit of which is also Point. The displaying of multiple lines of labels can be carried out by using two methods: When inputting labels in the String property, manually input \\r or \\n Open the Enable Wrap Text property, which will be introduced in detail later Relation of label size and line height: If the values of Font Size and Line Height are the same, labels will occupy the height of the most part of one line. If the value of Font Size is less than that of Line Height, space between multiple lines of labels will be enlarged If the value of Font Size is larger than that of Line Height, space between multiple lines of labels will be narrowed between multiple lines of labels. Overlapping of labels may appear. Overflow The Overflow property determines the array of labels in the bounding box when the content of labels is increased. There are four modes: NONE, CLAMP, SHRINK, and RESIZE_HEIGHT. Only in the latter three modes can the size of the bounding box be adjusted through the Rectangle Transform Tool in the upper left corner of the editor or modifying the Size size in the Inspector panel or add the Widget component. NONE mode will automatically fix the size of the bounding box according to the text size, line height, etc. Clamp When in Clamp mode, labels will firstly be rendered according to the requirements of alignment type and size, but the parts exceeding the bounding box will be concealed (clamped). Auto Shrink When in auto shrink mode, if labels exceed the bounding box when being rendered according to the original size, the size of the labels will be automatically shrunk to display all the labels. Attention! Auto shrink mode will not zoom in on labels to adapt to bounding box. Resize Height Resize height mode will make sure the bounding box of the labels fits the height of the labels, no matter the quantity of the labels' lines. This mode is suitable for displaying paragraphs of labels that don't have the same amount of content. An infinite amount of label content can be displayed in the arbitrary UI field when using this mode together with the ScrollView component. Enable Wrap Text The Enable Wrap Text property of the Label component can switch the auto wrap switch of labels. When Enable Wrap Text is opened, labels will automatically wrap acccording to the width of the bounding box without manual input of \\r or \\n when inputting labels. Note: The Enable Wrap Text property is only available in the CLAMP and SHRINK modes of the label layout mode. In RESIZE_HEIGHT mode, the Enable Wrap Text property is compulsorily opened. Auto Wrap in Clamp Mode When clamp mode opens auto wrap, labels will be wrapped in the allowable scale of the bounding box in priority. Only when not all the words can be displayed after being wrapped will clamp mode function. The following two pictures are taken when Clamp + Enable Wrap Text are opened, the difference of which is the different width of the bounding boxes of the labels; When the width of the bounding box is changing from the left picture to the right picture, labels will be continuously adjusted and wrapped. In the end, the clamped display will appear due to the insufficient height of the bounding box. Auto Wrap in Auto shrink mode Similar to clamp mode, labels will be wrapped in priority when labels exceed the width of the bounding box in auto shrink mode. Only when the width and length of the bounding box are exceeded will the labels be automatically shrunk to adapt to the bounding box. Enable Wrap Text of Chinese The auto wrap behavior of Chinese is different from that of English. English is wrapped by the unit of words. Blank space is the smallest unit of wrap adjustment. Chinese is wrapped by the unit of characters. Every character can be wrapped alone. Anchor point of label node The anchor point of a label node and the alignment mode of labels in the bounding box are two concepts that need to be differentiated. In a layout type that needs labels to enlarge the bounding box (e.g., Resize Height), only correct setting up of anchor points can make the bounding box be extended to the expected direction. For example, if you want the bounding box to extend downward, you need to set the y property of Anchor as 1. As shown below: Widget Add a Widget component to the node with the Label component, then you can make various layouts for label nodes relative to their parent nodes. In the above picture, two Label child nodes are added to the background node. After respectively adding the Widget component to them, set the Right property of the Widget for the labels on the left side as 50%, and set the Left property of the Widget for the labels on the right side as 60%, then the multi-column layout of labels in the picture above can be realized. And by setting margins on the Widget, plus the layout type of labels, a flexible and beautiful layout for labels can be easily realized without concrete and minor adjustments to the bounding box. Reference for checking components For properties of the Label component, you can also check Label Component document. "},"ui-system/components/engine/auto-layout.html":{"url":"ui-system/components/engine/auto-layout.html","title":"Auto Layout Container","keywords":"","body":"Auto Layout Container The layout component can be mounted to any node, making the node into a container with the auto layout function. The so-called auto layout container can automatically array the child nodes according to certain rules and adjust the container type nodes of its own size according to the sum total of bounding boxes of the node content. Layout Type Auto layout components have several basic layout types. These can be set up by the Layout Type property, which includes the following types. Horizontal Layout When Layout Type is set as Horizontal, all the child nodes will automatically be arrayed horizontally, and the width of the Layout node will be set up according to the sum Width of the child nodes. Then the two Label nodes included in the picture above will automatically be arrayed horizontally. In the horizontal layout type, the Layout component will not interfere with the position or height properties of the node on the y axis. The subnode can even be put outside the maximal height of the layout node's bounding box. If child nodes need to be aligned upward along the y axis, you can add the Widget component to the child nodes and open the alignment mode of the Top or Bottom. Vertical Layout When Layout Type is set as Vertical, all the child nodes will automatically be arrayed vertically and the height of the Layout node will be set up according to the sum Height of the child nodes. In the vertical layout type, the Layout component will not modify the position or width properties of the node on the x axis. Child nodes can only be neatly arrayed by adding the Widget and opening the Left or Right alignment mode. Node Direction The Layout arrays' child nodes are based on the display order of child nodes in Hierarchy and refers to the array directions set up by the Vertical Direction or Horizontal Direction properties. Horizontal Direction You can set up two directions: Left to Right or Right to Left. The former will array the nodes from left to right according to their display order in Hierarchy; the later will array the nodes from right to left according to their display order in Hierarchy. Vertical Direction You can set up two directions: Top to Bottom or Bottom to Top. The former will array the nodes from top to bottom according to their display order in Hierarchy; the later will array the nodes from bottom to top according to their display order in Hierarchy. Other layout types are coming soon We will update this part of the document in later edition. For the properties of other Layout components, please check Layout document. "},"ui-system/components/engine/list-with-data.html":{"url":"ui-system/components/engine/list-with-data.html","title":"List with data","keywords":"","body":"Create a list of dynamically generated content We can build and edit static UI interfaces with Scene panel easily, but in real world game project it's not enough. We'll need dynamically generated UI elements with data, such as character selection, inventory and level selection. Prepare data Let's take an inventory interface as example, we need following data structure to generate an item dynamically: Item id Icon id, we can put up a icon id to spriteFrame reference dictionary or array Item name Item price We will introduce how to define a data class and generate those data in Inspector panel. If you're not familiar with component system of Cocos Creator 3D, please start with Workflow of script development documentation. Custom data class For most game project, you can get inventory data from game server. For the simplicity let's define a data class for data structure and input. Let's add a new script ItemList.js and add the following properties: @ccclass('Item') export class Item { @property id = 0; @property itemName = ''; @property itemPrice = 0; @property(SpriteFrame) iconSF: SpriteFrame | null = null; } @ccclass export class ItemList extends Component { @property([Item]) items: Item[] = []; @property(Prefab) itemPrefab: Prefab | null = null; onLoad () { for (var i = 0; i We defined an Item class at the top of the script for storing and easily updating data needed by item. Please notice this class does not extends cc.Component, so it can be defined as a property type for any component. Please refer to the Declare class documentation for additional details. After the Item class definition, we defined a component class. Each script file can only contains one component definition and the component name will be the same as the file name. So the component we define is ItemList. In this component we have a list property which type is Item. This way we can populate the list with data input in Inspector panel. Now let's create an empty node and add ItemList component. We can find Items property in Inspector panel. To populate data, let's give the list a length. Type 3 in the field and you can input data like these: We have our data ready for now, you can also type in more data entries as you wish. If you're making a game with lots of data, please consider using more specialized data source like Excel and database. It's easy to convert such data sources to JSON for the engine. Make the view for data: Prefab as template Now move on to the view to visualize data, we can use Prefab to do this job. Let's create a prefab that looks like this: The child nodes icon, name, price will be used to display icon, item name and price from data. Data binding You can freely customize the prefab as you need, the picture above only shows an example. Now we need a component script to bind the data to the components that show them. Create a new script ItemTemplate.js and add it to the prefab root node. The script contains: @ccclass export class ItemTemplate extends Component { @property public id = 0; @property(SpriteComponent) public icon: SpriteComponent | null = null; @property(LabelComponent) public itemName: LabelComponent | null = null; @property(LabelComponent) public itemPrice: LabelComponent | null = null; } Drag all those nodes onto the property fields of ItemTemplate component. Note: We will assign value for id property through script, no data binding needed. Update template display with script Modify ItemTemplate.js script to add function to update the renderer components with input data. Let's add the following to the end of script: // data: { id, iconSF, itemName, itemPrice } init(data: Item) { this.id = data.id; this.icon.spriteFrame = data.iconSF; this.itemName.string = data.itemName; this.itemPrice.string = data.itemPrice; } init method takes a data object and use the data to update each renderer component on bound nodes. Now we can save Item node as a Prefab asset and use it as the template of our item entries. Instantiate template with data Go back to ItemList.js script, and add reference to our Prefab and then instantiate it with data. //... @property(Prefab) itemPrefab: Prefab | null = null; onLoad () { for (var i = 0; i In the onLoad callback method, we traverse each data stored in items in turn, instantiate itemPrefab to generate a new node and add it to the node where ItemList.js is. Then call the init method in ItemTemplate.js to update its display. Now we can add a Layout component to the node that holds ItemList.js through Add Component -> Add UI Component -> Layout under the Inspector panel, and set the following properties: Type: HORIZONTAL Resize Mode: CONTAINER Don't forget to drag and drop item Prefab to itemPrefab property field of ItemList component. You can also add a Sprite component to the node as the background. All steps have been completed. Now itemList node should look like this: Preview Running preview of the scene will get the result like this (the acutal look depends on how your template was setup and your data): The Layout component added in previous step is not necessary. We can use it to help putting multiple items in a container in order but you can also use the script program to do that. You can also add a ScrollView component together to display a large amount of content in a limited space. For details of layout methods please read the Auto Layout Container and the ScrollView Component documentation. "},"ui-system/components/engine/sliced-sprite.html":{"url":"ui-system/components/engine/sliced-sprite.html","title":"Stretchable UI Sprite","keywords":"","body":"Use a Sliced Sprite to make a UI image The core design principle of the UI system is to automatically adapt to different device screen sizes. When developing the UI, we need to correctly set the each node's size, and which can be automatically stretched and adapted according to the screen size of the device. To achieve this, we usually use 9-sliced format images to render these nodes. In this way, even if small original images can be used to generate background images that can cover the entire screen. On the one hand, the game package is reduced, and on the other hand, it can be flexibly adapted to different layout requirements. The right side of the picture above displays the texture of original size. The left side displays the effect of choosing Sliced mode and enlarging the size property. Setting up your SpriteFrame for 9-slicing To use a 9-sliced image effect that can be infinitely enlarged, we need to cut the image asset into a 9-slicing at first. First open the Sprite Editor, select the image asset in Assets, then click the Edit button on the bottom of Inspector. If the height of your window is not large enough, you might need to scroll Inspector downward to see the button at the bottom. After opening Sprite Editor, you will see there is a green line around the image, which indicates the position of the current 9-sliced split line. Drag the mouse to the split line, you will see the shape of the cursor change, then you can press down and drag the mouse to modify the position of the split line. We click and drag the four split lines at the top, bottom, and sides respectively and cut the image into a 9-slicing. The nine areas will apply different zooming in/out strategies when the Sprite size changes, which is as illustrated below: And the following picture illustrates the state of zooming in/out in different areas (the picture comes from Yannick Loriot's Blog): After cutting, don't forget to click the green check mark on the upper right corner of Sprite Editor to save modifications to the asset. Set the Sprite component to use Sliced mode After you have prepared the 9-sliced asset, you can modify the draw mode of the Sprite and modify the size to make a UI element that can specify any size. First, select the Sprite node in the Scene/Hierarchy, set the Type property of the Sprite as Sliced in the Inspector. Then drag the control point with the Rect Transform Tool to enlarge the size property of the node. You can also modify the size property value directly in the Inspector. Because the image asset has been set to 9-slicing, no matter how much the Sprite zooms in, there will be no vagueness or distortion. Precautions When using tools or directly modifying the size attribute of Sliced ​​Sprite, note that the size property value cannot be negative, otherwise it cannot be displayed normally in Sliced ​​mode. "},"editor/components/":{"url":"editor/components/","title":"Components","keywords":"","body":"Components Cocos Creator 3D includes the following Components： AudioSourceComponent ModelComponent SkinningModelComponent CameraComponent DirectionalLightComponent SphereLightComponent SpotLightComponent AnimationComponent BillboardComponent LineComponent ParticleSystemComponent BoxColliderComponent SphereColliderComponent RigidBodyComponent UI Components Continue to the AudioSourceComponent documentation. "},"engine/renderable/model-component.html":{"url":"engine/renderable/model-component.html","title":"ModelComponent","keywords":"","body":"Model component The ModelComponent is used to display a static 3D model. Set the model grid through a mesh, and change the appearance of the model through material. Properties Functions mesh 3D model assets for rendering. materials The material used to render the model, one material corresponds to one submesh in the mesh. shadowCastingMode Whether the model casts shadows. The planar shadow system in the scene should be enabled beforehand. visibility Used for which camera the model will be rendered, only the camera with the same visibility as the model will render the model. Model group rendering The group rendering function is determined by the Visibility property of the camera component and the Layer property of the node. Users can set the Visibility value through code to complete the group rendering. All nodes belong to the DEFAULT layer by default and are visible on all cameras. Note: Please review the Camera Component documentation for additional information, if required. Static batching The current static batching scheme is static batching at run time. Static batching can be performed by calling BatchingUtility.batchStaticModel. This function receives a node, and then merges all Mesh in ModelComponent under that node into one, and hangs it under another node. After batching, the original transform of ModelComponent cannot be changed, but the transform of the root node after batching can be changed. Only nodes that meet the following conditions can be statically batched: The child node can only contain ModelComponent. The vertex data structure of Mesh of ModelComponent under child nodes must be consistent. The material of ModelComponent under child nodes must be the same. About dynamic batching The engine currently provides two sets of dynamic batching systems, instancing batching and VB-merging batching. The two methods cannot coexist, and the priority of instancing is greater than that of dynamic merging VB. To enable batching, simply check the USE_INSTANCING or USE_BATCHING switch in the material used in the model. Note: Batching can participate in the frustum culling process normally, but transparents model cannot be sorted, which will lead to incorrect blending results. The engine does not explicitly prohibit the approval of transparent objects, and developers can control the trade-offs. Instancing batching The batch through instancing is suitable for drawing a large number of dynamic models with the same vertex data. When enabled, drawing will be grouped according to the material and vertex data, and the instanced attributes information will be organized in each group, and then complete the drawing at one time. Note: For the support and related settings of the skinning model, refer to the Skeletal Animation Component documentation. In addition, inside each group, the instanced attributes supports custom additional instanced attributes, which can pass more per-instance data between different instances (such as the difference in appearance of a diffuse color between different characters, or the influence of wind in a large grass field). This requires the support of custom effects. For more detailed instructions, please refer to the Syntax Guide documentation. VB-merging batching VB-merging batching is suitable for drawing a large number of non-skinned dynamic models with low number of faces and different vertex data. When enabled, drawing will be grouped according to the material, and then the vertex and world transformation information will be merged in each frame of each group, and then completed in batches. 1. Operations such as merging vertices per frame introduce a portion of CPU overhead, which is particularly expensive in JavaScript. In addition, it is necessary to remind that the number of draw calls is not as low as possible. Although, it is important to note, minimizing the number of draw calls to the extreme doesn't necessarily lead to the best (or even good) performance 2. Optimal performance is often the result of CPU and GPU load balancing, so when using batch functions, be sure to do more tests to identify performance bottlenecks and do targeted optimization. Batch best practices Generally speaking, the priority of the batch system is: static batching -> instancing batching -> VB-merging batching. The material must be insured that it is consistent, under this premise: If you are certain that certain models will remain completely static during the game cycle, use static batching. If there are a large number of the same model repeated drawing, there is only a relatively controllable small difference between each other, use instancing batching. If there are a large number of models with very low number of triangles but different vertex data, consider trying VB-merging batching. Note: [1] currently use uniforms to upload the batched world transformation matrix, taking into account the WebGL standard uniform quantity limit, the current batch draws up to 10 models, so for a large number of same For the material model, the number of drawcalls is expected to be reduced by up to 10 times after enabling VB-merging batching. ↩ Note: [2] there have been many discussions in the industry on the topic of batching and performance, you can refer to this nVidia slide. ↩ "},"editor/components/camera-component.html":{"url":"editor/components/camera-component.html","title":"CameraComponent","keywords":"","body":"Camera The Camera in a game is the main tool used to capture Scenes. The visible range of the Camera is controlled by adjusting camera-related parameters. The Camera is represented as follows in the Cocos Creator 3D editor: The Camera's visual range is composed of 6 planes forming a Frustum, a Near Plane, and a Far Plane to control the visible distance and range of near and far distance, at the same time, they also constitute the size of the viewport. Camera components The Camera Component is an important functional component that we use to present a Scene. Parameter Description ClearFlags Camera clear logo. Contains: DONT_CLEAR: not clear; DEPTH_ONLY: only clear the depth; SLOD_COLOR: clear the color, depth and template buffer Color Clear the specified color Depth Clear the specified depth Stencil Clear the specified template buffer Far Far cutting distance Near Near cutting distance Fov Angle of view OrthoHeight The height of the orthogonal Camera Priority Priority. High-priority Cameras will be rendered first in the rendering process Projection Projection mode. Divided into perspective projection (PERSPECTIVE) and orthogonal projection (ORTHO) Rect Viewport size of Camera Visibility The visibility of the Camera. Used to control the visibility of different models in the same Camera. Camera group rendering The Camera's group rendering function works with the Model Component through the Visibility property of the Camera Component. The user can set the Visibility value through code to complete the group rendering. It should be noted that the Visibility value is bitwise comparison, and the user can manipulate the top 20 bits of Visibility through bit operations to complete the grouping. The Camera and models provided by default are all rendered without grouping. You do not need to change this value if the game has no special requirements to do so. "},"particle-system/billboard-component.html":{"url":"particle-system/billboard-component.html","title":"BillboardComponent","keywords":"","body":"Billboard Component The billboard component is used to render a box that always faces the camera. Properties Features height The height of billboard. width The width of billboard. rotation The angle of rotation of the billboard around the center point. texture The texture displayed on the billboard. "},"particle-system/line-component.html":{"url":"particle-system/line-component.html","title":"LineComponent","keywords":"","body":"Line Component The Line component is used to render a line segment connected by a given point in a 3D scene. The line segment rendered by the Line component is wide and always faces the camera, which is similar to the billboard component. Properties Features texture The map displayed in the line segment. worldSpace Which coordinate system is used for the coordinates of each point in the line segment, check Use world coordinate system, and deselect use local coordinate system. positions The coordinates of the end points of each line segment. wdith The width of the line segment, if a curve is used, it means the change of the curve along the direction of the line segment. tile Number of texture tiles. offset The offset of the texture coordinates. color The color of the line segment. If a gradient color is used, it indicates the color gradient along the direction of the line segment. "},"ui-system/components/editor/":{"url":"ui-system/components/editor/","title":"UI Component Reference","keywords":"","body":"Common UI Controls This document describes commonly used control components in the UI system, the core rendering components, and alignment and layout strategy components. These controls will constitute the most interactive part of our game UI. Some commonly used UI controls can be created by adding nodes. In the upper left corner of the Hierarchy, select UI in the + create node menu to create a UI node, and the corresponding UI component will be automatically mounted on the node: For other UI components, you can manually select the node in the Hierarchy, and then click Add Component -> UI in the Inspector to add: Component Catalog UI components are mainly divided into the following two types: UI Renderer Components UI Basic Components "},"ui-system/components/editor/render-component.html":{"url":"ui-system/components/editor/render-component.html","title":"UI Renderer Component","keywords":"","body":"UI Renderer Components Sprite Component Reference Label Component Reference Mask Component Reference Graphics Component Reference RichText Component Reference UIStaticBatch Component Reference "},"ui-system/components/editor/sprite.html":{"url":"ui-system/components/editor/sprite.html","title":"Sprite Reference","keywords":"","body":"Sprite Component Reference Using Sprite is the most common way to display images in 2D/3D games. By adding the Sprite component to a Node, you can display SpriteFrame assets from project assets. You can add a Sprite component to the node by clicking the Add Component button below the Inspector panel and selecting UI -> Render -> Sprite. Sprite Properties Properties Function Explanation Type Rendering mode, currently includes SIMPLE, SLICED, TILED, FILLED four rendering modes. Color Image color. Grayscale If enabled, Sprite will be rendered in gray scale mode. Size Mode Specify the size of the Sprite.TRIMMED automatically fit to the size of the sprite croppedRAW automatic fit for sprite original size.CUSTOM use the node preset size. When the developer manually modifies Size properties, Size Mode will be automatically set to Custom. Atlas Auto Atlas which the Sprite display image asset belongs to. Sprite Frame Sprite Frame Assets which is used to render the Sprite. (The Edit button behind Sprite Frame is used to edit the 9-sliced cutting of the image asset, please refer to Use a Sliced Sprite to make a UI image. Trim Whether the transparent pixel area is included in the node bounding box. Please refer to Auto Trim for SpriteFrame. Src Blend Factor The source image blend mode. Dst Blend Factor The destination image blend mode. Together with the above properties, you can mix the foreground Sprite and background in different ways to render, and you can refer to glBlendFunc Tool for an effect preview. After adding the Sprite component, drag the SpriteFrame type asset from the Assets to the Sprite Frame property reference. Then, the asset image can be displayed through the Sprite component. If this SpriteFrame asset is contained within an Atlas asset, then the Atlas property of the Sprite will be set up along with it. Note: To dynamically replace SpriteFrame, you need to dynamically load the image asset before you replace it, please refer to the Acquire and load asset: how to dynamically load documentation. Rendering mode Currently, the Sprite component supports the following rendering modes: Simple mode: rendering the Sprite according to the original image asset. It is normally used along with Use Original Size to guarantee the image shown in the scene is in full accordance with the image designed by the graphic designer. Sliced mode: the image is cut up into a 9-slicing and according to certain rules is scaled to fit freely set dimensions (size). It is usually used in UI elements or to make images that can be enlarged infinitely without influencing the image quality. It will cut up the original image into a grid to save game asset space. Please read Use a Sliced Sprite to make a UI image for details. Tiled mode: The image will be repeated to fit the size of the Sprite. If the SpriteFrame is 9-sliced, the corners will also remain unscaled while the other areas will be repeated. Filled mode: draws a portion of the original image in a certain direction and scale, based on the origin and fill mode settings. Often used for dynamic display of progress bars. Filled mode When the Type property selects FILLED, a new set of properties appears to be configured. So let's explain their roles in turn. Properties Function Explanation Fill Type Fill type selection, including HORIZONTAL, VERTICAL, and RADIAL. Fill Start Normalized values for filling starting position (from 0 ~ 1, denoting the percentage of total population), when you select a horizontal fill, the Fill Start is set to 0, and it is populated from the leftmost edge of the image. Fill Range Normalized values for padding ranges (same from 0 ~ 1). When set to 1, it fills up the entire range of the original image. Fill Center Fill center point, this property can only be modified if the RADIAL fill type is selected. Determines which point on the Sprite is used as pivot when the FillType is set to RADIAL. Fill Range Supplemental description Under both the HORIZONTAL and VERTICAL fill types, the values set by Fill Start affect the total number of fills, if Fill Start is set to 0.5, even if Fill Range is set to 1.0, the actual padding is still only half the total size of the Sprite. The Fill Start in the RADIAL type only determines the orientation of the starting fill, when Fill Start is set to 0, start filling from the x axis positive direction. Fill Range determines the total amount of padding, which fills the entire circle when Fill Range is set to 1. A counter anticlockwise fill when Fill Range is positive, and is filled clockwise when negative. "},"ui-system/components/editor/label.html":{"url":"ui-system/components/editor/label.html","title":"Label Reference","keywords":"","body":"Label Component Reference The Label component is used to display texts, the text can use System Font, TrueType Font, or Bitmap Font. In addition, Label also has some basic layout functionalities like alignment, line wrap, auto fit etc. Select a node in the Hierarchy panel, then click the Add Component button at the bottom of the Inspector panel and select Label from UI -> Render to add the Label component to the node. Label Properties Properties Function Explanation Color Label color. String Text content string. HorizontalAlign Horizontal alignment of the text, including LEFT, CENTER and RIGHT. VerticalAlign Vertical alignment of the text, including TOP, CENTER and BOTTOM. FontSize Font size of the text. FontFamily Font family name (Takes effect when using System Font). LineHeight Line height of the text. Overflow Layout of the text. Currently supports CLAMP, SHRINK and RESIZE_HEIGHT. For details, see Label Layout below or Label Layout document. EnableWrapText Enable or disable the text line wrap (which takes effect when the Overflow is set to CLAMP or SHRINK). Font Specify the font asset used for text rendering. If the System Font is used, then this property can be set to null. UseSystemFont If enabled, the given FontFamily will be used for rendering. CacheMode Text cache mode, including NONE, BITMAP and CHAR. Takes effect only for System Font or TTF Font, BMFont does not require this optimization. See Cache Mode below for details. IsBold If enabled, bold effect will be added to the text. (Takes effect when using System Font or some TTF Font). IsItalic If enabled, italic effect will be added to the text. (Takes effect when using System Font or some TTF Font). IsUnderline If enabled, underline effect will be added to the text. (Takes effect when using System Font or TTF Font). SrcBlendFactor The source blend mode for text rendering. DstBlendFactor The destination blend mode for text rendering. Together with the above properties, you can mix the foreground and background content in different ways, and you can refer to glBlendFunc Tool for the effect. Label Layout Options Function Explanation CLAMP The text size won't zoom in/out as the UITransform contentSize changes.When Wrap Text is disabled, texts exceeding the width will be clipped according to the normal character layout.When Wrap Text is enabled, it will try to wrap the text exceeding the boundaries to the next line. If the vertical space is not enough, any text out of bounds will also be hidden. SHRINK The text size could be scaled down as the UITransform contentSize changes (it won't be scale up automatically, the maximum size that will show is specified by FontSize).When EnableWrapText is enabled, if the width is not enough, it will try to wrap the text to the next line first.Then no matter whether the text is wrapped, if the text still exceed the contentSize of UITransform, it will be scaled down automatically to fit the boundaries.Note: This mode may consumes more CPU resources when the label is refreshed. RESIZE_HEIGHT The UITransform contentSize will be adapted to make sure the text is completely shown in its boundary. The developer cannot manually change the height of text in UITransform, it is automatically calculated by the internal algorithm. Cache Mode Options Function Explanation NONE Defaults, the entire text in label will generate a bitmap. BITMAP Currently it behaves in the same way as NONE CHAR The principle of this mode is similar to BMFont, Label will cache text to a global shared bitmap in characters, each character of the same font style and font size will share the same cache globally. This mode is the most friendly to performance and memory if the characters is limited in a small set. However, there are currently restrictions on this mode, which we will optimize in subsequent releases:1. This mode can only be used for font style and fixed font size (by recording the fontSize, fontFamily, color, and outline of the font as key information for repetitive use of characters, other users who use special custom text formats need to be aware). And will not frequently appear with a huge amount of unused characters of Label. This is to save the cache, because the global shared bitmap size is 1024 * 1024, it will only be cleared when the scene is switched. Once the bitmap is full, the newly appearing characters will not be rendered. 2. Overflow does not support SHRINK. Note: Cache Mode has an optimized effect for all platforms. Use font assets By dragging the TTF font asset and BMFont font asset into the Font property in the Inspector panel, the Label component can alter the rendering font type. If you want to stop using a font file, you can use the system font again by checking UseSystemFont. "},"ui-system/components/editor/mask.html":{"url":"ui-system/components/editor/mask.html","title":"Mask Reference","keywords":"","body":"Mask Component Reference Mask is used to specify the range which clip the render results of the children. A node with a Mask component will use a bounding box (which is specified by the contentSize of the UITransform component in the Inspector) to create a rectangular rendered mask. All child nodes of this node will only appear inside the mask's boundary. Select a node in the Hierarchy panel, then click the Add Component button at the bottom of the Inspector panel and select Mask from UI -> Render. Then you can add the Mask component to the node. Note: The Mask component cannot be added to a node with other renderer components such as Sprite, Label, etc. Mask Properties Properties Function Explanation Type Mask type, including RECT, ELLIPSE, GRAPHICS_STENCIL. Segments The segements for ellipse mask, which takes effect only when the Mask type is set to ELLIPSE. Inverted The Reverse mask. Note: After adding the Mask component to a node, all nodes in the sub tree of this node will be affected by Mask during rendering. The GRAPHICS_STENCIL simply provides the graphics component, which developers can use to draw custom graphics. But the node click events are still calculated based on the size of the node. "},"ui-system/components/editor/graphics.html":{"url":"ui-system/components/editor/graphics.html","title":"Graphics Reference","keywords":"","body":"Graphics Component Reference The Graphics component provides a series of drawing functions that reference the Web canvas's drawing APIs. Select a node in the Hierarchy panel, then click the Add Component button at the bottom of the Inspector panel and select Graphics from UI -> Render. Then you can add the Graphics component to the node. Graphic Properties Properties Function Explanation FillColor Sets or returns the color used for the fill function. LineCap LineCap determines how the end points of every line are drawn. LineJoin LineJoin determines how two connecting segments (of lines, arcs or curves) with non-zero lengths in a shape are joined together. MiterLimit Sets or returns the maximum miter length. StrokeColor Stroke color. Sets or returns the color used for the stroke. Graphics API Path Function Function Explanation moveTo (x, y) Move the render cursor to a specified point in the canvas without creating lines. lineTo (x, y) Adds a straight line to the path. bezierCurveTo (c1x, c1y, c2x, c2y, x, y) Adds a cubic Bézier curve to the path. quadraticCurveTo (cx, cy, x, y) Adds a quadratic Bézier curve to the path. arc (cx, cy, r, a0, a1, counterclockwise) Adds an arc to the path which is centered at (cx, cy) position with radius r starting at startAngle and ending at endAngle going in the given direction by counterclockwise (defaulting to false). ellipse (cx, cy, rx, ry) Adds an ellipse to the path. circle (cx, cy, r) Adds a circle to the path. rect (x, y, w, h) Adds a rectangle to the path. close () Close the previous path by connecting the last point and the beginning point. stroke () Stroke the path as lines fill () Close and fill a path's inner surface clear () Erase any previously drawn content. "},"ui-system/components/editor/richtext.html":{"url":"ui-system/components/editor/richtext.html","title":"RichText Reference","keywords":"","body":"RichText Component Reference RichText component could be used for displaying a string with multiple styles. You could customize the text style of each text segment with a few simple BBCode. The currently supported tags are: color, size, outline, b, i, u, br, img and on, these tags could also be nested within each other. For more information about BBCode, please refer to the BBCode format section below. Click the Add Component button at the bottom of the Inspector panel and select RichText from UI -> Render to add the RichText component to the node. RichText Properties Properties Function Explanation Font Custom TTF font of RichText, all the label segments will use the same custom TTF font. FontSize Font size, in points (Note: This field does not affect the font size set in BBCode.) HandleTouchEvent Once checked, the RichText will block all input events (mouse and touch) within the bounding box of the node, preventing the input from penetrating into the underlying node. Horizontal Align Horizontal alignment ImageAtlas The image atlas for the img tag. For each src value in the img tag, there should be a valid spriteFrame in the imageAtlas. LineHeight Line height, in points. MaxWidth The maximize width of RichText, set to 0 means the maximize width is not limited. String Text of the RichText, you could use BBcode in the string. BBCode format Basics Currently the supported tag list is: size, color, b, i, u, img and on. There are used for customizing the font size, font color, bold, italic, underline, image and click event. Every tag should has a start tag and an end tag. The name and attribute format of the start tag must meet the requirements and be all lowercase. It will check the start tag name, but the end tag name restrict is loose, it only requires a tag, the end tags name doesn't matter. Here is an example of the size and color tag: Hello, Creator3D Supported tags Note: All tag names should be lowercase and the attribute assignment should use = sign. Name Description Example Note color Specify the font rendering color, the color value could be a built-in value or a hex value. eg, use #ff0000 for red. Red Text size Specify the font rendering size, the size should be a integer. enlarge me The size assignment should use = sign. outline Specify the font outline, you could customize the outline color and width by using the color and width attribute. A label with outline If you don't specify the color or width of outline, the default color value is #ffffff and the default width is 1. b Render text as bold font This text will be rendered as bold The tag name must be lowercase and cannot be written in bold. i Render text as italic font This text will be rendered as italic The tag name must be lowercase and cannot be written in italic. u Add a underline to the text This text will have a underline The tag name must be lowercase and cannot be written in underline. on Specify a event callback to a text node, when you click the node, the callback will be triggered. click me! Except for on tag, color and size tags can also add click event parameter. eg. click me param When the click event is triggered, the value can be obtained in the second attribute of the callback function. click me! Depends on the click event. br Insert a empty line and are both invalid tags. img Add image and emoji support to your RichText. The emoji name should be a valid sprite frame name in the ImageAtlas. Only is a valid img tag. If you specify a large emoji image, it will scale the sprite height to the line height of the RichText together with the sprite width. Nested Tags Tags could be nested, the rules is the same as normal HTML tags. For example, the following settings will render a label with font size 30 and color value green. I'm green is equal to: I'm green String__ of the __Inspector__. 2. Use BBCode to set colors on the inside of RichText separately. Use BBCode to set the colors separately inside RichText. __Note__: The two cannot be mixed. If mixed, the color set in the __second__ way will prevail at runtime. --> Detailed Explanation The RichText component is implemented in the Javascript layer and uses the Label node as the rendering part. All the layout logic goes also in Javascript layer. This means if you create a very complex RichText, it will end up with many label node created under the hook. And all these label node are using system font for rendering. So, you should avoid modifying the RichText content frequently in your game's main loop, which can lead to lower performance. Also, try to use the normal Label component instead of the RichText component if you can, and BMFont is the most efficient. "},"ui-system/components/editor/ui-static.html":{"url":"ui-system/components/editor/ui-static.html","title":"UIStaticBatch Reference","keywords":"","body":"UIStaticBatch Component References The UIStaticBatch component is used to improve UI rendering performance. The script will collect all the rendering data under the UI node tree (except Model, Mask, and Graphic) during the initialization of the current frame rendering and store it as a static input assembler(IA) rendering data. And rendering with fixed data in the subsequent rendering process, no longer traversing its node tree, after which the coordinate transformation will no longer take effect. Detailed Explanation The following points need to be noted when using this component: Do not trigger static batches frequently, as the original stored IA data will be emptied and re-collected, resulting in some performance and memory loss. Not applicable for child node tree which contains Mask, Graphic and Model. For a node that will not have any changes in the node tree (e.g. 2D Map), all child nodes can be deleted after data collection to get the best performance and memory performance. "},"ui-system/components/editor/base-component.html":{"url":"ui-system/components/editor/base-component.html","title":"UI Basic Component ","keywords":"","body":"UI Basic Components Canvas Component Reference UITransform Component Reference Widget Component Reference Button Component Reference Layout Component Reference EditBox Component Reference ScrollView Component Reference ScrollBar Component Reference ProgressBar Component Reference LabelOutline Component Reference Toggle Component Reference UIModel Component Reference ToggleGroup Component Reference Slider Component Reference PageView Component Reference PageViewIndicator Component Reference UIOpacity Component Reference BlockInputEvents Component Reference "},"ui-system/components/editor/canvas.html":{"url":"ui-system/components/editor/canvas.html","title":"Canvas Reference","keywords":"","body":"Canvas Component Reference The node where the Canvas component is located is the root of the UI rendering. There can be multiple Canvas in the scene. All UI elements must be placed under a Canvas node so that it can be rendered. UI Elements are rendered by the Canvas node that they are located under. Each Canvas can be presented in a certain order controlled by the priority attribute. In addition to the root node of the UI, Canvas also has a screen adaptation function. Please refer to the Multi-Resolution Adaption documentation to read about this. Canvas also supports multi-resolution adaptation . The design resolution and adaptation scheme are uniformly set in the Project Setting. A Camera is provided inside the Canvas, and the default z-axis direction is -1000 ~ 998, so the z-axis on the UI must be within this range to display properly (without taking the threshold value). In the previous design, Canvas was last rendered, meaning it could mask the rendering of all 3D content, but this was far from sufficient for project development needs, such as a 2D map with a 3D character. The RenderMode property allows developers to sort the rendering order of the 3D Camera and UI Camera. If you want to have canvas and 3D camera content mixed up, only the lowest camera or canvas can have the SOLID_COLOR ClearFlag, otherwise a camera with SOLID_COLOR flag will erase all content rendered before it. Canvas Properties Properties Function Explanation ClearFlag Clean up the flag of the screen buffer.DONT_CLEAR: No cleanup.DEPTH_ONLY: Clear the depth buffer.SOLID_COLOR: Clear the color depth buffer. Color The color used to clear the whole render buffer. Priority Camera sort priority.Only when the Canvas RenderMode is INTERSPERSE, the canvas can be rendered before any camera with lower priority.When RenderMode is OVERLAY, the priority only affect the order among all canvas. RenderMode Render mode of the Canvas.When set to INTERSPERSE, the priority take effect among all canvas and cameras in the Scene. When set to OVERLAY, the canvas will always be rendered after all cameras in the scene.Note: When INTERSPERSE mode is enabled and its priority is lower than other camera, the camera's ClearFlags should be set to DONT_ClEAR, otherwise the content of the beneath canvas will be erased. TargetTexture Rendering texture of the target. Detailed Explanation If you encounter errors in UI rendering, such as flickering, unwanted artifacts or other graphical oddness please refer to the Engine priority documentation. "},"ui-system/components/editor/ui-transform.html":{"url":"ui-system/components/editor/ui-transform.html","title":"UITransform Reference","keywords":"","body":"UITransform Component Reference The UITransform component defines the rectangle information on the UI, including the content size and anchor position of the rectangle. This component allows developers to modify the size and position of the rectangle freely, generally for rendering, calculation of click events, UI layout, screen adaptation, etc. Click the Add Component button at the bottom of the Inspector panel and select UITransform from UI to add the UITransform component to the node. UITransform Properties Properties Function Explanation ContentSize The content size of UI rectangle. AnchorPoint The anchor position of UI rectangle. Priority The priority of UI nodes, sorted in the parent node. The order of the Canvas node is not affected by this property. "},"ui-system/components/editor/widget.html":{"url":"ui-system/components/editor/widget.html","title":"Widget Reference","keywords":"","body":"Widget Component Reference Widget is a frequently used UI layout component. It can automatically align the current node to any position in the parent node's bounding box, or constrain the size, to make your game easily adaptable to different resolutions. About the alignment scheme, please see Widget Alignment for details. Click the Add Component button at the bottom of the Inspector panel and select UI/Widget to add the Widget component to the node. Widget Properties Properties Function Explanation Note Top Upper border alignment Once selected, an input field will appear to set the distance between the upper border of the current node and the upper border of the parent object. Bottom Lower border alignment Once selected, an input field will appear to set the distance between the lower border of the current node and the lower border of the parent object. Left Left border alignment Once selected, an input field will appear to set the distance between the left border of the current node and the left border of the parent object. Right Right border alignment Once selected, an input field will appear to set the distance between the right border of the current node and the right border of the parent object. HorizontalCenter Horizontal center alignment VerticalCenter Vertical center alignment Target Alignment target Specifies an alignment target that can only be one of the parent nodes of the current node. The default value is null, and when null, indicates the current parent.If the parent node is the entire scene, it will be aligned to the visible area of the screen (visibleRect), and can be used to dock UI elements to the edge of the screen. Align Mode Specifies the alignment mode of the Widget, which determines when the widget should refresh at runtime Normally set to ALWAYS, only to be initialized and realigned whenever the window size changes.Set to ONCE, will only make alignment when the component is enabled.Set to ON_WINDOW_RESIZE, will update Widget's alignment every time when the window changes. Border alignment We can create a new Sprite node under the Canvas node, add a Widget component to the Sprite, and do the following test: Left alignment, left border distance 100 px: Bottom alignment, bottom border distance 50%: The percentage will take the width or height of the parent node as a benchmark. Bottom right alignment, border distance 0 px: Center Alignment Horizontal center alignment: Vertical center alignment and right border distance 50%: Limit size If you align the left and right side at the same time, or align the top and bottom at the same time, then the size will be stretched in the corresponding direction. Let us look at a demonstration. Place two rectangular Sprites in the Scene and take the bigger one as the dialog box background and the smaller one as the button on the dialog box. Take the button node as the child node of the dialog box and set the button into SLICED mode so that you can observe the stretch effect. Horizontal stretch, left and right margin 10%: Vertical stretch, no margins on each end and horizontal center alignment: Stretch in the horizontal and vertical directions, margin 50 px: Limitation on node position control If Align Mode property is set to ALWAYS, the Widget will set the alignment for the current node every frame at runtime according to the alignment policy you set. The position and size (width, height) properties of the node where the component is located may be restricted and cannot be freely modified via the API or animation system. This is because the alignment set by the widget is processed at the end of each frame, so if you set the previously set alignment related properties in the Widget component, those settings will eventually be reset by the widget component's own settings. To make sure you can update node's position or size during runtime: Set Align Mode property of Widget to ONCE, so it will only align during onEnable process. Use Widget's API to update node's position and size, for example updating Widget's top, bottom, left, right instead of node's x, y, width, height. "},"ui-system/components/editor/button.html":{"url":"ui-system/components/editor/button.html","title":"Button Reference","keywords":"","body":"Button Component Reference The Button component responds to a click from the user. When the user clicks a Button, its status will change. In addition, users can assign a custom behavior to buttons' click event. Click the Add Component button at the bottom of the Inspector panel and select UI/Button to add the Button component to the node. Button Properties Properties Function Explanation Target Specify the Button background node. When the Button status changes, the Color or Sprite property of the node will be modified. Interactable Boolean type, if set to false then the Button component enters the forbidden state. Transition Enumeration type, including NONE, COLOR, SPRITE and SCALE. Each type corresponds to a different Transition setting. Please see the Button Transition section below for details. ClickEvents List type, default is null. Each event added by the user is composed of the node reference, component name and a response function. Please see the Button Event section below for details. Button Transition Button Transition is used to choose the action of the button when clicked by the user. Currently the types available are NONE, COLOR, SPRITE and SCALE. Color Transition Properties Function Explanation Normal Color of Button under Normal status. Pressed Color of Button under Pressed status. Hover Color of Button under Hover status. Disabled Color of Button under Disabled status. Duration Time interval needed for Button status switching. Sprite Transition Properties Function Explanation Normal SpriteFrame of Button under Normal status. Pressed SpriteFrame of Button under Pressed status. Hover SpriteFrame of Button under Hover status. Disabled SpriteFrame of Button under Disabled status. Scale Transition Properties Function Explanation Duration Time interval needed for Button status switching. ZoomScale When the user clicks the button, the button will zoom to a scale. The final scale of the button equals to the button's original scale * zoomScale, and the zoomScale can be a negative value. Button Click Events The Button can additionally add a click event to respond to the player's click action. There are two ways to achieve this. Add a callback using the Properties Property Function Explanation Target Node with the script component. Component Script component name. Handler Assign a callback function from the given component which will be triggered when the user clicks the Button. CustomEventData A user-defined string value passed as the last event argument of the event callback. Add a callback using the script There are two ways to add a callback through the script. The event callback added by this method is the same as the event callback added by the editor, all added by the script. First you need to construct a EventHandler object, and then set the corresponding target, component, handler and customEventData parameters. import { _decorator, Component, Event, Node, ButtonComponent, EventHandler } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { onLoad(){ const clickEventHandler = new EventHandler(); // This node is the node to which your event handler code component belongs clickEventHandler.target = this.node; // This is the code file name clickEventHandler.component = 'example'; clickEventHandler.handler = 'callback'; clickEventHandler.customEventData = 'foobar'; const button = this.node.getComponent(ButtonComponent); button.clickEvents.push(clickEventHandler); } callback(event: Event, customEventData: string){ // The event here is a Touch object, and you can get the send node of the event by event.target const node = event.target as Node; const button = node.getComponent(ButtonComponent); console.log(customEventData); // foobar } } By button.node.on ('click', ...) to add event callback. This is a very simple way, but the way has some limitations, in the event callback the screen coordinate point of the current click button cannot be obtained. // Suppose we add an event handler callback to the onLoad method of a component and handle the event in the callback function: import { _decorator, Component, ButtonComponent } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example ex tends Component { @property(ButtonComponent) button: ButtonComponent | null = null; onLoad(){ this.button.node.on('click', this.callback, this); } callback(button: ButtonComponent){ // Note that events registered this way cannot pass customEventData } } "},"ui-system/components/editor/layout.html":{"url":"ui-system/components/editor/layout.html","title":"Layout Reference","keywords":"","body":"Layout Component Reference Layout is a component for UI container nodes. This component provide to the container various layout functionalities to automatically arrange all the children, so that the developer can make list, page, grid container, etc conveniently. Horizontal Layout Vertical Layout Grid Layout Click the Add Component button at the bottom of the Inspector panel and select UI/Layout to add the Layout component to the node. Layout Properties Properties Function Explanation Type Layout type, including NONE, HORIZONTAL, VERTICAL and GRID. See Auto Layout for details. ResizeMode Resize mode, including NONE, CHILDREN and CONTAINER. PaddingLeft The left padding between the children and the container frame. PaddingRight The right padding between the children and the container frame. PaddingTop The top padding between the children and the container frame. PaddingBottom The bottom padding between the children and the container frame. SpacingX The spacing between children in the horizontal layout. NONE mode doesn't have this property. SpacingY The spacing between children in the vertical layout. NONE mode doesn't have this property. HorizontalDirection When it is designated as horizontal layout, this property determines which side(left or right) does the first child node start in the layout. When the Layout type is set to Grid, this property along with Start Axis property determine the starting horizontal alignment of Grid layout elements. VerticalDirection When it is designated as vertical layout, this property determines which side(top or bottom) does the first child node start in the layout. When the Layout type is set to Grid, this property with Start Axis property determines the starting vertical alignment of Grid layout elements. CellSize This property is only available in Grid layout, CHILDREN resize mode, determines the size of each child node. StartAxis This property is only available in Grid layout, determines the arrangement direction of children. AffectedByScale Whether the scale of the child node affects the layout. Detailed Explanation The default layout type is NONE. It indicates that the container won't change size and position of the children. When the user places children manually, the container will take the minimum rectangular region that can contain all the children as its own size. You can switch the layout container type by altering Type property in the Inspector panel, all the layout types support Resize Mode. When Resize Mode is NONE, the size of the container and children is independent from each other. When Resize Mode is CHILDREN, the size of the children will change with the size of the container to make sure all children fit inside the container's bounding box. When Resize Mode is CONTAINER, the size of the container will change with the size of the children to make sure the container is large enough to contain all children inside its bounding box. When using Grid layout, the Start Axis is very important. When choosing HORIZONTAL, it will fill an entire row before a new row is started. When choosing VERTICAL, it will fill an entire column before a new column is started. Node: If the Layout's configuration is set in runtime, the results need to be updated until the next frame, unless you manually call updateLayout API. "},"ui-system/components/editor/editbox.html":{"url":"ui-system/components/editor/editbox.html","title":"EditBox Reference","keywords":"","body":"EditBox Component Reference EditBox is a text input component, you can use this component to get user input easily. Click the Add Component button at the bottom of the Inspector panel and select UI/EditBox to add the EditBox component to the node. EditBox Properties Properties Function Explanation BackgroundImage The Sprite component attached to the node for EditBox's background FontColor The input text color of EditBox FontSize The input text size of EditBox InputFlag Specify the input flag: password or capitalized word. (Only supports Android platform) InputMode Specify the input mode: multiline or single line LineHeight The input text line height of EditBox MaxLength The maximize input characters of EditBox Placeholder The text content of EditBox placeholder PlaceholderFontColor The text font color of EditBox placeholder PlaceholderFontSize The text font size of EditBox placeholder PlaceholderLabel The Label component attached to the node for EditBox's placeholder text label ReturnType The keyboard return type of EditBox. This is useful for keyboard of mobile device String The initial input text of EditBox, which displays the text of the placeholder if not set TabIndex Set the tabIndex of the DOM input element, only useful on the Web TextLabel The Label component attached to the node for EditBox's input text label EditBox Events For event structure you can refer to the Button documentation. Editing Did Began: This event will be triggered when the user clicks on the EditBox. Editing Did Ended: This event will be triggered when the EditBox loses focus. When in single line input mode, it's triggered after user presses Enter key or clicks the area outside of EditBox. When in multiline input mode, it's triggered only after user clicks the area outside of EditBox. Text Changed: This event will be triggered when the content in EditBox is changed each time. Detailed Explanation If you want to input password, you need set Input Flag to PASSWORD and the Input Mode mustn't be ANY, usually we use Single Line. If you want to enable multiline input support, you can set the Input Mode to Any. The background image of EditBox support 9-slicing sprite frame, you could customize the border as you did in Sprite component. Add a callback through the script code Method one The event callback added by this method is the same as the event callback added by the editor, all added by code. First you need to construct a EventHandler object, and then set the corresponding target, component, handler and customEventData parameters. import { _decorator, Component, EditBoxComponent, EventHandler } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { onLoad() { const editboxEventHandler = new EventHandler(); // This node is the node to which your event handler code component belongs. editboxEventHandler.target = this.node; editboxEventHandler.component = 'example'; editboxEventHandler.handler = 'onEditDidBegan'; editboxEventHandler.customEventData = 'foobar'; const editbox = this.node.getComponent(EditBoxComponent); editbox.editingDidBegan.push(editboxEventHandler); // You can also register other callback functions in a similar way. // editbox.editingDidEnded.push(editboxEventHandler); // editbox.textChanged.push(editboxEventHandler); // editbox.editingReturn.push(editboxEventHandler); } onEditDidBegan(editbox, customEventData) { // The editbox here is a cc.EditBox object. // The customEventData parameter here is equal to the \"foobar\" you set before. } // Suppose this callback is for the editingDidEnded event. onEditDidEnded(editbox, customEventData) { // The editbox here is a cc.EditBox object. // The customEventData parameter here is equal to the \"foobar\" you set before. } // Suppose this callback is for the textChanged event. onTextChanged(text, editbox, customEventData) { // The text here indicates the text content of the modified EditBox. // The editbox here is a cc.EditBox object. // The customEventData parameter here is equal to the \"foobar\" you set before. } // Suppose this callback is for the editingReturn event. onEditingReturn(editbox, customEventData) { // The editbox here is a cc.EditBox object. // The customEventData parameter here is equal to the \"foobar\" you set before. } } Method two Added with Node's event API editbox.node.on('editing-did-began', ...). // Suppose we add an event handler callback inside a component's onLoad method and event handlers in the callback function. import { _decorator, Component, EditBoxComponent } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { @property(EditBoxComponent) editbox: EditBoxComponent | null = null; onLoad(){ this.editbox.node.on('editing-did-began', this.callback, this); } callback(editbox: EditBoxComponent){ // The callback parameter is the EditBox component, note that events registered this way cannot pass customEventData. } } Similarly, you can register events such as editing-did-ended, text-changed, editing-return, etc. The parameters of the callback function for these events are consistent with the parameters of editing-did-began. "},"ui-system/components/editor/scrollview.html":{"url":"ui-system/components/editor/scrollview.html","title":"ScrollView Reference","keywords":"","body":"ScrollView Component Reference ScrollView is a container with a scroll function. It provides a way to browse more contents within a limited display area. Generally, ScrollView will be used along with the Mask component and the ScrollBar component can also be added to show the current offset location within the browsing content. Click the Add Component button at the bottom of the Inspector panel and select UI/ScrollView to add the ScrollView component to the node. ScrollView Properties Properties Function Explanation BounceDuration Floating point number, the time duration for bounce back. The value range is 0-10 Brake Floating point number, the deceleration coefficient after scrolling. The value range is 0-1. If set to 1, then the scrolling will stop immediately, if set to 0, then the scrolling will continue until the content border CancelInnerEvents If it is set to true, then the scroll behavior will cancel the touch events registered on the child node. The default setting is true Content A reference node for the inner content of the ScrollView. It could be a node containing a very large image or long texts. Elastic Boolean value, whether to bounce back or not while scroll to the border. Horizontal Boolean value, whether horizontal scroll is allowed or not HorizontalScrollBar A reference node for creating a scroll bar showing the horizontal position of the content Inertia Is there an accelerating velocity when scrolling ScrollEvents Default list type is null. Each event added by the user is composed of the node reference, component name and a response function. Please see the ScrollView Event section below for details Vertical Boolean value, whether vertical scroll is allowed or not VerticalScrollBar A reference node for creating a scroll bar showing vertical position of the contents ScrollView Event For event structure you can refer to the Button documentation. The ScrollView event callback will have two parameters, the first one is the ScrollView itself and the second one is the event type of ScrollView. ScrollBar Setting ScrollBar is optional. You can choose to set either a Horizontal ScrollBar or a Vertical ScrollBar or of course set them both. To build a connection, you can drag a node with the ScrollBar component in the Hierarchy over to the corresponding field in ScrollView. Detailed Explanation The ScrollView component can only work with the specified content node. It calculates location information during scrolling using both the designated scroll direction and the length of the content node in this direction. The Content node can also set up the auto resize by adding a WidgetComponent, or it can arrange the layout of child nodes by adding a LayoutComponent, but these two components should not be added to a node at the same time to avoid unintentional consequences. Normally a ScrollView node tree resembles the following: The view here is used to define a scroll area that can be displayed. As a result, the MaskComponent will normally be added to the view. Contents that can scroll can be put in the content node or added to its child node. Add a callback through the script code Method one The event callback added by this method is the same as the event callback added by the editor, all added by code. First you need to construct a EventHandler object, and then set the corresponding target, component, handler and customEventData parameters. import { _decorator, Component, ScrollViewComponent, EventHandler } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { onLoad() { const scrollViewEventHandler = new EventHandler(); // This node is the node to which your event handler code component belongs scrollViewEventHandler.target = this.node; // This is the code file name scrollViewEventHandler.component = 'example'; scrollViewEventHandler.handler = 'callback'; scrollViewEventHandler.customEventData = 'foobar'; const scrollview = this.node.getComponent(ScrollViewComponent); scrollview.scrollEvents.push(scrollViewEventHandler); } callback(scrollview, eventType, customEventData){ // here scrollview is a Scrollview component object instance // here the eventType === ScrollViewComponent.EventType enum // here the customEventData parameter is equal to the \"foobar\" you set before } } Method two By scrollview.node.on('scroll-to-top', ...) way to add. // Suppose we add an event handler callback to the onLoad method of a component and handle the event in the callback function: import { _decorator, Component, ScrollViewComponent } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { @property(ScrollViewComponent) scrollview: ScrollViewComponent | null = null; onLoad(){ this.scrollview.node.on('scroll-to-top', this.callback, this); } callback(scrollView: ScrollViewComponent){ // The callback parameter is the ScrollView component, note that events registered this way cannot pass customEventData. } } Similarly, you can register events such as scrolling, touch-up, scroll-began, etc. The parameters of the callback function for these events are consistent with the parameters of scroll-to-top. "},"ui-system/components/editor/scrollbar.html":{"url":"ui-system/components/editor/scrollbar.html","title":"ScrollBar Reference","keywords":"","body":"ScrollBar Component Reference The ScrollBar allows the user to scroll by dragging a sliding block. It's a bit similar to the Slider component, but it is mostly used as a part of the ScrollView while Slider is used independently to set values. Click the Add Component button at the bottom of the Inspector panel and select UI/ScrollBar to add the ScrollBar component to the node. ScrollBar Properties Properties Function Explanation AutoHideTime Time to hide the ScrollBar automatically, need to set Enable Auto Hide to true for it to take effect Direction Scroll direction, including HORIZONTAL and VERTICAL EnableAutoHide Enable or disable auto hide. If this property is enabled, the ScrollBar will automatically disappear after actions stopped for AutoHideTime. Handle ScrollBar foreground picture. Its length / width will be calculated according to the content size of ScrollView and the dimensions of the actual display area Detailed Explanation The ScrollBar normally is used together with ScrollView instead of being used alone. Also, ScrollBar needs to assign a Sprite component, i.e. Handle in the Inspector panel. Normally we will also designate a background image to ScrollBar. This can be used to indicate the length or width of the whole ScrollBar. "},"ui-system/components/editor/progress.html":{"url":"ui-system/components/editor/progress.html","title":"ProgressBar Reference","keywords":"","body":"ProgressBar Component Reference ProgressBar is usually used to show the progress of a certain operation in the game. Add the ProgressBar component to a node and associate a Bar Sprite to this component. Then the Bar Sprite can be controlled to show progression in the scene. Click the Add Component button at the bottom of the Inspector panel and select UI/ProgressBar to add the ProgressBar component to the node. ProgressBar Properties Properties Function Explanation BarSprite The Sprite component needed for rendering ProgressBar. It can be linked by dragging a node with the Sprite component to this property Mode Currently supports the HORIZONTAL, VERTICAL and FILLED modes. The initial direction can be changed by cooperating with the reverse property Progress Floating point. The value range is 0~1, and values outside the range are not allowed. Reverse Boolean value. The default fill direction is from left to right / bottom to top, when enable, it becomes right to left / top to bottom Total Length The total length / total width of the BarSprite when the ProgressBar is at 100%. In FILLED mode, Total Length represents the percentage of the total display range for Bar Sprite, with values ranging from 0 to 1 Detailed Explanation After adding the ProgressBar component, drag a node with the Sprite component from the Hierarchy to the BarSprite property. Then you can control the display of the ProgressBar by dragging the progress sliding block. Bar Sprite could be its own node, child node or any node that comes with the Sprite component. Also, Bar Sprite can freely choose the SIMPLE, SLICED or FILLED render types. If the mode of the progress bar is FILLED, the Type of BarSprite should to be set to FILLED, otherwise a warning will appear. "},"ui-system/components/editor/label-outline.html":{"url":"ui-system/components/editor/label-outline.html","title":"LabelOutline Reference","keywords":"","body":"LabelOutline Component Reference The LabelOutline component will add an outline effect to the Label component on the node. LabelOutline won't have any effect on Label using BMFont. Select a node in the Hierarchy panel, then click the Add Component button at the bottom of the Inspector panel and select LabelOutline from UI. Then you can add the LabelOutline component to the node. LabelOutline Properties Properties Function Explanation Color The outline color Width The outline width "},"ui-system/components/editor/toggle.html":{"url":"ui-system/components/editor/toggle.html","title":"Toggle Reference","keywords":"","body":"Toggle Component Reference The Toggle component is a CheckBox, when it's used together with a ToggleGroup, it could be treated as a RadioButton. Click the Add Component button at the bottom of the Inspector panel and select UI/Toggle to add the Toggle component to the node. Toggle Properties Properties Function Explanation IsChecked Boolean type. When set to true, enable the check mark component CheckMark SpriteComponent type. The image displayed when Toggle is selected ToggleGroup ToggleContainerComponent type. The ToggleGroup which the toggle belongs to. When it is null, the Toggle is a CheckBox. Otherwise, the Toggle is a RadioButton CheckEvents List type, default is null. Each event added by the user is composed of the node reference, component name and a response function. Please see the Toggle Event section below for details Note: Because Toggle is inherited from Button, so the properties exists in Button also apply to Toggle, please refer to the Button Component for details. Toggle Event For event structure you can refer to the Button documentation. The Toggle event callback has two parameters, the first one is the Toggle itself and the second is the customEventData. Detailed Explanation The generic node hierarchy of Toggle is as below: Note: The checkMark node needs to be placed on the upper level of the background node in the Scene. Add a callback through the script code Method one The event callback added by this method is the same as the event callback added by the editor, all added by code. First you need to construct a EventHandler object, and then set the corresponding target, component, handler and customEventData parameters. import { _decorator, Component, Event, Node, ToggleComponent, EventHandler } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { onLoad(){ const checkEventHandler = new EventHandler(); // This Node is the node to which your event processing code component belongs checkEventHandler.target = this.node; // This is the code file name checkEventHandler.component = 'example'; checkEventHandler.handler = 'callback'; checkEventHandler.customEventData = 'foobar'; const toggle = this.node.getComponent(ToggleComponent); toggle.checkEvents.push(checkEventHandler); } callback(event: Event, customEventData: string){ // The event here is a Touch Event object, and you can get the send node of the event by event.target // The customEventData parameter here is equal to the \"foobar\" you set before } } Method two Added by the way of toggle.node.on('toggle', ...). // // Suppose we add an event handler callback inside a component's onLoad method and event handlers in the callback function: import { _decorator, Component, ToggleComponent } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { @property(ToggleComponent) toggle: ToggleComponent | null = null; onLoad(){ this.toggle.node.on('toggle', this.callback, this); } callback(toggle: ToggleComponnet){ // The callback parameter is the Toggle component, note that events registered this way cannot pass customEventData. } } "},"ui-system/components/editor/toggleContainer.html":{"url":"ui-system/components/editor/toggleContainer.html","title":"ToggleContainer Reference","keywords":"","body":"ToggleContainer Component Reference ToggleContainer is not a visible UI component but it can be used to modify the behavior of a set of Toggle components. Toggles that belong to the same ToggleContainer could only have one of them to be switched on at a time. Note: All the first layer child node containing the Toggle component will auto be added to the container. Click the Add Component button at the bottom of the Inspector panel and select UI/ToggleContainer to add the ToggleContainer component to the node. ToggleContainer Properties Properties Functions Explanation AllowSwitchOff If it is enabled, then the toggle button can be checked and unchecked repeatedly when it is clicked. If it is disabled, it will make sure there is always only one toggle could be checked and the already checked toggle can't be unchecked CheckEvents List type, default is null. Each event added by the user is composed of the node reference, component name and a response function. Please see the ToggleContainer Event section below for details ToggleContainer Event For event structure you can refer to the Button documentation. The ToggleContainer event callback has two parameters, the first one is the ToggleContainer itself and the second is the customEventData. Detailed Explanation The ToggleContainer won't be used alone and it usually be used with Toggle to implement the RatioButton. Add a callback through the script code The event callback added by this method is the same as the event callback added by the editor, all added by code. First you need to construct a EventHandler object, and then set the corresponding target, component, handler and customEventData parameters. import { _decorator, Component, Event, Node, ToggleContainerComponent, EventHandler } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { onLoad(){ const containerEventHandler = new EventHandler(); // This Node is the node to which your event processing code component belongs containerEventHandler.target = this.node; // This is the code file name containerEventHandler.component = 'example'; containerEventHandler.handler = 'callback'; containerEventHandler.customEventData = 'foobar'; const container = this.node.getComponent(ToggleContainerComponent); container.checkEvents.push(containerEventHandler); } callback(event: Event, customEventData: string){ // The event here is a Touch Event object, and you can get the send node of the event by event.target // The customEventData parameter here is equal to the \"foobar\" you set before } } "},"ui-system/components/editor/slider.html":{"url":"ui-system/components/editor/slider.html","title":"Slider Reference","keywords":"","body":"Slider Component Reference Slider is a component for the production of UI components such as volume adjustment. Click the Add Component button at the bottom of the Inspector panel and select UI/Slider to add the Slider component to the node. Slider Properties Properties Function Explanation Handle The button part of the Slider that allows to adjust value by sliding the button Direction The direction of the slider, including Horizontal and Vertical Progress Current progress value, the value range is 0 ~ 1 SlideEvents Slider component event callback function Slider Event For event structure you can refer to the Button documentation. The Slider event callback has two parameters, the first one is the Slider itself and the second is the customEventData. Detailed Explanation The Slider is usually used to adjust the value of the UI (for example, volume adjustment), and its main component is a slider button, which is used for user interaction. You can adjust the value of the Slider through this part. Usually a Slider node tree as shown below: Add a callback by script code Method one The event callback added by this method is the same as the event callback added by the editor, all added by code. First you need to construct a EventHandler object, and then set the corresponding target, component, handler and customEventData parameters. import { _decorator, Component, Event, Node, SliderComponent, EventHandler } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { onLoad(){ const sliderEventHandler = new EventHandler(); // This Node is the node to which your event processing code component belongs sliderEventHandler.target = this.node; // This is the code file name sliderEventHandler.component = 'example'; sliderEventHandler.handler = 'callback'; sliderEventHandler.customEventData = 'foobar'; const slider = this.node.getComponent(SliderComponent); slider.slideEvents.push(sliderEventHandler); } callback(event: Event, customEventData: string){ // The event here is a Touch Event object, and you can get the send node of the event by event.target // The customEventData parameter here is equal to the \"foobar\" you set before } } Method two By slider.node.on('slide', ...) way to add. // Suppose we add event handling callbacks to the onLoad method of a component and perform event handling in the callback function: import { _decorator, Component, SliderComponent } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { @property(SliderComponent) slider: SliderComponent | null = null; onLoad(){ this.toggle.node.on('toggle', this.callback, this); } callback(slider: SliderComponent){ // The parameter of the callback is the Slider component. Note that events registered this way cannot pass customEventData } } "},"ui-system/components/editor/pageview.html":{"url":"ui-system/components/editor/pageview.html","title":"PageView Reference","keywords":"","body":"PageView Component Reference The PageView component is derived from ScrollView, the difference is that when scrolls it automatically snaps to next page of content. Click the Add Component button at the bottom of the Inspector panel and select UI/PageView to add the PageView component to the node. PageView Properties Properties Function Description AutoPageTurningThreshold Auto page turning velocity threshold. When users swipe the PageView quickly, it will calculate a velocity based on the scroll distance and time, if the calculated velocity is larger than the threshold, then it will trigger page turning Bounce Duration The elapse time of bouncing back. The value range is 0 ~ 10, and when the value is 0, it will bounce back immediately Brake It determines how quickly the content stop moving. A value of 1 will stop the movement immediately. A value of 0 will never stop the movement until it reaches to the boundary of page view Content It is a node reference that is used to contain the contents of the page view Direction The page view direction Elastic When elastic is set, the content will be bounce back when move out of boundary Indicator The Page View Indicator, please refer to PageViewIndicator Setting below for details Inertia When inertia is set, the content will continue to move for a little while when touch ended PageEvents A list of the page view's events callback PageTurningEventTiming Change the timing for sending the PAGE_TURNING event CancelInnerEvents If it's set to true, the scroll behavior will cancel touch events on inner content nodes. It's set to true by default ScrollThreshold This value will be multiplied by the distance between two pages, to get the threshold distance. If user scroll distance is larger than this threshold distance, the page will turn immediately SizeMode Specify the size type of each page in PageView, including Unified and Free PageViewIndicator Setting PageViewIndicator is optional, the component is used to display the number of pages and mark the current page. The association can be done by dragging a node with a PageViewIndicator component into the Indicator property of the PageView component in the Hierarchy panel. PageView Event Properties Function Description Target Node with script component Component Script component name Handler Specifies a callback function that will be called when the PageView event occurs CustomEventData The user specifies an arbitrary string as the last parameter of the event callback The PageView event callback has two parameters, the first parameter is the PageView itself, the second parameter is the event type of the PageView. Detailed Explanation The PageView component must have the specified content node to work. Each child node in content is a separate page, and the size of each page is the size of the PageView node. If the node size is larger than the content size, it may result in an incomplete scroll. Under the PageView component there is a node object, which combines with ScrollThreshold to determine whether the current sliding distance is such that the page can be turned. The operation effect is divided into two kinds: Slow sliding - by dragging the page in the view to reach the specified ScrollThreshold value (the value is the percentage of page size), after the release will automatically slide to the next page. Fast sliding - quickly drag in one direction, automatically slide to the next page. Only slide up to one page at a time. Add callback via script code Method one The event callback added by this method is the same as the event callback added by the editor, all added by code. First you need to construct a EventHandler object, and then set the corresponding target, component, handler and customEventData parameters. import { _decorator, Component, Event, Node, PageViewComponent, EventHandler } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { onLoad(){ const pageChangedEventHandler = new EventHandler(); // This Node is the node to which your event processing code component belongs pageChangedEventHandler.target = this.node; // This is the code file name pageChangedEventHandler.component = 'example'; pageChangedEventHandler.handler = 'callback'; pageChangedEventHandler.customEventData = 'foobar'; const page = this.node.getComponent(PageViewComponent); page.clickEvents.push(pageChangedEventHandler); } callback(event: Event, customEventData: string){ // The event here is a Touch Event object, and you can get the send node of the event by event.target const node = event.target as Node; const pageview = node.getComponent(PageViewComponent); console.log(customEventData); // foobar } } Method two By pageView.node.on('page-turning', ...) way to add. // Suppose we add event handling callbacks to the onLoad method of a component and perform event handling in the callback function: import { _decorator, Component, Event, Node, PageViewComponent } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { onLoad(){ this.pageView.node.on('page-turning', this.callback, this); } callback(pageView: PageViewComponent){ // The parameter of the callback is the PageView component. Note that events registered this way cannot pass customEventData } } "},"ui-system/components/editor/pageviewindicator.html":{"url":"ui-system/components/editor/pageviewindicator.html","title":"PageViewIndicator Reference","keywords":"","body":"PageviewIndicator Component Reference The PageViewIndicator component is used to display the current page number of the PageView and the page where the tag is currently located. Click the Add Component button at the bottom of the Inspector panel and select UI/PageViewIndicator to add the PageViewIndicator component to the node. PageviewIndicator Properties Properties Function Description CellSize The cellsize for each element Direction The location direction of PageViewIndicator, including HORIZONTAL and VERTICAL Spacing The distance between each element SpriteFrame The spriteFrame for each element Detailed Explanation PageviewIndicator is not used alone, it needs to be used with PageView to create a tag of the number of pages corresponding to the page. When you slide to a page, PageviewIndicator will highlight its corresponding mark. "},"ui-system/components/editor/ui-model.html":{"url":"ui-system/components/editor/ui-model.html","title":"UIModel Reference","keywords":"","body":"UIModel Component Reference UIModel is a renderer component with a conversion feature that converts 3D models from 3D render pipeline to 2D. This component supports rendering the 3D model and particle system in the UI, without the component, the 3D model and particle system nodes will not be rendered. The UIModel component is added by selecting the node in the Hierarchy panel with the ModelComponent or classes inherited from it, then clicking the Add Component button below the Inspector panel and selecting UI/Model. And the particles are added to the particle nodes. The usual structure is as below: "},"ui-system/components/editor/ui-opacity.html":{"url":"ui-system/components/editor/ui-opacity.html","title":"UIOpacity Reference","keywords":"","body":"UIOpacity Component References The UIOpacity Component records a transparency modification flag for the node, which is used to influence all the render nodes inside its sub tree. Normally it's used on a non render nodes, otherwise its opacity will be multiplied with the render component's opacity. The render nodes can set transparency individually by setting the alpha channel of color. UIOpacity Properties Properties Function Description Opacity transparency "},"ui-system/components/editor/block-input-enents.html":{"url":"ui-system/components/editor/block-input-enents.html","title":"BlockInputEvents Reference","keywords":"","body":"BlockInputEvents Component Reference The BlockInputEvents component will intercept all input events (mouse and touch events) in the bounding box of the node to which it belongs, preventing input from penetrating to the lower-level nodes, generally used in the background of the upper-level UI. When we make a pop-up UI dialog, the background of the dialog does not intercept events by default. That is, although the background is blocking the game scene, when clicked or touched on the background, the blocked game element underneath will still respond to the click event. At this point we can avoid this by simply adding the BlockInputEvents component to the node where the background is located. This component does not have any API interface and is effective when added directly to a scene. "},"scripting/":{"url":"scripting/","title":"脚本指南及事件机制","keywords":"","body":"脚本 Cocos Creator 3D 脚本用于实现用户定义的（游戏）行为。 脚本创建 脚本基础 语言支持 脚本执行顺序 cc 类 访问节点和其他组件 常用节点和组件接口 生命周期回调 创建和销毁节点 加载和切换场景 获取和加载资源 使用计时器 组件 组件顺序 属性参数参考 插件脚本 CCClass 进阶参考 添加 Log 废弃API 事件机制 作为引擎中极为常用的系统，我们提供了完整高效的事件系统给开发者使用，详情介绍请见： 事件机制 "},"scripting/setup.html":{"url":"scripting/setup.html","title":"脚本创建","keywords":"","body":"创建脚本 创建组件脚本 在 Cocos Creator 3D 中，脚本也是资源的一部分。你可以在资源编辑器中通过点击\"创建\"按钮来添加并选择 TypeScript 来创建一份组件脚本。此时你会在你的资源编辑器中得到一份新的脚本： 一份简单的组件脚本如下： import { _decorator, Component, Node } from 'cc'; const { ccclass, property } = _decorator; @ccclass('NewScript') export class NewScript extends Component { /* class member could be defined like this */ // dummy = ''; /* use `property` decorator if your want the member to be serializable */ // @property // serializableDummy = 0; start () { // Your initialization goes here. } // update (deltaTime: number) { // // Your update function goes here. // } } 请注意，我们更推荐用户使用 TypeScript 来编写脚本，但如果用户想要使用 JavaScript 来编写脚本的话，可以直接在操作系统的文件夹中创建 js 文件，也可以在代码编辑器中创建 js 文件。 编辑脚本 用户可根据自己的需求，选择自己喜爱的文本工具（如：Vim, Sublime Text, Web Storm, VSCode...）进行脚本编辑，请先到 设置 中进行设置。 通过双击脚本资源，可以直接打开脚本编辑器进行编辑。当编辑完脚本并保存，Cocos Creator 3D 会自动检测到脚本的改动，并迅速编译。 在代码编写之前，请先阅读 脚本基础 了解更多关于脚本的内容。 添加脚本到场景节点中 将脚本添加到场景节点中，实际上就是为这个节点添加一份组件。我们先将刚刚创建出来的 NewScript.js 重命名为 say-hello.js。然后选中我们希望添加的场景节点，此时该节点的属性会显示在 属性检查器 中。在 属性检查器 的最下方有一个 添加组件 的按钮，点击按钮并选择 添加用户脚本 -> say-hello 来添加我们刚刚编写的脚本组件。 如果一切顺利，你将会看到你的脚本显示在 属性检查器 中： 注意：用户也可以通过直接拖拽脚本资源到 属性检查器 的方式来添加脚本。 默认脚本编辑工具配置 继续前往 脚本基础。 "},"scripting/basic.html":{"url":"scripting/basic.html","title":"脚本基础","keywords":"","body":"运行环境 Cocos Creator 3D 引擎的 API 都存在于模块 cc中， 使用标准的 ES6 模块导入语法将其导入： import { Component, // 导入类 Component _decorator, // 导入命名空间 _decorator } from \"cc\"; import * as cc from \"cc\"; // 将整个 Cocos Creator 3D 模块导入为命名空间 Cocos Creator 3D @_decorator.ccclass(\"MyComponent\") export class MyComponent extends Component { public v = new cc.Vec3(); } 保留标识符 cc 注意，由于历史原因，cc 是 Cocos Creator 3D 保留使用的标识符， 其行为相当于在任何模块顶部已经定义了名为 cc 的对象。 因此，你不应该将 cc 用作任何全局对象的名称： /* const cc = {}; // 每个 Cocos Creator 3D 脚本都等价于在此处含有隐式定义 */ import * as cc from \"cc\"; // 错误：命名空间导入名称 cc 由 Cocos Creator 3D 保留使用 const cc = { x: 0 }; console.log(cc.x); // 错误：全局对象名称 cc 由 Cocos Creator 3D 保留使用 function f () { const cc = { x: 0 }; console.log(cc.x); // 正确：cc 可以用作局部对象的名称 const o = { cc: 0 }; console.log(o.cc); // 正确：cc 可以用作属性名 } console.log(cc, typeof cc); // 错误：行为是未定义的 "},"scripting/language-support.html":{"url":"scripting/language-support.html","title":"语言支持","keywords":"","body":"语言支持 JavaScript 语言特性 Creator 3D 支持的 JavaScript 语言规范为 ES6。 此外，以下几项更新于 ES6 规范的语言特性或提案仍旧在支持之列： 类字段 Promise 对象 可选链操作符 空值合并操作符 全局对象 globalThis 以下语言特性同样支持，但需要开启相关的编译选项： 异步函数 特别地，Creator 3D 目前支持 “Legacy” 装饰器提案，其用法和含义见 babel-plugin-proposal-decorators。 由于该 提案 仍处于 阶段2， 引擎暴露的所有装饰器相关功能接口都在以下划线开头的 _decorator 命名空间下。 运行环境 从用户的角度来说，Creator 3D 未绑定任何 JavaScript 实现。因此，Creator 3D 建议开发者严格依照 JavaScript 规范编写脚本，以获取更好的跨平台支持。 举例来说，当希望使用全局对象时，应当使用标准特性 globalThis： globalThis.blahBlah // 任何环境下 globalThis 一定存在 而非 window、global、self 或 this： typeof window // 可能是 'undefined' typeof global // 在浏览器环境下可能是 'undefined' 再如，Creator 3D 未提供 CommonJS 的模块系统，因此以下代码片段将带来问题： const blah = require('./blah-blah'); // 错误：`require` 是未定义的 module.exports = blah; // 错误：`module` 是未定义的 反之，应使用标准模块语法： import blah from './blah-blah'; export default blah; TypeScript Creator 3D 使用 babel 而非 tsc 编译 TypeScript 脚本。 特别地，使用了 @babel/plugin-transform-typescript 插件。基于此原因，TypeScript 的支持存在某些限制，以下列举出了一些重要的注意事项， 关于完整的说明，见 @babel/plugin-transform-typescript。 tsconfig.json 不会被读取； 隐含着 isolatedModules 选项，这意味着： 不支持 const enums； 导出声明中不应该导出 TypeScript 类型和接口。 不支持 export = 和 import =； 命名空间导出的变量必须声明为 const 而非 var 或 let； 同一命名空间的不同声明不会共享作用域，需要显式使用限定符。 编译时不会读取 tsconfig.json 意味着 tsconfig.json 的编译选项并不影响编译， 但存在例外，见 模块解析。 你仍然可以在项目中使用 tsconfig.json 以配合 IDE 实现类型检查等功能。 为了使得 IDE 的 TypeScript 检查功能 和 Creator 3D 行为兼容， 你需要额外注意一些事项，见 tsconfig。 模块解析 Creator 3D 使用 NodeJS 模块解析算法。 等价于如下的 tsconfig.json： {\"compilerOptions\": { \"moduleResolution\": \"node\" }} Typescript 的路径映射功能也受支持。 以下 tsconfig.json 选项将被读取并保持和 tsc 相同的语义： compilerOptions.baseUrl compilerOptions.paths "},"scripting/ccclass.html":{"url":"scripting/ccclass.html","title":"ccclass","keywords":"","body":"cc 类 将装饰器 ccclass 应用在类上时，此类称为 cc 类。 cc 类注入了额外的信息以控制 Cocos Creator 3D 对该类对象的序列化、编辑器对该类对象的展示等。 ccclass cc 类的各种特性是通过 ccclass(name) 的 cc 类选项参数来指定的。 cc 类名 选项 name 指定了 cc 类的名称。cc 类名应该是独一无二的。 当需要相应的 cc 类时，可以通过其 cc 类名来查找，例如： 序列化。 若对象是 cc 类对象， 则在序列化时将记录该对象的 cc 类名， 反序列化时将根据此名称找到相应的 cc 类进行序列化。 当 cc 类是组件类时，Node 通过可以组件类的 cc 类名查找该组件； cc 属性 当装饰器 property 应用在 cc 类的属性或访问器上时，此属性称为 cc 属性。 与 cc 类类似，cc 属性注入了额外的信息以控制 Cocos Creator 3D 对该属性的序列化、编辑器对该属性的展示等。 property cc 属性的各种特性是通过 property() 的 cc 属性选项参数来指定的。 cc 类型 选项 type 指定了属性的 cc 类型。 可以通过以下几种形式的参数指定类型： 构造函数。 构造函数所指定的类型就直接作为属性的 cc 类型。 注意，当 Javascript 内置构造函数 Number、String、Boolean 用作 cc 类型时将给出警告，并且将 分别视为 cc 类型 CCFloat、CCString、CCBoolean。 Cocos Creator 3D 内置属性类型标识。 CCInteger、CCFloat、CCBoolean、CCString 是内置属性类型标识。 CCInteger 声明类型为 Cocos Creator 3D 整数； CCFloat 声明类型为 Cocos Creator 3D 浮点数； CCString 声明类型为 Cocos Creator 3D 字符串； CCBoolean 声明类型为 Cocos Creator 3D 布尔值。 数组。 通过将构造函数、Cocos Creator 3D 内置属性类型标识或数组作为数组元素时， 属性被指定为 Cocos Creator 3D 数组。 例如 [CCInteger] 就将类型声明为元素为Cocos Creator 3D 整数的 Cocos Creator 3D 数组。 若属性未指定 cc 类型，Cocos Creator 3D 将从属性的默认值或初始化式的求值结果推导其 cc 类型： 若值的类型是 Javascript 原始类型 number、string、boolean， 则其 cc 类型分别为 Cocos Creator 3D 浮点数、Cocos Creator 3D 字符串、Cocos Creator 3D 布尔值。 否则，若值是对象类型，则相当于使用对象的构造函数指定了 cc 类型； 否则，属性的 cc 类型是未定义的。 一般地，仅需要在以下情况中需要显式地声明 cc 类型： 当需要将属性显示为整数时； 当属性的实际值可能是多个类型时。 关于 cc 类型如何影响 cc 属性以及对未定义 cc 类型的属性的处理，见： 属性类型 序列化参数 为了方便，额外提供了以下装饰器以快速声明 cc 类型： 等价于 @type(t) @property(t) @integer @property(CCInteger) @float @property(CCFloat) @string @property(CCString) @boolean @property(CCBoolean) 下列代码演示了不同 cc 类型 的 cc 属性的声明： import { _decorator, CCInteger, Node } from \"cc\"; const { ccclass, property, integer, float, boolean, string, type } = _decorator; @ccclass class MyClass { @integer // 声明属性 _id 的 cc 类型为 Cocos 整数 private _id = 0; @type(Node) // 声明属性 _targetNode 的 cc 类型为 Node private _targetNode: Node | null = null; @type([Node]) // 声明属性 _children 的 cc 类型为 Node 数组 private _children: Node[] = []; @property private _count = 0; // 未声明 cc 类型，从初始化式的求值结果推断为 Cocos 浮点数 @type(String) // 警告：不应该使用构造函数 String // 等价于 CCString private _name: string = ''; @property private _children2 = []; // 未声明 cc 类型，从初始化式的求值结果推断为：元素为未定义的 Cocos 数组 } 默认值 选项 default 指定了 cc 属性的默认值。 构造函数 通过 constructor 定义 CCClass 的构造函数使用 constructor 定义，为了保证反序列化能始终正确运行，constructor 不允许定义构造参数。 开发者如果确实需要使用构造参数，可以通过 arguments 获取，但要记得如果这个类会被序列化，必须保证构造参数都缺省的情况下仍然能 new 出对象。 判断类型 判断实例 需要做类型判断时，可以用 TypeScript 原生的 instanceof： class Sub extends Base { } let sub = new Sub(); console.log(sub instanceof Sub); //true console.log(sub instanceof Base); //true let base = new Base(); console.log(base instanceof Sub); // false 成员 实例变量 在构造函数中定义的实例变量不能被序列化，也不能在 属性检查器 中查看。 class Sprite{ //声明变量 url: string; id: number; constructor() { //赋值 this.url = \"\"; this.id = 0; } } 如果是私有的变量，建议在变量名前面添加下划线 _ 以示区分。 实例方法 实例方法请在原型对象中声明： class Sprite{ text: string; constructor() { this.text = \"this is sprite\" } // 声明一个名叫 \"print\" 的实例方法 print(){ console.log(this.text); } } let obj = new Sprite(); // 调用实例方法 obj.print(); 静态变量和静态方法 静态变量或静态方法可以用 statics 声明： class Sprite{ static count=0; static getBounds(){ } } 静态成员会被子类继承，继承时会将父类的静态变量浅拷贝给子类，因此： class Object{ static count= 11; static range: { w: 100, h: 100 } } class Sprite extends Object{ } console.log(Sprite.count); // 结果是 11，因为 count 继承自 Object 类 Sprite.range.w = 200; console.log(Object.range.w); // 结果是 200，因为 Sprite.range 和 Object.range 指向同一个对象 如果你不需要考虑继承，私有的静态成员也可以直接定义在类的外面： // 局部方法 doLoad(sprite){ // ... }; // 局部变量 let url = \"foo.png\"; class Sprite{ load() { this.url = url; doLoad(this); }; }; 继承 父构造函数 请注意，不论子类是否有定义构造函数，子类实例化前父类的构造函数都会被自动调用。 class Node { name: string; constructor(){ this.name = \"node\"; } } class Sprite extends Node{ constructor() { super(); // 子构造函数被调用前，父构造函数已经被调用过，所以 this.name 已经被初始化过了 console.log(this.name); // \"node\" // 重新设置 this.name this.name = \"sprite\"; } } let obj = new Sprite(); console.log(obj.name); // \"sprite\" 重写 所有成员方法都是虚方法，子类方法可以直接重写父类方法： class Shape{ getName() { return \"shape\"; } }; class Rect extends Shape{ getName () { return \"rect\"; } }; let obj = new Rect(); console.log(obj.getName()); // \"rect\" 属性 属性是特殊的实例变量，能够显示在 属性检查器 中，也能被序列化。 属性和构造函数 属性不用在构造函数里定义，在构造函数被调用前，属性已经被赋为默认值了，可以在构造函数内访问到。如果属性的默认值无法在定义 CCClass 时提供，需要在运行时才能获得，你也可以在构造函数中重新给属性赋默认值。 class Sprite { constructor() { this.num = 1; } @property({type:CCInteger}) private num = 0; } 不过要注意的是，属性被反序列化的过程紧接着发生在构造函数执行之后，因此构造函数中只能获得和修改属性的默认值，还无法获得和修改之前保存（序列化）的值。 属性参数 default参数 default 用于声明属性的默认值，声明了默认值的属性会被 CCClass 实现为成员变量。默认值只有在第一次创建对象的时候才会用到，也就是说修改默认值时，并不会改变已添加到场景里的组件的当前值。 当你在编辑器中添加了一个组件以后，再回到脚本中修改一个默认值的话，属性检查器 里面是看不到变化的。因为属性的当前值已经序列化到了场景中，不再是第一次创建时用到的默认值了。如果要强制把所有属性设回默认值，可以在 属性检查器 的组件菜单中选择 Reset。 default 允许设置为以下几种值类型： 任意 number, string 或 boolean 类型的值 null 或 undefined 继承自 ValueType 的子类，如 Vec3, Color 或 Rect 的实例化对象： @property({type:Vec3}) private pos = null; 空数组 [] 或空对象 {} visible参数 默认情况下，是否显示在 属性检查器 取决于属性名是否以下划线 _ 开头。如果以下划线开头，则默认不显示在 属性检查器，否则默认显示。 如果要强制显示在 属性检查器，可以设置 visible 参数为 true: @property({visible:true}) private _num = 0; 如果要强制隐藏，可以设置 visible 参数为 false: @property({visible:false}) private num = 0; serializable参数 指定了 default 默认值的属性默认情况下都会被序列化，序列化后就会将编辑器中设置好的值保存到场景等资源文件中，并且在加载场景时自动还原之前设置好的值。如果不想序列化，可以设置serializable: false。 @property({serializable:false}) private num = 0; type参数 当 default 不能提供足够详细的类型信息时，为了能在 属性检查器 显示正确的输入控件，就要用 type 显式声明具体的类型： 当默认值为 null 时，将 type 设置为指定类型的构造函数，这样 属性检查器 才知道应该显示一个 Node 控件。 @property({type:Node}) private enemy = null; 当默认值为数值（number）类型时，将 type 设置为 cc.Integer，用来表示这是一个整数，这样属性在 属性检查器 里就不能输入小数点。 @property({type:CCInteger}) private num = 0; 当默认值是一个枚举（Enum）时，由于枚举值本身其实也是一个数字（number），所以要将 type 设置为枚举类型，才能在 属性检查器 中显示为枚举下拉框。 enum A{ c, d } Enum(A); @ccclass(\"test\") export class test extends Component { @property({type:A}) accx:A=A.c; } override参数 所有属性都将被子类继承，如果子类要覆盖父类同名属性，需要显式设置 override 参数，否则会有重名警告： @property({type:CCString,tooltip:\"my id\",override:true}) private _id = \"\"; @property({displayName:\"Name\",override:true}) private _name = null; private get name(){ return this._name; } 更多参数内容请查阅 属性参数。 GetSet 方法 在属性中设置了 get 或 set 以后，访问属性的时候，就能触发预定义的 get 或 set 方法。 get 在属性中设置 get 方法： @property({type:CCInteger}) private _num = 0; private get num(){ return this._num; } get 方法可以返回任意类型的值。 这个属性同样能显示在 属性检查器 中，并且可以在包括构造函数内的所有代码里直接访问。 class Sprite{ _width: number; constructor() { this._width = 128; console.log(this.width); // 128 } @property({type:CCInteger}) private width = 0; private get width(){ return this._width; } }; 请注意： 设定了 get 以后，这个属性就不能被序列化，也不能指定默认值，但仍然可附带除了 default, serializable 外的大部分参数。 @property({type:CCInteger,tooltip: \"The width of sprite\"}) private _width = 0; private get width(){ return this._width; } get 属性本身是只读的，但返回的对象并不是只读的。用户使用代码依然可以修改对象内部的属性，例如： @property _num=0; private get num(){ return this._num; } start(){ consolo.log(this.num); } set 在属性中设置 set 方法： @property({type:CCInteger}) private _width = 0; set(value){ this._width = value } set 方法接收一个传入参数，这个参数可以是任意类型。 set 一般和 get 一起使用： @property _width=0; private get width(){ return this._width; } set(value){ this._width = value; } 如果没有和 get 一起定义，则 set 自身不能附带任何参数。 和 get 一样，设定了 set 以后，这个属性就不能被序列化，也不能指定默认值。 "},"scripting/reference/attributes.html":{"url":"scripting/reference/attributes.html","title":"属性参数参考","keywords":"","body":"属性参数 属性参数用来给已定义的属性附加元数据，类似于脚本语言的 Decorator 或者 C# 的 Attribute。 属性检查器相关参数 参数名 说明 类型 默认值 备注 type 限定属性的数据类型 (Any) undefined 详见 type 参数 visible 在 属性检视器 面板中显示或隐藏 boolean (注1) 详见 visible 参数 displayName 在 属性检视器 面板中显示为另一个名字 string undefined tooltip 在 属性检视器 面板中添加属性的 Tooltip string undefined multiline 在 属性检视器 面板中使用多行文本框 boolean false readonly 在 属性检视器 面板中只读 boolean false min 限定数值在编辑器中输入的最小值 number undefined max 限定数值在编辑器中输入的最大值 number undefined step 指定数值在编辑器中调节的步长 number undefined range 一次性设置 min, max, step [min, max, step] undefined step 值可选 slide 在 属性检视器 面板中显示为滑动条 boolean false 序列化相关参数 这些参数不能用于 get 方法 参数名 说明 类型 默认值 备注 serializable 序列化该属性 boolean true 详见 serializable 参数 formerlySerializedAs 指定之前序列化所用的字段名 string undefined 重命名属性时，声明这个参数来兼容之前序列化的数据 editorOnly 在导出项目前剔除该属性 boolean false 其它参数 参数名 说明 类型 默认值 备注 default 定义属性的默认值 (Any) undefined 详见 default 参数 notify 当属性被赋值时触发指定方法 function (oldValue) {} undefined 需要定义 default 属性并且不能用于数组不支持 ES6 定义方式 override 当重写父类属性时需要定义该参数为 true boolean false 详见 override 参数 animatable 该属性是否能被动画编辑器修改 boolean undefined 注1: visible 的默认值取决于属性名。当属性名以下划线 _ 开头时，默认隐藏，否则默认显示。 返回 脚本开发。 "},"scripting/access-node-component.html":{"url":"scripting/access-node-component.html","title":"访问节点和其他组件","keywords":"","body":"Access nodes and components You can modify nodes and components in the Property Inspector, or dynamically in a script. The advantage of modifying dynamically is that attributes can be continuously modified, either quickly or over a period of time to achieve a gradual effect. Scripts can also respond to player input, and can modify, create, or destroy nodes. Scripts also allow a variety of game logic to be implemented. To achieve these effects, you need to get the node or component you want to modify in the script first. Concepts This document introduces the following concepts: Obtaining the node where the component is located Obtaining other components Use the Property Inspector to set-up nodes and components Find child nodes Global node lookup Access values in existing variables Obtain the node where the component is located Obtaining the node where the component is located is as simple as accessing the this.node variable in the component method. Example: start(){ let node = this.node; node.setPosition(0.0,0.0,0.0); } Obtaining other components It is often required to obtain other components on the same node. Using the getComponent API will help find the component. Example: import { _decorator, Component, LabelComponent } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"test\") export class test extends Component { private label: any = null start(){ this.label = this.getComponent(LabelComponent); let text = this.name + 'started'; // Change the text in Label Component this.label.string = text; } } You can also pass in a class name to getComponent. For user-defined components, the class name is the file name of the script, and is case sensitive. For example, the component declared in SinRotate.ts, the class name is SinRotate. Example: let rotate = this.getComponent(\"SinRotate\"); getComponent is also available from a node. It works exactly the same. Example: start() { console.log( this.node.getComponent(LabelComponent) === this.getComponent(LabelComponent) ); // true } If a component cannot be found on a node, getComponent will return null. Accessing the value of null, it will throw a TypeError error at runtime. To decide whether a component exists, please do a sanity check. Example: import { _decorator, Component, LabelComponent } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"test\") export class test extends Component { private label: any =null; start() { this.label = this.getComponent(LabelComponent); if (this.label) { this.label.string = \"Hello\"; } else { console.error(\"Something wrong?\"); } } } Obtaining other nodes and their components It is usually not enough to only be able to access the node's own components. Scripts usually need to interact between multiple nodes. For example, a cannon that automatically targets a player needs to constantly obtain the latest position of the player. Cocos Creator 3D provides some different methods to obtain other nodes and/or other components. Setting a node using Property Inspector The most direct way is to set the object you need in the Property Inspector. Taking the node as an example, this only needs to declare an attribute of type Node in the script. Example: // Cannon.ts import { _decorator, Component, Node } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"Cannon\") export class Cannon extends Component { // Declare Player attribute @property({type:Node}) private player = null; } This code declares a player property in properties with a default value of null, and specifies its object type as type Node. This is equivalent to declaring public Node player = null; in other languages. After the script is compiled, this component looks like this in the Property Inspector: Then, you can drag any node on the Hierarchy Manager to this Player control. In this way, the player property will be set successfully, and can be accessed directly in the script. Example: // Cannon.ts import { _decorator, Component, Node } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"Cannon\") export class Cannon extends Component { @property({type:Node}) private player = null; start() { console.log(\"The player is \" + this.player.name); } } Using the Property Inspector to set a Component In the above example, if you declare the type of the property as the Player component, when you drag the Player Node to the Property Inspector, the Player property will be set to the Player component in this node. It is then not necessary to call getComponent yourself. Example: // Cannon.ts import { _decorator, Component } from \"cc\"; const { ccclass, property } = _decorator; import { Player } from \"Player\"; @ccclass(\"Cannon\") export class Cannon extends Component { @property({type:Player}) private player = null; start(){ let PlayerComp = this.player; } } Tthe default value of an attribute can be changed from null to an array []. This allows setting multiple objects in the Property Inspector at the same time. However, if you need to dynamically obtain other objects at runtime, you also need to use the search method described below. Finding child nodes Sometimes, there are many objects of the same type in the game scene, such as turrets, enemies, and special effects. Usually a global script manages them uniformly. If the Property Inspector is used to associate them one by one with this script, the work will be tedious. In-order to better manage these objects in a unified way, they can be placed under a unified parent object. Then all of the child objects can be obtained through the parent object. Example: // CannonManager.ts import { _decorator, Component, Node } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"CannonManager\") export class CannonManager extends Component { start() { let cannons = this.node.children; //... } } getChildByName can also be used. Example: this.node.getChildByName(\"Cannon 01\"); 如果子节点的层次较深，你还可以使用 find，find 将根据传入的路径进行逐级查找： find(\"Cannon 01/Barrel/SFX\", this.node); 全局名字查找 当 find 只传入第一个参数时，将从场景根节点开始逐级查找： this.backNode = find(\"Canvas/Menu/Back\"); 访问已有变量里的值 如果你已经在一个地方保存了节点或组件的引用，你也可以直接访问它们 通过模块访问 你可以使用 import 来实现脚本的跨文件操作，让我们看个示例： // Global.ts, now the filename matters import { _decorator, Component, Node } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"Global\") export class Global extends Component { public static backNode:any=null; public static backLabel:any=null; } 每个脚本都能用 import{ } from + 文件名(不含路径) 来获取到对方 exports 的对象。 // Back.ts import { _decorator, Component, Node, LabelComponent } from \"cc\"; const { ccclass, property } = _decorator; // this feels more safe since you know where the object comes from import{Global}from \"./Global\"; @ccclass(\"Back\") export class Back extends Component { onLoad(){ Global.backNode=this.node; Global.backLabel=this.getComponent(LabelComponent); } } // AnyScript.ts import { _decorator, Component, Node } from \"cc\"; const { ccclass, property } = _decorator; // this feels more safe since you know where the object comes from import{Global}from \"./Global\"; @ccclass(\"AnyScript\") export class AnyScript extends Component { start () { var text = \"Back\"; Global.backLabel.string=text; } } 继续前往 常用节点和组件接口。 "},"scripting/basic-node-api.html":{"url":"scripting/basic-node-api.html","title":"常用节点和组件接口","keywords":"","body":"常用节点和组件接口 在通过 访问节点和组件 介绍的方法获取到节点或组件实例后，这篇文章将会介绍通过节点和组件实例可以通过哪些常用接口实现我们需要的种种效果和操作。这一篇也可以认为是 Node 和 Component 类的 API 阅读指南，可以配合 API 一起学习理解。 节点状态和层级操作 假设我们在一个组件脚本中，通过 this.node 访问当前脚本所在节点。 激活/关闭节点 节点默认是激活的，我们可以在代码中设置它的激活状态，方法是设置节点的 active 属性： this.node.active = false; 设置 active 属性和在编辑器中切换节点的激活、关闭状态，效果是一样的。当一个节点是关闭状态时，它的所有组件都将被禁用。同时，它所有子节点，以及子节点上的组件也会跟着被禁用。要注意的是，子节点被禁用时，并不会改变它们的 active 属性，因此当父节点重新激活的时候它们就会回到原来的状态。 也就是说，active 表示的其实是该节点 自身的 激活状态，而这个节点 当前 是否可被激活则取决于它的父节点。并且如果它不在当前场景中，它也无法被激活。我们可以通过节点上的只读属性 activeInHierarchy 来判断它当前是否已经激活。 this.node.active = true; 若节点原先就处于 可被激活 状态，修改 active 为 true 就会立即触发激活操作： 在场景中重新激活该节点和节点下所有 active 为 true 的子节点 该节点和所有子节点上的所有组件都会被启用，他们中的 update 方法之后每帧会执行 这些组件上如果有 onEnable 方法，这些方法将被执行 this.node.active = false; 如该节点原先就已经被激活，修改 active 为 false 就会立即触发关闭操作： 在场景中隐藏该节点和节点下的所有子节点 该节点和所有子节点上的所有组件都将被禁用，也就是不会再执行这些组件中的 update 中的代码 这些组件上如果有 onDisable 方法，这些方法将被执行 更改节点的父节点 假设父节点为 parentNode，子节点为 this.node 您可以： this.node.parent = parentNode; 或 this.node.removeFromParent(false); parentNode.addChild(this.node); 这两种方法是等价的。 注意： removeFromParent 通常需要传入一个 false，否则默认会清空节点上绑定的事件和 action 等。 通过 创建和销毁节点 介绍的方法创建出新节点后，要为节点设置一个父节点才能正确完成节点的初始化。 索引节点的子节点 this.node.children 将返回节点的所有子节点数组。 this.node.childrenCount 将返回节点的子节点数量。 注意 以上两个 API 都只会返回节点的直接子节点，不会返回子节点的子节点。 更改节点的变换（位置、旋转、缩放） 更改节点位置 使用 setPosition 方法： this.node.setPosition(100, 50, 100); this.node.setPosition(new Vec3(100,50,100)); 设置 position 变量： this.node.position = new Vec3(100,50,100); 以上两种用法等价。 更改节点旋转 this.node.setRotation(90,90,90); 或通过欧拉角设置本地旋转 this.node.setRotationFromEuler(90,90,90); 更改节点缩放 this.node.setScale(2,2,2); 常用组件接口 Component 是所有组件的基类，任何组件都包括如下的常见接口（假设我们在该组件的脚本中，以 this 指代本组件）： this.node：该组件所属的节点实例 this.enabled：是否每帧执行该组件的 update 方法，同时也用来控制渲染组件是否显示 update(deltaTime: number)：作为组件的成员方法，在组件的 enabled 属性为 true 时，其中的代码会每帧执行 onLoad()：组件所在节点进行初始化时（节点添加到节点树时）执行 start()：会在该组件第一次 update 之前执行，通常用于需要在所有组件的 onLoad 初始化完毕后执行的逻辑 更多组件成员方法请继续参考 生命周期回调 文档。 "},"scripting/life-cycle-callbacks.html":{"url":"scripting/life-cycle-callbacks.html","title":"生命周期回调","keywords":"","body":"﻿# 生命周期回调 Cocos Creator 3D为组件脚本提供了生命周期的回调函数。用户只要定义特定的回调函数，Creator 3D就会在特定的时期自动执行相关脚本，用户不需要手工调用它们。 目前提供给用户的生命周期回调函数主要有： onLoad start update lateUpdate onDestroy onEnable onDisable onLoad 组件脚本的初始化阶段，我们提供了 onLoad 回调函数。onLoad 回调会在节点首次激活时触发，比如所在的场景被载入，或者所在节点被激活的情况下。在 onLoad 阶段，保证了你可以获取到场景中的其他节点，以及节点关联的资源数据。onLoad 总是会在任何 start 方法调用前执行，这能用于安排脚本的初始化顺序。通常我们会在 onLoad 阶段去做一些初始化相关的操作。例如： import { _decorator, Component, Node, SpriteFrame, find } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"test\") export class test extends Component { @property({type:SpriteFrame}) bulletSprite=null; @property({type:Node}) gun=null; _bulletRect=null; onLoad(){ this._bulletRect=this.bulletSprite.getRect(); this.gun = find('hand/weapon'),this.node; } } start start 回调函数会在组件第一次激活前，也就是第一次执行 update 之前触发。start 通常用于初始化一些中间状态的数据，这些数据可能在 update 时会发生改变，并且被频繁的 enable 和 disable。 import { _decorator, Component, Node } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"starttest\") export class starttest extends Component { private _timer: number = 0.0; start () { this._timer = 1.0; } update (deltaTime: number) { this._timer += deltaTime; if(this._timer >= 10.0){ console.log('I am done!'); this.enabled = false; } } } update 游戏开发的一个关键点是在每一帧渲染前更新物体的行为，状态和方位。这些更新操作通常都放在 update 回调中。 import { _decorator, Component, Node } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"updatetest\") export class updatetest extends Component { update (deltaTime: number) { this.node.setPosition(0.0,40.0*deltaTime,0.0); } } lateUpdate update 会在所有动画更新前执行，但如果我们要在动效（如动画、粒子、物理等）更新之后才进行一些额外操作，或者希望在所有组件的 update 都执行完之后才进行其它操作，那就需要用到 lateUpdate 回调。 import { _decorator, Component, Node } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"lateupdatetest\") export class lateupdatetest extends Component { lateUpdate (deltaTime: number) { this.node.setPosition(0.0,50,0.0); } } onEnable 当组件的 enabled 属性从 false 变为 true 时，或者所在节点的 active 属性从 false 变为 true 时，会激活 onEnable 回调。倘若节点第一次被创建且 enabled 为 true，则会在 onLoad 之后，start 之前被调用。 onDisable 当组件的 enabled 属性从 true 变为 false 时，或者所在节点的 active 属性从 true 变为 false 时，会激活 onDisable 回调。 onDestroy 当组件或者所在节点调用了 destroy()，则会调用 onDestroy 回调，并在当帧结束时统一回收组件。 继续前往 创建和销毁节点。 "},"scripting/create-destroy.html":{"url":"scripting/create-destroy.html","title":"创建和销毁节点","keywords":"","body":"创建和销毁节点 创建新节点 除了通过场景编辑器创建节点外，我们也可以在脚本中动态创建节点。通过 new Node() 并将它加入到场景中，可以实现整个创建过程。 以下是一个简单的例子: import { _decorator, Component, Node } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"test\") export class test extends Component { start(){ let node =new Node('box'); node.setPosition(0,0,-10); } } 克隆已有节点 有时我们希望动态的克隆场景中的已有节点，我们可以通过 instantiate 方法完成。使用方法如下： import { _decorator, Component, Node,instantiate, director } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"test\") export class test extends Component { @property({type:Node}) private target: Node = null; start(){ let scene = director.getScene(); let node = instantiate(this.target); node.parent = scene; node.setPosition(0, 0,-10); } } 创建预制节点 和克隆已有节点相似，你可以设置一个预制（Prefab）并通过 instantiate 生成节点。使用方法如下： import { _decorator, Component, Prefab, instantiate, director } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"test\") export class test extends Component { @property({type:Prefab}) private target: Prefab = null; start(){ let scene = director.getScene(); let node = instantiate(this.target); node.parent = scene; node.setPosition(0,0,0); } } 销毁节点 通过 node.destroy() 函数，可以销毁节点。值得一提的是，销毁节点并不会立刻被移除，而是在当前帧逻辑更新结束后，统一执行。当一个节点销毁后，该节点就处于无效状态，可以通过 isValid 判断当前节点是否已经被销毁。 使用方法如下： import { _decorator, Component, Node } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"test\") export class test extends Component { @property({type:Node}) private target: Node = null; private positionz: number = -20; start(){ // 5秒后销毁节点 setTimeout(function () { this.target.destroy(); }.bind(this), 5000); } update(deltaTime: number){ console.info(this.target.isValid); this.positionz += 1*deltaTime; if (this.target.isValid) { this.target.setPosition(0.0,0.0,this.positionz); } } } destroy 和 removeFromParent 的区别 调用一个节点的 removeFromParent 后，它不一定就能完全从内存中释放，因为有可能由于一些逻辑上的问题，导致程序中仍然引用到了这个对象。因此如果一个节点不再使用了，请直接调用它的 destroy 而不是 removeFromParent。destroy 不但会激活组件上的 onDestroy，还会降低内存泄露的几率，同时减轻内存泄露时的后果。 总之，如果一个节点不再使用，destroy 就对了，不需要 removeFromParent 也不需要设置 parent 为 null 哈。 继续前往 资源管理/加载和切换场景 说明文档。 "},"scripting/scene-managing.html":{"url":"scripting/scene-managing.html","title":"加载和切换场景","keywords":"","body":"加载和切换场景 在 Cocos Creator 3D中，我们使用场景文件名（不包含扩展名）来索引指代场景。并通过以下接口进行加载和切换操作： director.loadScene(\"MyScene\"); 通过常驻节点进行场景资源管理和参数传递 引擎同时只会运行一个场景，当切换场景时，默认会将场景内所有节点和其他实例销毁。如果我们需要用一个组件控制所有场景的加载，或在场景之间传递参数数据，就需要将该组件所在节点标记为「常驻节点」，使它在场景切换时不被自动销毁，常驻内存。我们使用以下接口： game.addPersistRootNode(myNode); 上面的接口会将 myNode 变为常驻节点，这样挂在上面的组件都可以在场景之间持续作用，我们可以用这样的方法来储存玩家信息，或下一个场景初始化时需要的各种数据。 需要注意的是，目标节点必须为位于层级的根节点，否则设置无效。 如果要取消一个节点的常驻属性： game.removePersistRootNode(myNode); 需要注意的是上面的 API 并不会立即销毁指定节点，只是将节点还原为可在场景切换时销毁的节点。 场景加载回调 加载场景时，可以附加一个参数用来指定场景加载后的回调函数： director.loadScene(\"MyScene\", onSceneLaunched); 上一行里 onSceneLaunched 就是声明在本脚本中的一个回调函数，在场景加载后可以用来进一步的进行初始化或数据传递的操作。 由于回调函数只能写在本脚本中，所以场景加载回调通常用来配合常驻节点，在常驻节点上挂载的脚本中使用。 预加载场景 director.loadScene 会在加载场景之后自动切换运行新场景，有些时候我们需要在后台静默加载新场景，并在加载完成后手动进行切换。那就可以预先使用 preloadScene 接口对场景进行预加载： director.preloadScene(\"table\", function () { console.log(\"Next scene preloaded\"); }); 之后在合适的时间调用 loadScene, 就可以真正切换场景。 director.loadScene(\"table\"); 就算预加载还没完成，你也可以直接调用 director.loadScene，预加载完成后场景就会启动。 继续前往 获取和加载资源 说明文档。 "},"scripting/load-assets.html":{"url":"scripting/load-assets.html","title":"获取和加载资源","keywords":"","body":"Obtaining and Loading assets Cocos Creator 3D uses the same asset management mechanism as Cocos Creator. In this section, we will introduce: Declaration of asset attributes How to set assets in the Property Inspector Loading assets dynamically Loading remote assets and device assets Dependence and releasing assets Declaration of asset attributes In Cocos Creator 3D, all types that inherit from Asset are collectively called assets, such asTexture2D, SpriteFrame,AnimationClip, Prefab, etc. Loading assets is unified and interdependent assets can be automatically preloaded. For example: when the engine is loading the scene, it will automatically load the assets associated with the scene first. If these assets are associated with other assets, the other will be loaded first, and the scene loading will end after all loading is completed. You can define an Asset property in the script like this: //test.ts import { _decorator, Component, Node, SpriteFrame } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"test\") export class test extends Component { @property({type: SpriteFrame}) private spriteFrame: SpriteFrame = null; } How to set Assets in the Property inspector As long as the type is defined in the script, you can easily set the asset directly in the Property inspector. Suppose, we create a script like this: //test.ts import { _decorator, Component, Node, SpriteFrame, Texture2D } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"test\") export class test extends Component { @property({type: Texture2D}) private texture: Texture2D = null; @property({type: SpriteFrame}) private spriteFrame: SpriteFrame = null; } After adding it to a node, it looks like this in the Property Inspector: Next, we drag a Texture and a SpriteFrame from the Assets Panel into the corresponding properties of the Property Inspector: Resulting in： This allows you to get and set assets directly within a script: start () { let spriteFrame = this.spriteFrame; let texture = this.texture; } Although it is intuitive to set assets in the Attributes Inspector, the assets can only be set in the Scene, in advance. This means there is no way to switch assets dynamically. If you need to switch assets dynamically, take a look at this next section on Dynamic loading. Dynamic loading We have example for asset loading, please see these test-case-3d(AssetLoading) There are two points to note when loading assets dynamically. First, the resources folder needs to be created manually inside the resources folder and must be located in the root directory, like this: All assets that need to be dynamically loaded through a script must be placed in the resources folder or its subfolders. Note: The assets in the folder can refer to other assets outside the folder, and can also be referenced by external scenes or assets. When the project is built, except for the scenes that have been checked in the Build panel, all assets in the resources folder, together with the assets outside the resources folder that are dependent by necessary assets, other assets will be deleted. Note: If an asset is only depended on by other assets and does not need to be loaded directly by loader.loadRes, then please do not put it in the resources folder. Doing so, the size of the package body and settings.js will be increased, and the useless assets in the resources folder will not be automatically removed during the build process. At the same time, during the build process, JSON's automatic merge strategy will also be affected, and it is not possible to merge fragmented JSON as much as possible. Second, The load process of Cocos Creator 3D is always asynchronous. You need to get the loaded assets in the callback function. This is done because there is no other asset preload list except the assets associated with the scene, and dynamically loaded assets that are truly dynamically loaded. Loading Asset Dynamically Cocos Creator 3D provides loader.loadRes API to specifically load those assets located in the assets directory. Unlike loader.load, loadRes can only load a single asset at a time. When calling, you only need to pass in the path of the relative assets, and the end of the path cannot include the file extension. // load the Prefab loader.loadRes(\"test assets/prefab\", Prefab , (err: any, prefab: Prefab) => { const newNode = instantiate(prefab); director.getScene().addChild(newNode); }); // load the AnimationClip loader.loadRes(\"test assets/anim\", AnimationClip , (err: any, clip: AnimationClip) => { this.node.getComponent(AnimationComponent).addClip(clip, \"anim\"); }); Loading a SpriteFrame or a Texture2D After the image is set to a spriteframe, texture or other image types, an asset of the corresponding type will be generated in the Assets Panel. But if you load test assets/image directly, the resulting type will be an ImageAsset. You must add the asset type, after the image path, in-order to load the sub-asset of the corresponding asset generated by the image. If you are not sure about the path of the corresponding asset, you can view it in settings.js when running or previewing: // load a SpriteFrame，image is ImageAsset，spriteFrame is image/spriteFrame, texture is image/texture loader.loadRes(\"test assets/image/spriteFrame\", SpriteFrame ,(err: any, spriteFrame: SpriteFrame) => { this.node.getComponent(SpriteComponent).spriteFrame = spriteFrame; }); // load a texture loader.loadRes(\"test assets/image/texture\", Texture2D ,(err: any, texture: Texture2D) => { const spriteFrame = new SpriteFrame(); spriteFrame.texture = texture; this.node.getComponent(SpriteComponent).spriteFrame = spriteFrame; }); If a type parameter is specified, an asset of the specified type will be found under the path. When you need to get a \"sub-asset\" (such as getting the sub-asset SpriteFrame of ImageAsset), you need to specify the path of the sub-asset. Loading a SpriteFrame from Atlas For an atlas imported from a third-party tool such as Texturepacker, if you want to load the SpriteFrame, you can only load the atlas first, and then get the SpriteFrame. This is a special case. // load SpriteAtlas, and get one of them SpriteFrame // Note Atlas resource file (plist) usually of the same name and a picture file (PNG) placed in a directory, So should need to in the second parameter specifies the resource type. loader.loadRes(\"test assets/atlas.plist\", SpriteAtlas, (err: any, atlas: SpriteAtlas) => { const frame = atlas.getSpriteFrame('sheep_run_0'); this.node.getComponent(SpriteComponent)..spriteFrame = frame; }); Asset release If a single asset loaded by loadRes, needs to be released, you can call loader.releaseRes, and releaseRes can pass in the same path and type parameters asloadRes. loader.releaseRes(\"test assets/image/spriteFrame\"); loader.releaseRes(\"test assets/anim\"); Alternatively, you can use loader.releaseAsset to release a specific instance of an aseset. loader.releaseAsset(spriteFrame); Special note, assets dynamically loaded by using cc.loader.loadRes or cc.loader.loadResDir, will not be release when scene switching, remain not released by default. Use setAutoRelease to change the default behavior on a single asset, to force preserve or release specified asset when scene switching. loader.setAutoRelease(spriteFrame, true); Batch loading of assets loader.loadResDir can load multiple assets in the same path: // load the test assets all assets in the directory loader.loadResDir(\"test assets\", (err: any, assets: Array) => { // ... }); // load the test assets, all SpriteFrame in the directory, // and get their path loader.loadResDir(\"test assets\", SpriteFrame, (err: any, assets: Array, urls: Array) => { // ... }); Loading remote and local device assets Cocos Creator 3D supports loading remote texture assets. This is a friendly approach for loading textures that need to be requested from the server, such as user avatars. It should be noted that this requires developers to call loader.load directly. At the same time, if the user downloads the assets to the local device storage in other ways, they also need to use the same API to load. The APIs such as loadRes above are only applicable to the assets in the application package and the hot-updated local assets. Here is the usage of this API: // remote url of image asset const remoteUrl1 = \"http://unknown.org/someres.png\"; loader.load(remoteUrl1, (err: any, image: ImageAsset) => { // Use imageAsset to create sprite frame or texture }); // Remote URL without image suffix, you must specify the type // of remote image file const remoteUrl2 = \"http://unknown.org/emoji?id=124982374\"; loader.load({url: remoteUrl2, type: 'png'}, (err: any, image: ImageAsset) => { // Use imageAsset to create sprite frame }); There are still some restrictions on using manual asset loading. The ones that have a greater impact on developers are: This loading method only supports native asset types such as images, sounds, text, and does not support direct loading and parsing of assets such as SpriteFrame, SpriteAtlas, and Tilemap (these require AssetBundle support in future versions) Remote loading on the web side is restricted by the browser's CORS cross domain policy. If the other server prohibits cross domain access, then it will fail to load, and due to the limitation of WebGL security policies, even if the other server allows the http request to succeed, it cannot be rendered. Dependency and releasing of assets After loading the assets, all assets will be temporarily cached in the loader to avoid sending meaningless http requests when the assets are repeatedly loaded. Of course, the cached content will occupy memory, and some assets may no longer be needed by the user. If you want to release them, here are some things to note when doing asset releasing. First and foremost: assets are interdependent. For example, in the figure below, the Node in the Prefab asset contains the Sprite component. The Sprite component depends on the SpriteFrame, the SpriteFrame asset depends on the Texture asset, and as mentioned the Prefab , SpriteFrame, and Texture assets are cached by the loader. The advantage of this is that there may be another SpriteAtlas asset that depends on the same SpriteFrame and Texture. In this case, when you manually load this SpriteAtlas, you do not need to re-request the texture asset, the loader will automatically use the assets in the cache. After understanding the mutual reference of assets, the problem of asset releasing is also looming. When you choose to release a Prefab, we will not automatically release other assets it depends on. Why? There may be other uses for these dependent assets . When users release assets, they often ask us, why do I release the assets, but the memory usage is still high? The reason is that the basic assets, such as textures that actually occupy memory, will not be released when you release Prefabs or a SpriteAtlas. Second: Object references cannot be tracked in JavaScript. In JavaScript, due to its weakly typed nature, does not include memory management functions. The memory of all objects is managed by the garbage collection mechanism. This causes the JavaScript layer logic to never know when an object will be released. The engine cannot manage external object references to assets through a mechanism similar to reference counting. The engine cannot count whether assets are no longer needed. The current design of the loader requires the user to manage the assets according to the game logic. The user can decide that certain assets and the assets it depends on are no longer needed and immediately release their cache in the loader. You can also choose to prevent some shared assets from being released when releasing dependent assets. Here is a simple example: // Release a texture directly loader.release(texture); // release a prefab and all assets it depends on const deps = loader.getDependsRecursively('prefabs/sample'); loader.release(deps); // If there are some assets in this prefab that are shared with other // parts of the scene, you don't want them to be released, you can delete // this asset from the dependency list. const deps = loader.getDependsRecursively('prefabs/sample'); const index = deps.indexOf(texture2d._uuid); if (index !== -1) deps.splice(index, 1); loader.release(deps); One last note: JavaScript's garbage collection is deferred. Imagine a situation where, after you released the loader's reference to an asset, the game logic requests the asset again. At this point, garbage collection has not started (the timing of garbage collection is uncontrollable), or somewhere in your game logic still holds a reference to this old asset. This means that this asset still exists in memory, but the loader has no access, it will be reloaded. This causes this asset to have two identical copies in memory, wasting memory. This isn't a problem for just one asset, but if there are many similar assets or assets being loaded more than once, may put a strain on the available memory. If your memory runs high please carefully check the game logic for leaks. If not, the garbage collection mechanism will normally reclaim the memory. Continue to the Event documentation. "},"scripting/scheduler.html":{"url":"scripting/scheduler.html","title":"使用计时器","keywords":"","body":"使用计时器 在 Cocos Creator 3D中，我们为组件提供了方便的计时器。 也许有人会认为 setTimeout 和 setInterval 就足够了，开发者当然可以使用这两个函数，不过我们更推荐使用计时器，因为它更加强大灵活，和组件也结合得更好！ 下面来看看它的具体使用方式： 开始一个计时器 this.schedule(function() { // 这里的 this 指向 component this.doSomething(); }, 5); 上面这个计时器将每隔 5s 执行一次。 更灵活的计时器 // 以秒为单位的时间间隔 let interval = 5; // 重复次数 let repeat = 3; // 开始延时 let delay = 10; this.schedule(function() { // 这里的 this 指向 component this.doSomething(); }, interval, repeat, delay); 上面的计时器将在10秒后开始计时，每5秒执行一次回调，重复3次。 只执行一次的计时器（快捷方式） this.scheduleOnce(function() { // 这里的 this 指向 component this.doSomething(); }, 2); 上面的计时器将在两秒后执行一次回调函数，之后就停止计时。 取消计时器 开发者可以使用回调函数本身来取消计时器： this.count = 0; this.callback = function () { if (this.count == 5) { // 在第六次执行回调时取消这个计时器 this.unschedule(this.callback); } this.doSomething(); this.count++; } this.schedule(this.callback, 1); 注意：组件的计时器调用回调时，会将回调的 this 指定为组件本身，因此回调中可以直接使用 this。 下面是 Component 中所有关于计时器的函数： schedule：开始一个计时器 scheduleOnce：开始一个只执行一次的计时器 unschedule：取消一个计时器 unscheduleAllCallbacks：取消这个组件的所有计时器 这些 API 的详细描述都可以在我们的 API 文档中找到。 除此之外，如果需要每一帧都执行一个函数，请直接在 Component 中添加 update 函数，这个函数将默认被每帧调用，这在 生命周期文档 中有详细描述。 注意：Node 不包含计时器相关 API "},"scripting/component.html":{"url":"scripting/component.html","title":"组件","keywords":"","body":"组件 所有继承自 Component 的类都称为组件类， 其对象称为组件，实现了 Cocos Creator 3D EC 系统中的组件概念。 组件类必须是 cc 类。 import { Component } from \"cc\"; @ccclass(\"MyComponent\") class MyComponent extends Component { } 组件的创建和销毁 组件的生命周期完全由结点操控。 与普通类对象不同，组件不能由构造函数创建： const component = new MyComponent(); // 错误：组件无法由构造函数创建 相反地，组件必须由结点来创建： const myComponent = node.addComponent(MyComponent); 在此之后，称组件附加到了结点上。 调用 Node.removeComponent 方法移除指定的组件并将其销毁。 组件总是附加在某个结点上，除了： 在组件类的构造函数结束之前； 组件从结点上移除之后。 import { Component } from \"cc\"; @ccclass(\"MyComponent\") class MyComponent extends Component { constructor () { console.log(this.node.name); // 错误：组件并未附加到结点上 } public printNodeName () { console.log(this.node.name); } } // >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> const myComponent = node.addComponent(MyComponent); myComponent.printNodeName(); // 正确 node.removeComponent(); myComponent.printNodeName(); // 错误：组件并未附加到结点上 "},"scripting/execution-order-component.html":{"url":"scripting/execution-order-component.html","title":"组件顺序","keywords":"","body":"脚本执行顺序 使用统一的控制脚本来初始化其他脚本 一般我都会有一个 Game.ts 的脚本作为总的控制脚本，假如我还有 Player.ts, Enemy.ts, Menu.ts 三个组件，那么他们的初始化过程是这样的： // Game.ts import { _decorator, Component, Node } from \"cc\"; const { ccclass, property } = _decorator; import { Player } from './Player'; import { Enemy } from './Enemy'; import { Menu }from './Menu'; @ccclass(\"Game\") export class Game extends Component { private player =Player; private enemy =Enemy; private menu =Menu; onLoad(){ this.player.init(); this.enemy.init(); this.menu.init(); } } 其中在 Player.ts, Enemy.ts 和 Menu.ts 中需要实现 init 方法，并将初始化逻辑放进去。这样我们就可以保证 Player, Enemy 和 Menu 的初始化顺序。 在 Update 中用自定义方法控制更新顺序 同理如果要保证以上三个脚本的每帧更新顺序，我们也可以将分散在每个脚本里的 update 替换成自己定义的方法： //Player.ts static updataPlayer(deltaTime: number) { } 然后在 Game.ts 脚本的 update 里调用这些方法： // Game.ts update (deltaTime: number) { this.player.updataPlayer(deltaTime); this.enemy.updataEnemy(deltaTime); this.menu.updateMenu(deltaTime); } 控制同一个节点上的组件执行顺序 在同一个节点上的组件脚本执行顺序，可以通过组件在 属性检查器 里的排列顺序来控制。排列在上的组件会先于排列在下的组件执行。我们可以通过组件右上角的齿轮按钮里的 Move Up 和 Move Down 菜单来调整组件的排列顺序和执行顺序。 假如我们有两个组件 CompA 和 CompB，他们的内容分别是： // CompA.ts import { _decorator, Component, Node } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"CompA\") export class CompA extends Component { onLoad(){ console.log('CompA onLoad!'); } start () { console.log('CompA start!'); } update (deltaTime: number) { console.log('CompA update!'); } } // CompB.ts import { _decorator, Component, Node } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"CompB\") export class CompB extends Component { onLoad(){ console.log('CompB onLoad!'); } start () { console.log('CompB start!'); } update (deltaTime: number) { console.log('CompB update!'); } } 组件顺序 CompA 在 CompB 上面时，输出： CompA onLoad! CompB onLoad! CompA start! CompB start! CompA update! CompB update! 在 属性检查器 里通过 CompA 组件右上角齿轮菜单里的 Move Down 将 CompA 移到 CompB 下面后，输出： CompB onLoad! CompA onLoad! CompB start! CompA start! CompB update! CompA update! 设置组件执行优先级 如果以上方法还是不能提供所需的控制粒度，还可以直接设置组件的 executionOrder。executionOrder 会影响组件的生命周期回调的执行优先级。设置方法如下： //Player.ts import { _decorator, Component, Node } from \"cc\"; const { ccclass, executionOrder } = _decorator; @ccclass(\"Player\") @executionOrder(-1) export class Player extends Component { onLoad () { console.log('Player onLoad!'); } } // Menu.ts import { _decorator, Component, Node } from \"cc\"; const { ccclass, executionOrder } = _decorator; @ccclass(\"Menu\") @executionOrder(1) export class Menu extends Component { onLoad () { console.log('Menu onLoad!'); } } executionOrder 越小，该组件相对其它组件就会越先执行。executionOrder 默认为 0，因此设置为负数的话，就会在其它默认的组件之前执行。 executionOrder 只对 onLoad, onEnable, start, update 和 lateUpdate 有效，对 onDisable 和 onDestroy 无效。 "},"engine/event/":{"url":"engine/event/","title":"事件机制","keywords":"","body":"Event Events are a messaging mechanism used for object interaction within the engine. Event monitoring // The event listener will be triggered every time, you need to // manually cancel the registration xxx.on(type, func, target); Property Description type the event registration string. func the callback for performing event monitoring. target the event receiving object. Event cancellation // Cancel all registered events of this type on the object xxx.off(type); // Cancel the event of the specified target of the specified // callback on the object xxx.off(type, func, target); Event distribution // Dispatch parameters can be specified when the event // is dispatched xxx.emit(type, ...arg); Note: due to the performance considerations of the underlying event dispatch, only a maximum of 5 event parameters are supported here. Therefore, it is necessary to pay attention to the number of control parameters when passing parameters. Event descriptions System events System events refer to global events, which are monitored and distributed directly from the browser. cc.systemEvent.on(type, func, target); Currently supported system events are: touch events, mouse events, gravity events, and key press events. The global event type can be ontained by using cc.SystemEventType. Event Name Event Type Description TOUCH_START Finger starts touch event. TOUCH_MOVE When your finger moves on the screen. TOUCH_END The finger ends the touch event. TOUCH_CANCEL When the finger leaves the screen outside the target node area. MOUSE_DOWN Triggered once when the mouse is pressed. MOUSE_MOVE When the mouse moves on the target node in the target node area, whether it is pressed or not. MOUSE_UP Triggered once when the mouse is released from the pressed state. MOUSE_WHEEL Mouse scroll event. MOUSE_ENTER When the mouse moves into the target node area, whether it is pressed or not. MOUSE_EXIT When the mouse moves out of the target node area, whether it is pressed or not. KEY_DOWN Event triggered when a key is pressed. KEY_UP Event triggered when the key is released. DEVICEMOTION Gravity sensing. The key value list obtained by the KEY event can be used by referring to the API Macro. UI events Event processing is done in the node. For components, you can register and listen to events by accessing the node this.node. Monitoring events can be registered using the this.node.on() function as follows: import { _decorator, Component, Node } from \"Cocos3D\"; const { ccclass } = _decorator; @ccclass(\"example\") export class example extends Component { onLoad() { this.node.on(Node.EventType.TOUCH_CANCEL, this.callback, this); } callback(){ } onDestroy(){ // In general, for data recovery control, we will // specify func, and cancel the event when the component // is destroyed this.node.off(Node.EventType.TOUCH_CANCEL); } Event Name Event Type Description TRANSFORM_CHANGED Node change position, rotation or zoom event. POSITION_PART Node position change event. Unified monitoring by TRANSFORM_CHANGED, and judge the type after distribution. ROTATION_PART Node rotation event. Unified monitoring by TRANSFORM_CHANGED, and judge the type after distribution. SCALE_PART Node zoom event. Unified monitoring by TRANSFORM_CHANGED, and judge the type after distribution. SIZE_CHANGED Event triggered when the node size changes. ANCHOR_CHANGED Event triggered when the node anchor changes. CHILD_ADDED Node subclass added. CHILD_REMOVED Node subclasses removed. "},"scripting/log.html":{"url":"scripting/log.html","title":"添加 Log","keywords":"","body":"在引擎内添加 Log 信息 本文档主要说明如何按照正确的规范在引擎内部代码中添加新的 Log 信息（包含 log, warning, error）。 Log 信息机制和背景 目前 Cocos Creator 3d 中的 Log 信息是以一个错误信息表形式独立于引擎存储的，具体存储在 engine 目录下的 EngineErrorMap.md 中。而在引擎代码中，不允许直接以字符串形式写日志、警告、错误等信息，必须以下面三个 API 来书写： import { logID, warnID, errorID } from 'core/platform/debug'; logID(id, ...params); warnID(id, ...params); errorID(id, ...params); 这样做的主要目的是减少字符串在引擎源码中所占据的包体。 EngineErrorMap 的编写规范 EngineErrorMap 按照一百位来做大模块划分，总共四位，从 0000 到 9900，也就是说支持最多 100 个大模块。十位数是用来划分子模块的，或者也可以直接以连续的形式排列，这个由模块负责人决定。 由于历史原因，目前没有按照严格的优先级顺序来做排序，新建的模块可以简单得往后顺延。未来我们会做更好的排序管理和整理。 具体错误信息的编写规范如下： ### 4 number ID Message in english. 比如 ### 8300 Should only one camera exists, please check your project. 信息中支持使用 %s，%d，%f 这样的参数接收符，运行输出 LOG 时会按照参数顺序依次拼接到信息中。 EngineErrorMap 的维护 EngineErrorMap 修改后，如果希望代码中的调用生效，需要在 engine 目录下执行 > gulp build-debug-infos EngineErrorMap.md 的修改也要跟随引擎的其他修改提交到 git。 "},"scripting/deprecated.html":{"url":"scripting/deprecated.html","title":"废弃 API","keywords":"","body":"废弃 API 框架说明 为了更友好和便利的维护废弃API ，将通过三个函数来实现： markAsWarning 对给予对象上的属性中嵌入一个警告，给予对象需要存在该属性。 removeProperty 重新定义给予对象上移除的属性，并嵌入一个报错，给予对象应不存在该属性。 replaceProperty 重新定义给予对象上移除的属性，并嵌入一个警告和调用新的属性，参数不兼容的需要进行适配，给予对象应不存在该属性。 函数签名 interface IRemoveItem { /** 废弃属性的名称 */ name: string; /** 警告的次数 */ logTimes?: number; /** 额外建议 */ suggest?: string; } interface IMarkItem { /** 废弃属性的名称 */ name: string; /** 警告的次数 */ logTimes?: number; /** 额外建议 */ suggest?: string; } interface IReplacement { /** 废弃属性的名称 */ name: string; /** 警告的次数 */ logTimes?: number; /** 替换属性的名称 */ newName?: string; /** 废弃属性的所属对象 */ target?: object; /** 废弃属性的所属对象的名称 */ targetName?: string; /** 自定义替换属性（函数） */ customFunction?: Function; /** 自定义替换属性的 setter */ customSetter?: (v: any) => void; /** 自定义替换属性的 getter */ customGetter?: () => any; } export let removeProperty: (owner: object, ownerName: string, properties: IRemoveItem[]) => void; export let markAsWarning: (owner: object, ownerName: string, properties: IMarkItem[]) => void; export let replaceProperty: (owner: object, ownerName: string, properties: IReplacement[]) => void; /** 此函数用于设置全局默认的信息输出次数 */ export function setDefaultLogTimes (times: number): void; 使用规范 按照模块划分，每个模块维护一份废弃文件。为了便于维护，命名统一为 deprecated.ts ，并且放在相应模块的目录下，并需要在相应的模块的index.ts文件中import该文件，例如import './deprecated'。 注：cocos\\utils目录下的deprecated.ts文件为声明和实现文件。 使用示例 // 对于替换参数不兼容的API，通过合适的自定义功能进行适配 replaceProperty(AnimationComponent.prototype, 'AnimationComponent.prototype', [ { name: 'removeClip', newName: 'removeState', customFunction: function (...args: any) { const arg0 = args[0] as AnimationClip; return AnimationComponent.prototype.removeState.call(this, arg0.name); } } ]); replaceProperty(vmath, 'vmath', [ { name: 'vec2', newName: 'Vec2', target: math, targetName: 'math', 'logTimes': 1 }, { name: 'EPSILON', target: math, targetName: 'math', 'logTimes': 2 } ]); removeProperty(vmath, 'vmath', [ { 'name': 'random', 'suggest': 'use Math.random.' } ]); markAsWarning(math, 'math', [ { 'name': 'toRadian' } ]); 使用注意 操作目标都是对象，如果想要修改类的成员函数，请传入target.prototype。 replaceProperty不传入newName或newTarget，表示和name或target一致。 如果要控制次数，最好在使用之前调用setDefaultLogTimes，因为别的模块可能会把默认次数改了。 "},"asset/":{"url":"asset/","title":"Asset Manual","keywords":"","body":"About Assets This section will introduce the overall workflow of the assets in Cocos Creator 3D in detail, and explain the use of various types of assets and items that may require attention. Assets Manager The Assets Manager is an important tool for accessing and managing assets, developers are recommended to familiarize themselves with the use of the Assets Manager for managing assets. Read the Assets Manager documentation for a detailed introduction. Assets Workflow Assets Workflow - the general Assets workflow including importing assets, synchronizing assets, locating assets, etc. can be found in the Assets Workflow documentation. Getting and Loading assets - detailed instructions for getting and loading assets can be found in the Getting and Loading assets documentation. Sub-package loading of assets - for game sub-packaging of small game platforms, Cocos Creator 3D provides developers with sub-package loading functions. For detailed instructions, please read the Subpackage Loading documentation. Common Assets type workflow Next we will introduce the main Asset types and related workflows in Cocos Creator 3D: Scene assets Image Assets Texture Map assets Sprite Frame Assets Cube Map assets Auto crop of image assets Atlas assets Render texture Prefabricated assets Script Assets Font Assets Sound assets Material Assets Model assets Export model assets from third-party tools Animation assets "},"asset/asset-workflow.html":{"url":"asset/asset-workflow.html","title":"Asset workflow","keywords":"","body":"Assets workflow Importing assets There are three ways to import assets: Create a new file through the Assets Panel in Cocos Creator 3D. Use the Create button to start the importing process. By copying files, in the file manager of the operating system, to the project asset folder, and then open the editor or activate the editor window to automatically refresh the asset list of the Assets Panel to finish importing assets. Drag and drop asset files from the file manager of the operating system to a folder location on the Assets Panel. This will trigger an import of the selected assets. Syncing Assets The assets in the Assets Panel are synchronized with the project asset files seen in the file manager of the operating system. Assets are moved, renamed, and deleted in the Assets Panel. If deleted in Cocos Creator 3D, it will be deleted in the file manager of the operating system. If deleted in the file manager of the operating system, it will be deleted in Cocos Creator 3D. Asset Configuration Information .meta File All asset files will generate a .meta configuration file with the same name when imported. This configuration file provides the unique identification (uuid) of the asset in the project, small image references, cropping data of texture assets, as well as other configuration information. This data is a necessary factor in identifying a legitimate asset that Cocos Creator 3D is using. The .meta file is not visible in the Assets Panel. When operating in the Assets Panel, the renaming, moving, and deleting of an asset will automatically synchronize the .meta file that corresponds to the asset by the Editor. To ensure that configuration information such as the uuid remains unchanged, that is, it does not affect existing references. It is not recommended to operate the asset file directly in the file manager of the operating system. If there is such an operation, please manually operate the corresponding .meta file along with the asset file. The following suggestions are recommended: Close the editor you are using to avoid update failures due to file locks or identical asset names. When deleting, renaming, or moving assets, please delete, rename, and move the .meta file as needed. When copying assets together with .meta files, the copied .meta files will be used directly instead of generating new .meta files; if only the asset files are copied, a new .meta file with the corresponding name will be generated when you re-open the editor. This asset will become a new asset to the editor. Assets in Library After the asset is imported, new data will be generated and stored in the project's Library folder. The structure and assets of the files in Library are engine-oriented and the format required for the final game, that is, machine-friendly, but not human-friendly. When a library is lost or damaged, just delete the entire library folder and open the project, and the asset library will be rebuilt. How to locate assets A asset has a unique uuid, used to locate the asset, but this method is not intuitive enough. There is another intuitive way: Database URL format, such as an asset-db. The corresponding protocol header is db://assets, the protocol header for internal-db is db://internal. There are folder-level asset formats, such as db://assets/prefabs/fire.prefab SVN or GIT syncing of assets Note: there are line breaks in the .meta file. It is recommended to unify the line break styles and rules of the team members' computers to avoid opening the project after synchronizing the project assets. "},"asset/load-assets.html":{"url":"asset/load-assets.html","title":"Loading assets","keywords":"","body":"Obtaining and Loading assets Obtaining and Loading assets by Script, please refer to the Obtaining and Loading assets documentation in the Scripting Guide. "},"asset/subpackage.html":{"url":"asset/subpackage.html","title":"Subpackages","keywords":"","body":"Sub-package loading As a game becomes more complex, it can get larger in size. This leaves the developer needing to balance out the package size. Cocos Creator 3D supports Sub-package loading, which supports both the loading code and assets. Sub-package loading currently only supports various instant game platforms, such as WeChat Mini Games. Sub-package loading, is the splitting the game content into several packages according to certain rules. Only the necessary packages are downloaded when first started. This necessary package is called the main package. The main package can trigger the download of other sub-packages, which can effectively reduce the time taken for the first startup. Configuration method Cocos Creator 3D's sub-packaging is configured folder by folder. When a folder is selected, the related configuration options of the folder will appear in the Properties Inspector: After selecting Configure as a sub-package, click OK in the upper right. The assets (including code and other assets) under this folder will be treated as the contents of the sub-package. Sub-package name will be passed in as the loading name when the __sub-package** is loaded. By default, this folder name will be used. Note: When configured as a sub-package, only native assets, such as pictures and audio, will eventually be placed in the sub-package. Prefabs, AnimationClip and other JSON type assets will still be placed in the main package. Note: Nesting of sub-packages should be avoided as much as possible. For example, after folder A is selected as a sub-package, folder B under folder A is also selected as a sub-package. If there is nesting, the parent folder will not package the content in the child folders. Constructing The role of sub-packaing will only be reflected after the project is built. When previewing, the entire package is still loaded. After the project is built, the corresponding sub-package folders will be generated in sub-packages under the release package directory. For example: Configure the cases/01_graphics folder in the example project as a sub-package, then after the project is built, the 01_graphics folder will be generated in sub-packages under the release package directory. When building and publishing, all the code and assets in the cases/01_graphics sub-package folder will be processed as follows: Code: all code in the cases/01_graphics folder will be merged into an entry script file named 01_graphics/game.js, and these codes will be removed from the main package . Assets: will move the cases/01_graphics sub-package assets from the res/raw-assets folder in the release package directory to sub-packages/01_graphics in the release package directory under contents. Loading child packages The engine provides a unified api loader.downloader.loadSubpackage() to load the assets (including code and other assets) in the sub-package. loadSubpackage() needs to pass in the name of a sub-package. This name is the name of the sub-package configured by the user in the previous project. The default is the name of the sub-package folder. When the sub-package is loaded, a callback will be triggered. If the loading fails, an error message will be returned. loader.downloader.loadSubpackage ('01_graphics', (err: any) => { if (err) { return console.error (err); } console.log ('load sub-package successfully.'); }); If the loading is successful, the script in the sub-package will be executed, and the resource loading path of the sub-package will be added to the engine. Developers can access all the assets in this sub-package in exactly the same way as the main package, without having to worry about whether these assets were originally in the main package or in the sub-package. WeChat Mini-Games In the construction of the WeChat Mini-Game platform, the configuration of the sub-packages will also be automatically generated in accordance with the rules in the game.json configuration file. This file is located in the distribution package directory. Note: WeChat Mini-Games require a specific version to support the sub-packaging functions. WeChat 6.6.7 client, 2.1.0 and above basic libraries are supported, please update to the latest client version. For developer tools please use version 1.02.1806120 and above. After updating the developer tools, don't forget to modify the Details -> Project Settings -> debug base library in the developer tools to 2.1.0 and above: Restrictions on the size of the sub-package loading package The current WeChat Mini-Game sub-packaging size has the following restrictions: The size of all sub-packages of the entire WeChat Mini-Game cannot exceed 8M. The size of a single sub-package/main package cannot exceed 4M. For additional details, please refer to the official WeChat Mini-Game sub-package documentation. "},"asset/scene.html":{"url":"asset/scene.html","title":"Scene","keywords":"","body":"Scene Assets In Cocos Creator 3D, the Scene is the cornerstone for organizing game content during development, and presenting all game content to the players. The Scene itself is a file, also considered a game asset, and saves most of the game's information. Creating a Scene There are three ways to create a Scene: In order to have a good directory structure in your project, it is strongly recommend that you use Method 1 to create a Scene. Method 1: Select the folder where you want to create the Scene file in the Assets. On the folder Right click --> New --> Scene file, and then type the desired Scene name. Method 2: Click the Create menu in the Assets to create a new Scene. Method 3: Select File --> New Scene, a new Scene will appear directly in the Hierarchy Panel, but a new Scene will not appear in the Assets. You need to save it in the root of the asset folder. A New Scene.scene Scene file appears in the directory. Saving a Scene While creating Scenes, you can quickly save Scenes with the shortcut keys Ctrl + S (Windows) or Command + S (Mac). Switching Scenes In the Assets, double-click the Scene you want to open. When needing to switch Scenes in the game, you can use the director.loadScene() API to implement dynamic scene loading and switching in the game. For further details, please see the API documentation. Scene Asset Properties Since the Scene is an Asset a property can be set in the Assets to load assets asynchronously. After opening the Scene file, Scene is the root node of the Scene node tree. Select the Scene node in the Hierarchy Manager. In the Property Inspector on the left, you can set the properties of the entire Scene, including ambient light settings, shadow settings and sky box settings. For a detailed description of each attribute, see the following documents: Ambient light Shadow Skybox "},"asset/image.html":{"url":"asset/image.html","title":"Images","keywords":"","body":"Images Image assets are generally created using image processing software (such as Photoshop, Paint on Windows, etc) and output into file formats that Cocos Creator 3D can use, currently including .jpg and .png. Importing image assets After importing images into Cocos Creator 3D, they can be seen in Assets Panel. Types of image assets On the right side of the Property Inspector panel, you can choose different ways to use the image asset. There are currently 4 ways to use it for developers, as shown below: The details of each type of image asset are described in detail in the following sections: The raw type is the original picture type. It has no effect and users do not need to use it. The texture type is the image asset type, which is also the default type for import. For details, see: Texture normal map type is normal map type The sprite-frame type is a sprite frame asset, which is used for UI production. For details, see: SpriteFrame The texture cube type is a cube map type, which is used on the panorama to make a sky box. For details, see: Sky Box In the Assets Manager, a triangle icon similar to a folder will be displayed on the left of the image . Click to expand to see its sub-assets. After each image is imported, the editor will automatically create a selected type asset of the same name. Select the asset itself to change the asset type, set the image flip, and set the quality of the image on each platform. For detailed descriptions of sub-assets, please refer to the Sub-asset Properties Panel documentation. "},"asset/texture.html":{"url":"asset/texture.html","title":"Textures","keywords":"","body":"Texture Map Assets Texture mapping assets are assets used for procedural sampling, such as textures on models and the UI on Sprites. When the UI or model are rendered, the corresponding texture is sampled, then filled on the model grid, plus a series of processing such as lighting to render the entire scene. _Texture assets can be generated from ImageAsset. Some common image formats, including, .png, .jpeg, etc. can be used in ImageAsset. Texture2D Texture2D is a type of texture asset that is usually used for rendering of 3D models, such as reflection maps, ambient light mask maps, etc. in model materials. Texture2D in Cocos Creator 3D: Note: The texture type is a Texture2D asset. Adjusting the Properties of a Texture2D When importing an ImageAsset, it will be set to Texture2D by default. At this same time, one or more sub-assets will be generated on the original asset. Click the arrow in front of the original asset to see all the sub-assets. Example: After selecting the generated Texture2D sub-asset, you can see the following panel: Sub-Asset Texture2D Properties Panel The following describes the properties of the panel: Properties Explanation anisotropy Anisotropy value minFilter Narrowing Filter Algorithm magFilter Magnification Filter Algorithm mipFilter Multi-level texture filtering algorithm wrapS S (U) direction texture addressing mode wrapT T (V) direction texture addressing mode Using Texture2D Texture2D is a very widely used asset. Any property marked as Texture2D in the Property Panel can be dragged into a Texture2D asset type. The usage scenario is mainly in the Editor environment and for dynamic acquisition: In the Editor, just drag the assets in; For dynamic acquisition, you need to obtain the ImageAsset asset first, and then instantiate the Texture2D asset based on the obtained ImageAsset; TextureCube TextureCube is a cube texture, which can be used to set the scene's Skybox. It can be obtained by setting the panorama ImageAsset to the TextureCube type. It can also be obtained by making CubeMap assets. TextureCube obtained from a panorama in Cocos Creator 3D: TextureCube obtained by making a CubeMap in Cocos Creator 3D: To learn more about the use of TextureCube and CubeMaps, please refer to the Sky Box documentation. "},"asset/sprite-frame.html":{"url":"asset/sprite-frame.html","title":"Sprite Frames","keywords":"","body":"Sprite Frame Assets Sprite Frame is a container for UI rendering and basic graphics, which manages the clipping and tiling data on top of a Texture2D asset (by holding a reference to it). Importing Sprite Frame Assets Use the default asset import method to import image assets into the project, then set the type of image as sprite-frame and can then be seen in the Assets Panel. Image assets will use thumbnails of their own pictures as icons in the Assets Panel. When the image sub-asset is selected in the Assets Panel, a thumbnail of the image is displayed below the Property Inspector. Using a Sprite Frame 1. The object contained in the container is using textures In the editor, drag the SpriteFrame asset to the Sprite Frame property of the Sprite component to switch the image displayed by the Sprite. At runtime, taking the content picture in the above picture as an example, The entire asset is divided into image asset (content) ,its sub-asset (spriteFrame) and sub-asset (texture). The assets in the game package can be obtained by the following methods: Method 1: (load ImageAsset): const self = this; const url = 'test_assets/test_altas/content'; loader.loadRes(url, ImageAsset,(err: any, imageAsset) => { const sprite = this.getComponent(SpriteComponent); const spriteFrame = new SpriteFrame(); const tex = new Texture2D(); tex.image = imageAsset; spriteFrame.texture = tex; sprite.spriteFrame = spriteFrame; }); Method 2:（load SpriteFrame)： const self = this; const url = 'test_assets/test_altas/content/spriteFrame'; loader.loadRes(url, SpriteFrame,(err: any , spriteFrame) => { const sprite = this.getComponent(SpriteComponent); sprite.spriteFrame = spriteFrame; }); Assets on the server can only be loaded into ImageAsset. For specific methods, please refer to the Asset Loading documentation. Cocos Creator will provide a way to package an Image Asset as a SpriteFrame in a later release to make it easier for users to use image assets. 2. The container contains objects that are used by RenderTexture RenderTexture is a rendering texture that renders content from the camera directly to a texture instead of the screen. SpriteFrame can easily display 3D camera content on the UI by managing RenderTexture. Use is as follows: const cameraComp = this.getComponent(CameraComponent); const renderTexture = new RenderTexture(); const size = view.getVisibleSize(); renderTexture.reset({ width: size.width, height: size.height, colorFormat: RenderTexture.PixelFormat.RGBA8888, depthStencilFormat: RenderTexture.DepthStencilFormat.DEPTH_24_STENCIL_8 }); cameraComp.targetTexture = renderTexture; const spriteFrame = new SpriteFrame(); spriteFrame.texture = renderTexture; const sprite = this.getComponent(SpriteComponent); sprite.spriteFrame = spriteFrame; "},"ui-system/components/engine/trim.html":{"url":"ui-system/components/engine/trim.html","title":"Texture Auto Trim","keywords":"","body":"Auto Trim for SpriteFrame Once a texture is imported, the SpriteFrame asset generated with the texture will be trimmed automatically. Any fully transparent pixels around the image will be cropped. This will help us get the exact node size we need for Sprites. Trim Related Properties in Sprite Component There are two properties related to trim setting in Sprite component: Trim If checked, the node's bounding box will not include transparent pixels around the image. Instead the bounding box will be an exact fit to trimmed image. If unchecked the bounding box will be showing original texture including transparent pixels. Size Mode Use the options in this property to set node's size to the original texture size or trimmed image size. Options are: TRIMMED Select this option will set the size of the node to use trimmed image size of the current SpriteFrame used by Sprite component. RAW Select this option will set the size of the node to use the original texture size, including transparent pixels. CUSTOM This option make sure the size of the node will not be changed along with SpriteFrame, and should be managed by yourself. If you use the Rect Transform Tool to drag and change the size of the node, or modify the size property in Inspector panel, or modify the width or height in the script, the Size Mode property will be automatically set to CUSTOM. The following picture shows the comparison of two size modes: Sprite Animation with offset There are a lot of animator prefer to draw the moving motion in texture, commonly seen in attack animations. Usually animator will use a large texture and put character on different positions on the texture for different animation frames. In this case, we need to set the Sprite component's Trim property to false, and set the Size Mode to RAW. In this way, the animation will use the original texture size when playing each sequence frame, and retain the information of transparent pixels around the image. So that the character's position drawn in the texture can be displayed correctly. When Trim property is set to true, it is more suitable for animation where the displacement is completely controlled by the character's position property. TexturePacker Setting We recommend users to use sprite sheet tools such as TexturePacker for generating sprite animation texture assets. In TexturePacker before you publish your sprite sheet, please make sure you choose Trim in Trim Mode setting of Sprites section. Please do not use Crop, flush position, or the trim information will be lost and you can't get back originial texture offset anymore. It is currently recommended to use version 4.x or higher for packaging to prevent the import failure caused by inconsistent export data in the lower version. "},"asset/compress-texture.html":{"url":"asset/compress-texture.html","title":"Compressed textures","keywords":"","body":"Compress texture Cocos Creator 3D can set the compression method required for textures directly in the editor, and then automatically compress the textures when the project is released. For the web platform, multiple image formats can be exported at the same time, and the engine will automatically download the appropriate format according to different browsers. Configure compressed texture Cocos Creator 3D supports importing images in multiple formats (see the table below for details), but in an actual running game, we do not recommend using the original images as assets to load. For example, on a mobile platform, only 80% or less of the original image quality may be required, or a .png without the transparent channel can be converted into a .jpg, which can reduce the storage space required. Image format Android iOS WeChat game Web PNG Supported Supported Supported Supported JPG Supported Supported Supported Supported WEBP Native Supported for Android 4.0+Other versions can use this library can use this library Not Supported partially supported PVR Not Supported Supported Supported iOS devices Supported iOS devices ETC1 Supported Not Supported Supported Android devices Supported Android devices ETC2 Supported with WebGL2 or WebGL extension if available By default, Cocos Creator 3D outputs the original image during construction. If you need to compress an image during the build process, you can select this image in the Assets Panel and then manage it in the Property Inspector to edit the texture format of the image. Detailed compression textures If you want to use compressed textures, you need to turn on the compressed texture option when you build the project: When Cocos Creator 3D builds the image, it will find whether the current image has been already configured to use compressed textures. If not, it will continue to find whether the default configuration has been made. If not, it will output the original image. If the configuration of the compressed texture is found, the image will be compressed according to the found configuration. Multiple texture formats can be specified on one platform, and each texture format is compressed to generate an image of the specified format when it is constructed. These generated images will not all be loaded into the engine during runtime, the engine will choose to load the appropriate image according to the configuration in macro.SUPPORT_TEXTURE_FORMATS. macro.SUPPORT_TEXTURE_FORMATS enumerates all the image formats supported by the current platform. When the engine loads the images, it will find, from the generated images in this list, the format with the highest priority (that is, the order is higher) to load. The user can customize the supported image assets for a platform and the priority of the loading order, by modifying macro.SUPPORT_TEXTURE_FORMATS. Example In the example images above, the default platform is configured with compressed textures in png format, the web platform is configured with compressed textures in pvr and png formats, and no configuration is added on other platforms. When building a web platform, this image will be compressed into two formats: pvr and png. When building other platforms, it will only generate images in the png format. The default settings of macro.SUPPORT_TEXTURE_FORMATS is only supported by pvr on the iOS platform. This means pvr images will only be loaded on iOS browsers, and browsers on other platforms will load png images. "},"asset/atlas.html":{"url":"asset/atlas.html","title":"Atlas","keywords":"","body":"Atlas assets Atlas, also called a Sprite Sheet, is a common art asset in game development. Atlas is an asset for merging multiple pictures into a large picture through a special tool, and indexing through a file such as a .plist. Atlas assets available for Cocos Creator 3D consist of a .plist and at least one .png file, although usually many .png files make up an Atlas. The following is an image file used in an Atlas: Why use atlas assets In a game, using an Atlas composed of multiple pictures as art assets has the following advantages: The blank area around each picture will be removed when synthesizing the Atlas, plus various optimization algorithms can be implemented as a whole. After synthesizing the Atlas, the game package and memory consumption can be greatly reduced. When multiple Sprites are rendering pictures from the same atlas, these Sprites can be processed using the same rendering batch, which greatly reduces the CPU's computing time and improves operating efficiency. For a more comprehensive explanation, you can watch a teaching video: What is a Sprite Sheet from CodeAndWeb. Atlas Assets To generate an Atlas, you should first prepare a set of original pictures. Example: Next, you can use special software to generate the Atlas. Examples: TexturePacker 4.x Zwoptex When using these software packages to generate an Atlas, please select a .plist file in Cocos2d-x format. The resulting Atlas files are a .plist and .png with the same name. Example: myAtlas.plist and myAtlas.png. Users of the TexturePacker software need to pay attention to a few items: Use version 4.x only. Version 3.x is not supported. Importing Atlas Assets Drag the .plist and the .png files shown above into the Assets Panel at the same time. You can generate Atlas assets that can be used in the editor and scripts. Atlas and SpriteFrame In the Image Resource Document, the relationship between Texture and SpriteFrame was introduced. After importing the Atlas, we can see that the Atlas is of type Atlas and can be expanded by clicking the triangle icon on the left. After expanding, we can see that the Atlas contains many sub-assets of type SpriteFrame. Assets are pictures that can be used and referenced individually. The use of the Sprite Frame is the same as that described in the image asset. Please refer to the related documents. "},"asset/auto-atlas.html":{"url":"asset/auto-atlas.html","title":"Auto Atlas","keywords":"","body":"Auto Atlas Auto Atlas Assets is the picture-combining method that comes as part of Cocos Creator 3D. You can pack a specified series of images into a sprite sheet. This capability is very similar to the function of Texture Packer. Creating Auto Atlas Assets Right-click in the Assets Panel, select New -> Auto Atlas Configuration in the menu. Selecting this option will create a new asset similar to AutoAtlas.pac. AutoAtlas will pack all SpriteFrame assets in the same folder into a big Sprite Atlas asset during the build process. We might add other ways to choose assets for packing in the future. If the original SpriteFrame asset have been configured, then all configurations will be preserved. Configuring Auto Atlas Assets After selecting an Auto Atlas Resource in the Assets Panel, the Property Inspector panel will display all of the configurable items for the Auto Atlas Resource. Properties Functional Description Maximum Width Single Atlas Maximum Width Maximum Height Maximum Height of a Single Atlas Spacing Spacing between shreds in the atlas Allow Rotation Whether Rotate Fragments Output size is square Whether to force the size of the atlas to be square The output size is a power of two Whether to set the size of the atlas to a multiple of a square Algorithm Atlas packaging strategy, currently only one option Output format Atlas image generation format, the available formats are [png, jpg, webp ...] Expand the edge Expand a pixel outer frame outside the border of the broken image, and copy the adjacent broken image pixels to the outer frame. This feature is also called \"Extrude\". Does not include unreferenced assets In preview, this option will not take effect, this option will take effect after building After the configuration is complete, you can click the Preview button to preview the packaged results. The related results generated according to the current automatic atlas configuration will be displayed in the area below the Properties Inspector. Please note that after each configuration, you can re-click Preview to update the preview image. (Generating a preview is not required). The results are divided into: Packed Textures: Display the packaged atlas pictures and picture-related information. If there are multiple pictures to be generated, they will be listed below in the Property Inspector. Unpacked Textures: Display the broken image assets that cannot be packed into the atlas. The cause may be that the size of these broken image assets is larger than the size of the atlas assets. At this time, the configuration or fragmentation of the following atlas may need to be adjusted. The size of the figure is increased. Generating an Atlas When inside the editor or previewing the project Cocos Creator 3D is directly using the split SpriteFrame assets, only after you build the project with the option AutoAtlas enabled, the Atlas asset will be generated and be used instead of all split assets. "},"asset/render-texture.html":{"url":"asset/render-texture.html","title":"Render-texture","keywords":"","body":"RenderTexture A rendered texture is a texture on the GPU. Usually, we set it to the camera's target texture, so that the content illuminated by the camera is drawn to the texture through the frambuffer off the screen. Using RenderTexture // Method 1: Draw the content illuminated by the 3D camera // onto the UI sprite frame export class CaptureToWeb extends Component { @property(SpriteComponent) sprite: SpriteComponent = null; @property(CameraComponent) camera: CameraComponent = null; protected _renderTex: RenderTexture = null; start () { const spriteframe = this.sprite.spriteFrame; const sp = new SpriteFrame(); sp.reset({ originalSize: spriteframe.getOriginalSize(), rect: spriteframe.getRect(), offset: spriteframe.getOffset(), isRotate: spriteframe.isRotated(), borderTop: spriteframe.insetTop, borderLeft: spriteframe.insetLeft, borderBottom: spriteframe.insetBottom, borderRight: spriteframe.insetRight, }); const rendetTex = this._renderTex = new RenderTexture(); rendetTex.reset({ width: 256, height: 256, colorFormat: RenderTexture.PixelFormat.RGBA8888, depthStencilFormat: RenderTexture.DepthStencilFormat.DEPTH_24_STENCIL_8 }); this.camera.targetTexture = rendetTex; sp.texture = rendetTex; this.sprite.spriteFrame = sp; } } // Method 2: Draw the content illuminated by the 3D camera onto the 3D model export class RenderCameraToModel extends Component { @property(ModelComponent) model: ModelComponent = null; start () { // Your initialization goes here. const renderTex = new RenderTexture(); renderTex.reset({ width: 256, height: 256, colorFormat: RenderTexture.PixelFormat.RGBA8888, depthStencilFormat: RenderTexture.DepthStencilFormat.DEPTH_24_STENCIL_8, }); const cameraComp = this.getComponent(CameraComponent); cameraComp.targetTexture = renderTex; const pass = this.model.material.passes[0]; const binding = pass.getBinding('mainTexture'); pass.bindTextureView(binding, renderTex.getGFXTextureView()); } } For more Render Texture examples, please see these test casees. "},"asset/prefab.html":{"url":"asset/prefab.html","title":"Prefab","keywords":"","body":"Prefab It is necessary to use Prefabs for Nodes that will be repeatedly generated in a project. Creating a Prefab After editing the Node in the Scene, drag the Nodes directly from the Hierarchy Manager to the Assets Panel to complete the creation of the Prefab. After the creation is complete, the original Node will automatically become a Prefab Node, showing in green. Using Prefabs Drag a Node from the Assets Panel to the Hierarchy Manager or the Scene Panel to create a Prefab Node in the Scene. In the Scene, the Prefab Node objects data source comes from the deserialization of the Prefab assets. They are completely independent of each other, multiples can coexist, and there is no data association with the Prefab assets. Assets and Nodes are changed separately unless the Restore from assets orUpdate to assets (described below) is used. Otherwise, they will not affect each other. Editing Prefab Nodes in a Scene In the Hierarchy Manager, select the Prefab Node, and notice there are several buttons that can be clicked at the top of the Property Inspector. If you move the mouse up, there will be a text prompt for these functions. The following image describes the functions of the buttons in the red frame area: First, revert to normal node. Prefab Nodes can become ordinary Nodes, that is, completely separated from the relationship between assets. This function is available in the top-level menu ,Edit. Second, associate the Node to another Prefab asset. As a way for Nodes to re-associate assets, you need to first select a Prefab asset in the Asset Manager, and then select a Prefab Node in the Hierarchy Panel to re-associate it. This function is available in the top-level menu, Edit. Third, locating assets is convenient to quickly locate Prefab assets in the Asset Manager. When there are many assets, the efficiency is higher. Fourth, you can deserialize a Node object again from the asset and replace the existing node. This operation does not change the uuid of the existing Node. It is usually used when you want the Node to be re-synchronized with the Prefab Asset. Fifth, when there are new changes to the Node, and you want to update to the associated Prefab asset, you can use this button. Status of prefab nodes Prefab Nodes in the Property Inspector render green to indicate normal association with assets and render red to indicate that the associated assets no longer exist. Entering prefab editing mode Double-click the Prefab Asset in the Assets Panel to switch from Scene editing mode to Prefab editing mode. You can edit the Prefab Assets in the Editor. After editing, click Save Prefab in the Scene editor to save the edited Prefab Assets. Next, click Close to return to the Scene editing mode. There is no automatic synchronization between Prefab Nodes and Assets. Manual synchronization is required. Modifying Prefab Assets in this way will not affect existing Prefab Nodes after saving. If you need to update other such Prefab Nodes in the Scene, and the Scene where the Node is not open, the Scene needs to be opened and edited. Select the Prefab Node, click the Restore option from the Assets button at the top in the Property Inspector. Now, the Node can be updated, the scene saved and the Asset synchronized to the Node. "},"asset/script.html":{"url":"asset/script.html","title":"Scripting","keywords":"","body":"Script Assets In Cocos Creator 3D, scripts are also part of the Asset. For a detailed introduction to scripting, please refer to the Scripting Guide documentation. For details on the creation and use of script assets, please refer to the Script Creation documentation. "},"asset/font.html":{"url":"asset/font.html","title":"Fonts","keywords":"","body":"Fontss There are three types of font assets available to games made with Cocos Creator: system fonts, dynamic fonts, and bitmap fonts. The system font renders text by calling the system font that comes with the game running platform, and does not require the user to add any related assets to the project. To use system fonts, use the Use System Font property in LabelComponent. Importing font assets Dynamic fonts Cocos Creator currently supports dynamic fonts in True Type format. Simply drag a font file with an extension of .ttf into the Assets Panel, and you can import the font asset. Bitmap fonts The bitmap font is composed of a font file in .fnt format and a .png image. The .fnt file provides an index of each character thumbnail. Fonts in this format can be generated by specialized software, please refer to: Glyph Designer Hiero BMFont (Windows) When importing bitmap fonts, be sure to drag both the .fnt file and the .png file into the Assets Panel at the same time. Note: after importing the bitmap font, you need to change the type of the .png file to sprite-frame, otherwise the bitmap font will not work properly. The imported fonts are displayed in the Assets Panel, as follows: Note: in order to improve the efficiency of asset management, it is recommended that the imported .fnt and .png files be stored in separate directories and not mixed with other assets. Using font assets The font asset needs to be rendered through the Label component. Here is how to create a Node with a Label component in the scene. Creating a Label (Font) Node Using the Menu Click on the Create Node button in the upper left corner of the Hierarchy Manager and select Create Render Node --> Label (Text), and a component with Label will be created in the Scene node. You can also complete the creation through Node --> Create Render Node --> Label (Text) of the main menu, the effect is the same as the above method. Associated Font Assets The font components created using the above method use the system font as the associated asset, by default. If you want to use a TTF or bitmap fonts in the project, you can drag your font assets to the created Label component. At this time, the font used in a scene will be immediately rendered using the font asset specified. You can also freely switch the Font property of the same Label component to use TTF or bitmap fonts according to the needs of the project. When switching font files, other properties of the Label component are not affected. If you want to restore the use of system fonts, you can click the property check box of Use System Font to clear the font file specified in the Font property. Dragging and droping to create a Label node Another quick way to create font nodes using specified assets is to directly drag and drop font files, either TTF or bitmap fonts, from the Assets Panel into the Hierarchy Panel. The only difference from the menu created above is that text nodes created using drag and drop will automatically use the dragged font asset to set the Font property of the Label component. "},"asset/audio.html":{"url":"asset/audio.html","title":"Audio","keywords":"","body":"Audio Sound assets are audio files. An audio system has two main functions: playing background music and playing short sound effects. For sound assets, there is no difference between the two. After all, audio assets are imported into the editor, AudioClip assets perform related audio operations through the AudioSourceComponent system component. To use the audio system, please refer to the Audio System documentation. Supported audio asset formats Currently, the engine's audio system can support the following formats: .ogg .mp3 .wav .mp4 .m4a Use of sound assets After adding an AudioSourceComponent to a Node, drag the imported audio asset from the Asset Manager to the Clip of the node AudioSourceComponent to control the sound asset: "},"asset/material.html":{"url":"asset/material.html","title":"Material","keywords":"","body":"Material assets Material creation Material is created as follows: or The Material controls the final shading of each model. The Material is composed of Effects, and the shading process of an Effect is controlled by the Material. The Material itself can also be regarded as a container of Effect assets. The Material can switch the Effect assets to be used at will. The following figure is the Effect asset of the Material we have selected by default. At the same time, we can also switch the Effect of the current Material by clicking the box to the right of the Effect property. Effect Creation Effects are created in a similar way to Materials. The created Effect is a PBR Effect by default. Continue to the Effect writing format and syntax documentation. "},"asset/mesh.html":{"url":"asset/mesh.html","title":"Mesh","keywords":"","body":"Model assets Currently, model files in FBX and glTF formats. For how to export these two model files from third-party tools, you can refer to the DCC Export Mesh documentation. Model importing After importing into the editor, from the outside, the corresponding model asset file can be obtained in the Assets Panel. It's directory structure is as follows: The structure of a model file without animations is as follows: The structure of the model file that contains animations is as follows: The various file types are described: .material files are material files .mesh files are model files .texture files are model texture files .animation files are model animation files .skeleton files are model bone files .prefab files are prefab files that are automatically generated on import Using Models After importing a model file, drag the root node of the model file directly from the Assets Panel to the node you want to place in the Hierarchy Manager to complete the node creation. At this point the model is successfully created in the scene . Alternatively, you can expand the node of the model file, select the .prefab file under the model file node, and drag it from the Assets Panel into the Hierarchy Manager to complete the creation. Model asset Properties panel description When the model asset file is selected in the Asset Explorer (.fbx or .gltf), the properties of the model asset can be set in the Property Inspector. Model module Normals information: Optional, Exclude, Require, Recalculate Tangents information: Optional, Exclude, Require, Recalculate SkipValidation: whether to skip standard checks Animation Module The above image is all the animation asset information under the current model, and the editing area of ​​the specific frame number information of the currently selected animation. You can change the animation name or perform simple animation cropping here. To do so: Click the + button in the red box on the image to add an animation clip asset. The new file added by default copies a complete clip data. You can input the number of frames in the Start End input box to crop the animation. (Drag and drop animation is not currently supported) Click the - button in the red box on the image to delete the currently selected animation file Material module DumpMaterial: When you are not satisfied with the material that comes with the model file and want to modify it, you need to enable this option to dump the material files in the file structure directory out of the model assets. You can adjust and modify the materials. Dumper Directory: here you can specify or view the directory location for the dumped files. About glTF Currently, the glTF 2.0 specification is supported, but the following features are unavailable until Cocos Creator 3D v1.1: sparse accessor morph target "},"asset/anim.html":{"url":"asset/anim.html","title":"Animation assets","keywords":"","body":"Animation assets Editor Custom Animation For creating custom animations in the Cocos Creator 3D editor, please refer to the Animation Creation documentation. Information about the Format is also important to understand. Bone animations attached after a model import After a model with animations is imported, the animation on the corresponding model will be generated. The imported animations can be used in the same way as those created in editor. For cutting a skeletal animation, please refer to Introduction of Animation Modules for Model Assets documentation. "},"getting-started/":{"url":"getting-started/","title":"启动","keywords":"","body":"新手上路 欢迎使用 Cocos Creator 3D，在学习使用之前，请先按照以下步骤安装好编辑器开发环境。 在安装完我们的编辑器之后，就可以通过 Hello world! 熟悉编辑器，也可以参考我们的 示例游戏 进行自己的开发啦。 本章节包括以下内容： Dashboard Hello world! 快速上手：制作第一个游戏 注意事项 继续前往 Dashboard 说明文档。 "},"getting-started/helloworld/":{"url":"getting-started/helloworld/","title":"Hello world!","keywords":"","body":"Hello World项目 第一个Cocos Creator 3D项目, 为您展示: 创建项目 了解工程目录 创建一个物体 修改相机属性 创建、修改、绑定脚本 运行及调试项目 新建项目 在Dashboard面板中，点击右下角新建按钮，在弹出菜单中选中Creator 3D。 选择空的模板，设置项目路径，点击下方的创建按钮。 编辑器界面 工程目录 通常情况的我们只需要关心assets(资源目录) assets(资源目录) build(构建目录) library(导入的资源目录) local(日志文件目录) profiles(编辑器配置) temp(临时文件目录) package.json(项目配置) 新建场景 左下方资源管理器面板点击鼠标右键，选择新建->Scene。 创建物体 左上方层级管理器面板点击鼠标右键, 选择创建->3D对象->Cube 正方体。创建的正方体就会出现在场景编辑器里。 修改Camera 选择Camera对象 在层级管理器面板，选择Camera，场景编辑器会选中它，并显示Gizmo。 修改Camera位置 在场景编辑器里，拖动Gizmo, 使Camera能够看到创建的正方体。 修改Camera背景颜色 在属性检查器面板，点击Color属性，选择黑色为背景色。 添加脚本 新建脚本 在资源管理器面板点击鼠标右键，选择新建->TypeScript。 生命周期函数（按以下顺序调用） onLoad 脚本初始化时调用 onEnable 组件的 enabled 属性从 false 变为 true 时调用 start 组件第一次激活时调用 update 每一帧渲染前更新物体调用 lateUpdate 在所有组件的 update 都执行完之后调用 onDisable 组件的 enabled 属性从 true 变为 false 时调用 onDestroy 组件或者所在节点销毁时调用 添加代码 添加onLoad()函数，并输出Hello world import { _decorator, Component, Node } from 'cc'; const { ccclass, property } = _decorator; @ccclass('HelloWorld') export class HelloWorld extends Component { /* class member could be defined like this */ // dummy = ''; /* use `property` decorator if your want the member to be serializable */ // @property // serializableDummy = 0; start () { // Your initialization goes here. console.info('Hello world'); } // update (deltaTime: number) { // // Your update function goes here. // } } 为物体绑定脚本 选择创建的正方体，在属性检查器面板点击添加组件->自定义脚本->HelloWorld 运行项目 编辑器菜单栏点击->项目->运行预览, 或者点击中间的运行按钮。 调试项目 以Chrome浏览器为例： 按 F12 或者 Ctrl + Shift + I 打开Chrome的开发者工具。 日志信息 Console面板显示了所有日志输出 断点调试 选择标签栏的Source选项，按下Ctrl+P，搜索HelloWorld.js，在onLoad函数里设置断点，再刷新网页就可以调试了。 "},"getting-started/first-game/":{"url":"getting-started/first-game/","title":"快速上手：制作第一个游戏","keywords":"","body":"快速上手：制作第一个游戏 Cocos Creator 3D编辑器的强大之处就是可以让开发者快速的制作游戏原型。 下面我们将跟随教程制作一款名叫 一步两步 的魔性小游戏。这款游戏考验玩家的反应能力，根据路况选择是要跳一步还是跳两步，“一步两步，一步两步，一步一步似爪牙似魔鬼的步伐”。 可以在 这里 体验一下游戏的完成形态。 新建项目 如果您还不了解如何获取和启动 Cocos Creator 3D，请阅读 安装和启动 一节。 首先启动 Cocos Creator 3D，然后新建一个名为 MindYourStep 的项目，如果不知道如何创建项目，请阅读 Hello World!。 新建项目后会看到如下的编辑器界面： 创建游戏场景 在 Cocos Creator 3D 中，游戏场景（Scene） 是开发时组织游戏内容的中心，也是呈现给玩家所有游戏内容的载体。游戏场景中一般会包括以下内容： 场景物体 角色 UI 以组件形式附加在场景节点上的游戏逻辑脚本 当玩家运行游戏时，就会载入游戏场景，游戏场景加载后就会自动运行所包含组件的游戏脚本，实现各种各样开发者设置的逻辑功能。所以除了资源以外，游戏场景是一切内容创作的基础。现在，让我们来新建一个场景。 在 资源管理器 中点击选中 assets 目录，点击 资源管理器 左上角的加号按钮，选择文件夹，命名为Scenes。 点击先中Scenes目录（下图把一些常用的文件夹都提前创建好了），点击鼠标右键，在弹出的菜单中选择 场景文件 我们创建了一个名叫 New Scene 的场景文件，创建完成后场景文件 New Scene 的名称会处于编辑状态，将它重命名为 Main。 双击 Main，就会在 场景编辑器 和 层级管理器 中打开这个场景。 添加跑道 我们的主角需要在一个由方块（Block）组成的跑道上从屏幕左边向右边移动。我们使用编辑器自带的立方体（Cube）来组成道路。 在 层级管理器 中创建一个立方体（Cube），并命名为Cube。 选中Cube，按Ctrl+D来复制出3个Cube。 将3个Cube按以下坐标排列：第一个节点位置（0，-1.5，0），第二个节点位置（1，-1.5，0），第三个节点位置（2，-1.5，0） 效果如下： 添加主角 创建主角节点 首先创建一个名字为Player的空节点，然后在这个空节点下创建名为Body的主角模型节点，为了方便，我们采用编辑器自带的胶囊体模型做为主角模型。 分为两个节点的好处是，我们可以使用脚本控制Player节点来使主角进行水平方向移动，而在Body节点上做一些垂直方向上的动画（比如原地跳起后下落），两者叠加形成一个跳越动画。 将Player节点设置在（0，0，0）位置，使得它能站在第一个方块上。 效果如下： 编写主角脚本 想要主角影响鼠标事件来进行移动，我们就需要编写自定义的脚本。如果您从没写过程序也不用担心，我们会在教程中提供所有需要的代码，只要复制粘贴到正确的位置就可以了，之后这部分工作可以找您的程序员小伙伴来解决。下面让我们开始创建驱动主角行动的脚本吧。 创建脚本 如果还没有创建Scripts文件夹，首先在 资源管理器 中右键点击 assets 文件夹，选择 新建 -> 文件夹，重命名为Scripts。 右键点击Scripts文件夹，选择 新建 -> TypeScript，创建一个 TypeScript 脚本，有关TypeScript资料可以查看 TypeScript 官方网站。 将新建脚本的名字改为PlayerController，双击这个脚本，打开代码编辑器（例如VSCode）。 注意： Cocos Creator 3D 中脚本名称就是组件的名称，这个命名是大小写敏感的！如果组件名称的大小写不正确，将无法正确通过名称使用组件！ 编写脚本代码 在打开的 PlayerController 脚本里已经有了预先设置好的一些代码块，如下所示： import { _decorator, Component } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"PlayerController\") export class PlayerController extends Component { /* class member could be defined like this */ // dummy = ''; /* use `property` decorator if your want the member to be serializable */ // @property // serializableDummy = 0; start () { // Your initialization goes here. } // update (deltaTime: number) { // // Your update function goes here. // } } 这些代码就是编写一个组件（脚本）所需的结构。具有这样结构的脚本就是 Cocos Creator 3D 中的 组件（Component），他们能够挂载到场景中的节点上，提供控制节点的各种功能，更详细的脚本信息可以查看 脚本。 我们在脚本中添加对鼠标事件的监听，然后让Player动起来，将PlayerController中代码做如下修改。 import { _decorator, Component, Vec3, systemEvent, SystemEvent, EventMouse, AnimationComponent, v3 } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"PlayerController\") export class PlayerController extends Component { /* class member could be defined like this */ // dummy = ''; /* use `property` decorator if your want the member to be serializable */ // @property // serializableDummy = 0; // for fake tween private _startJump: boolean = false; private _jumpStep: number = 0; private _curJumpTime: number = 0; private _jumpTime: number = 0.1; private _curJumpSpeed: number = 0; private _curPos: Vec3 = v3(); private _deltaPos: Vec3 = v3(0, 0, 0); private _targetPos: Vec3 = v3(); private _isMoving = false; start () { // Your initialization goes here. systemEvent.on(SystemEvent.EventType.MOUSE_UP, this.onMouseUp, this); } onMouseUp(event: EventMouse) { if (event.getButton() === 0) { this.jumpByStep(1); } else if (event.getButton() === 2) { this.jumpByStep(2); } } jumpByStep(step: number) { if (this._isMoving) { return; } this._startJump = true; this._jumpStep = step; this._curJumpTime = 0; this._curJumpSpeed = this._jumpStep / this._jumpTime; this.node.getPosition(this._curPos); Vec3.add(this._targetPos, this._curPos, v3(this._jumpStep, 0, 0)); this._isMoving = true; } onOnceJumpEnd() { this._isMoving = false; } update (deltaTime: number) { if (this._startJump) { this._curJumpTime += deltaTime; if (this._curJumpTime > this._jumpTime) { // end this.node.setPosition(this._targetPos); this._startJump = false; this.onOnceJumpEnd(); } else { // tween this.node.getPosition(this._curPos); this._deltaPos.x = this._curJumpSpeed * deltaTime; Vec3.add(this._curPos, this._curPos, this._deltaPos); this.node.setPosition(this._curPos); } } } } 现在我们可以把 PlayerController 组件添加到主角节点上。在 层级管理器 中选中 Player 节点，然后在 属性检查器 中点击 添加组件 按钮，选择 添加用户脚本组件 -> PlayerController，为主角节点添加 PlayerController 组件。 为了能在运行时看到物体，我们需要将场景中的Camera进行一些参数调整，将位置放到（0，0，13），Color设置为（50，90，255，255）： 现在点击工具栏中心位置的Play按钮，在打开的网页中点击鼠标左键和右键，可以看到如下画面： 更多的预览功能，可以参考 项目预览调试 添加角色动画 从上面运行的结果可以看到单纯对Player进行水平方向的移动是十分呆板的，我们要让Player跳跃起来才比较有感觉，我们可以通过为角色添加垂直方向的动画来达到这个效果。有关 动画编辑器 的更多信息，请阅读 动画编辑器 选中场景中的Body节点，编辑器下方 控制台 边上的 动画编辑器，添加Animation组件并创建Clip，命名为oneStep。 进入动画编辑模式，添加position属性轨道，并添加三个关键帧，position值分别为（0，0，0）、（0，0.5，0）、（0，0，0）。 退出动画编辑模式前前记得要保存动画，否则做的动画就白费了。 我们还可以通过 资源管理器 来创建Clip，下面我们创建一个名为twoStep的Clip并将它添加到Body身上的 AnimationComponent 上，这里为了录制方便调整了一下面板布局。 进入动画编辑模式，选择并编辑twoStep的clip，类似第2步，添加三个position的关键帧，分别为（0，0，0）、（0，1，0）、（0，0，0）。 在 PlayerController组件 中引用 动画组件 ，我们需要在代码中根据跳的步数不同来播放不同的动画。 首先需要 在 PlayerController组件 中引用Body身上的 AnimationComponent。 @property({type: AnimationComponent}) public BodyAnim: AnimationComponent = null; 然后在 属性检查器 中将Body身上的 AnimationComponent 拖到这个变量上。 在跳跃的函数 jumpByStep 中加入动画播放的代码： if (step === 1) { this.BodyAnim.play('oneStep'); } else if (step === 2) { this.BodyAnim.play('twoStep'); } 点击Play按钮,点击鼠标左键、右键，可以看到新的跳跃效果： 跑道升级 为了让游戏有更久的生命力，我们需要一个很长的跑道来让Player在上面一直往右边跑，在场景中复制一堆Cube并编辑位置来组成跑道显然不是一个明智的做法，我们通过脚本完成跑道的自动创建。 游戏管理器（GameManager） 一般游戏都会有一个管理器，主要负责整个游戏生命周期的管理，可以将跑道的动态创建代码放到这里。在场景中创建一个名为GameManager的节点，然后在 assets/Scripts 中创建一个名为GameManager的ts脚本文件，并将它添加到GameManager节点上。 制作Prefab 对于需要重复生成的节点，我们可以将他保存成 Prefab（预制） 资源，作为我们动态生成节点时使用的模板。关于 Prefab 的更多信息，请阅读 预制资源（Prefab）。 我们将生成跑道的基本元素正方体（Cube）制作成Prefab，之后可以把场景中的三个Cube都删除了。 添加自动创建跑道代码 我们需要一个很长的跑道，理想的方法是能动态增加跑道的长度，这样可以永无止境的跑下去，这里为了方便我们先生成一个固定长度的跑道，跑道长度可以自己定义。跑道上会生成一些坑，跳到坑上就GameOver了。 将GameManager脚本中代码替换成以下代码： import { _decorator, Component, Prefab, instantiate, Node, CCInteger} from \"cc\"; const { ccclass, property } = _decorator; enum BlockType{ BT_NONE, BT_STONE, }; @ccclass(\"GameManager\") export class GameManager extends Component { @property({type: Prefab}) public cubePrfb: Prefab = null; @property({type: CCInteger}) public roadLength: Number = 50; private _road: number[] = []; start () { this.generateRoad(); } generateRoad() { this.node.removeAllChildren(true); this._road = []; // startPos this._road.push(BlockType.BT_STONE); for (let i = 1; i 在GameManager的inspector面板中可以通过修改roadLength的值来改变跑道的长度。 预览可以看到现在自动生成了跑道，不过因为Camera没有跟随Player移动，所以看不到后面的跑道，我们可以将场景中的Camera设置为Player的子节点。 这样Camera就会跟随Player的移动而移动，现在预览可以从头跑到尾的观察生成的跑道了。 增加开始菜单 开始菜单是游戏不可或缺的一部分，我们可以在这里加入游戏名称、游戏简介、制作人员等信息。 添加一个名为Play的按钮 这个操作生成了一个Canvas节点，一个PlayButton节点和一个Label节点。因为UI组件需要在带有 CanvasComponent 的父节点下才能显示，所以编辑器在发现目前场景中没有带这个组件的节点时会自动添加一个。 创建按钮后，将Label节点上的 cc.LabelComponent 的String属性从Button改为Play。 在Canvas底下创建一个名字为StartMenu的空节点，将PlayButton拖到它底下。我们可以通过点击工具栏上的2D/3D按钮来切换到2D编辑视图下进行UI编辑操作，详细的描述请查阅 场景编辑。 增加一个背景框，在StartMenu下新建一个名字为BG的Sprite节点，调节它的位置到PlayButton的上方，设置它的宽高为（200，200）,并将它的SpriteFrame设置为 internal/default_ui/default_sprite_splash 。 添加一个名为Title的 Label 用于开始菜单的标题，。 修改Title的文字，并调整Title的位置、文字大小、颜色。 增加操作的Tips，然后调整PlayButton的位置，一个简单的开始菜单就完成了 增加游戏状态逻辑，一般我们可以将游戏分为三个状态： 初始化（Init）：显示游戏菜单，初始化一些资源。 游戏进行中（Playing）：隐藏游戏菜单，玩家可以操作角度进行游戏。 结束（End）：游戏结束，显示结束菜单。 使用一个枚举（enum）类型来表示这几个状态。 enum BlockType{ BT_NONE, BT_STONE, }; enum GameState{ GS_INIT, GS_PLAYING, GS_END, }; GameManager脚本中加入表示当前状态的私有变量 private _curState: GameState = GameState.GS_INIT; 为了在开始时不让用户操作角色，而在游戏进行时让用户操作角色，我们需要动态的开启和关闭角色对鼠标消息的监听。 所以对PlayerController做如下的修改： start () { // Your initialization goes here. //systemEvent.on(SystemEvent.EventType.MOUSE_UP, this.onMouseUp, this); } setInputActive(active: boolean) { if (active) { systemEvent.on(SystemEvent.EventType.MOUSE_UP, this.onMouseUp, this); } else { systemEvent.off(SystemEvent.EventType.MOUSE_UP, this.onMouseUp, this); } } 然后需要在GameManager脚本中引用PlayerController，需要在Inspector中将场景的Player拖入到这个变量中。 @property({type: PlayerController}) public playerCtrl: PlayerController = null; 为了动态的开启\\关闭开启菜单，我们需要在GameManager中引用StartMenu节点，需要在Inspector中将场景的StartMenu拖入到这个变量中。 @property({type: Node}) public startMenu: Node = null; 增加状态切换代码，并修改GameManger的初始化方法： start () { this.curState = GameState.GS_INIT; } init() { this.startMenu.active = true; this.generateRoad(); this.playerCtrl.setInputActive(false); this.playerCtrl.node.setPosition(v3()); } set curState (value: GameState) { switch(value) { case GameState.GS_INIT: this.init(); break; case GameState.GS_PLAYING: this.startMenu.active = false; setTimeout(() => { //直接设置active会直接开始监听鼠标事件，做了一下延迟处理 this.playerCtrl.setInputActive(true); }, 0.1); break; case GameState.GS_END: break; } this._curState = value; } 添加对Play按钮的事件监听。 为了能在点击Play按钮后开始游戏，我们需要对按钮的点击事件做出响应。 在GameManager脚本中加入响应按钮点击的代码，在点击后进入游戏的Playing状态： onStartButtonClicked() { this.curState = GameState.GS_PLAYING; } 然后在Play按钮的Inspector上添加ClickEvents的响应函数。 现在预览场景就可以点击Play按钮开始游戏了。 添加游戏结束逻辑 目前游戏角色只是呆呆的往前跑，我们需要添加游戏规则，来让他跑的更有挑战性。 角色每一次跳跃结束需要发出消息，并将自己当前所在位置做为参数发出消息 在PlayerController中记录自己跳了多少步 private _curMoveIndex = 0; // ... jumpByStep(step: number) { // ... this._curMoveIndex += step; } 在每次跳跃结束发出消息： onOnceJumpEnd() { this._isMoving = false; this.node.emit('JumpEnd', this._curMoveIndex); } 在GameManager中监听角色跳跃结束事件，并根据规则判断输赢 增加失败和结束判断，如果跳到空方块或是超过了最大长度值都结束： checkResult(moveIndex: number) { if (moveIndex 监听角色跳跃消息，并调用判断函数： start () { this.curState = GameState.GS_INIT; this.playerCtrl.node.on('JumpEnd', this.onPlayerJumpEnd, this); } // ... onPlayerJumpEnd(moveIndex: number) { this.checkResult(moveIndex); } 此时预览，会发现重新开始游戏时会有判断出错，是因为我们重新开始时没有重置PlayerController中的_curMoveIndex属性值。所以我们在PlayerController中增加一个reset函数： reset() { this._curMoveIndex = 0; } 在GameManager的init函数调用reset来重置PlayerController的属性。 init() { \\\\ ... this.playerCtrl.reset(); } 步数显示 我们可以将当前跳的步数显示到界面上，这样在跳跃过程中看着步数的不断增长会十分有成就感。 在Canvas下新建一个名为Steps的Label，调整位置、字体大小等属性。 在GameManager中引用这个Label @property({type: LabelComponent}) public stepsLabel: LabelComponent = null; 将当前步数数据更新到这个Label中 因为我们现在没有结束界面，游戏结束就跳回开始界面，所以在开始界面要看到上一次跳的步数，因此我们在进入Playing状态时，将步数重置为0。 set curState (value: GameState) { switch(value) { case GameState.GS_INIT: this.init(); break; case GameState.GS_PLAYING: this.startMenu.active = false; this.stepsLabel.string = '0'; // 将步数重置为0 setTimeout(() => { //直接设置active会直接开始监听鼠标事件，做了一下延迟处理 this.playerCtrl.setInputActive(true); }, 0.1); break; case GameState.GS_END: break; } this._curState = value; } 在响应角色跳跃的函数中，将步数更新到Label控件上 onPlayerJumpEnd(moveIndex: number) { this.stepsLabel.string = '' + moveIndex; this.checkResult(moveIndex); } 光照和阴影 有光的地方就会有影子，光和影构成明暗交错的3D世界。接下来我们为角色加上简单的影子。 开启阴影 在 层级管理器 中点击最顶部的 Scene 节点，将planarShadows选项中的Enabled打钩，并修改Distance和Normal参数 点击Player节点下的Body节点，将 cc.ModelComponent 下的ShadowCastingMode设置为ON。 此时在场景编辑器中会看到一个阴影面片，预览会发现看不到这个阴影，因为它在模型的正后方，被胶囊体盖住了。 调整光照 新建场景时默认会添加一个 DirctionalLight ，由这个平行光计算阴影，所以为了让阴影换个位置显示，我们可以调整这个平行光的方向。 在 层级管理器 中点击选中 Main Light 节点，调整Rotation参数为（-10，17，0）。 预览可以看到影子效果： 添加主角模型 做为一个官方教程，用胶囊体当主角显的有点寒碜，所以我们花（低）重（预）金（算）制作了一个Cocos主角。 导入模型资源 从原始资源导入模型、材质、动画等资源不是本篇基础教程的重点，所以这边直接使用已经导入工程的资源。 将项目工程中assets目录下的cocos文件夹拷贝到你自己工程的assets目录下。 添加到场景中 在cocos文件中已经包含了一个名为Cocos的Prefab，将它拖到场景中Player下的Body节点中。 此时会发现模型有些暗，可以加个聚光灯，以突出它锃光瓦亮的脑门。 添加跳跃动画 现在预览可以看到主角初始会有一个待机动画，但是跳跃时还是用这个待机动画会显得很不协调，所以我们在跳跃过程中换成跳跃的动画。 在 PlayerController 类中添加一个引用模型动画的变量： @property({type: SkeletalAnimationComponent}) public CocosAnim: SkeletalAnimationComponent = null; 然后在Inspector中要将Cocos节点拖入这个变量里。 在jumpByStep函数中播放跳跃动画 jumpByStep(step: number) { if (this._isMoving) { return; } this._startJump = true; this._jumpStep = step; this._curJumpTime = 0; this._curJumpSpeed = this._jumpStep / this._jumpTime; this.node.getPosition(this._curPos); Vec3.add(this._targetPos, this._curPos, v3(this._jumpStep, 0, 0)); this._isMoving = true; this.CocosAnim.getState('cocos_anim_jump').speed = 3.5; //跳跃动画时间比较长，这里加速播放 this.CocosAnim.play('cocos_anim_jump'); //播放跳跃动画 if (step === 1) { //this.BodyAnim.play('oneStep'); } else if (step === 2) { this.BodyAnim.play('twoStep'); } this._curMoveIndex += step; } 在onOnceJumpEnd函数中让主角变为待机状态，播放待机动画。 onOnceJumpEnd() { this._isMoving = false; this.CocosAnim.play('cocos_anim_idle'); this.node.emit('JumpEnd', this._curMoveIndex); } 预览效果： 最终代码 PlayerController.ts import { _decorator, Component, Vec3, systemEvent, SystemEvent, EventMouse, AnimationComponent, SkeletalAnimationComponent, v3 } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"PlayerController\") export class PlayerController extends Component { @property({type: AnimationComponent}) public BodyAnim: AnimationComponent = null; @property({type: SkeletalAnimationComponent}) public CocosAnim: SkeletalAnimationComponent = null; // for fake tween private _startJump: boolean = false; private _jumpStep: number = 0; private _curJumpTime: number = 0; private _jumpTime: number = 0.3; private _curJumpSpeed: number = 0; private _curPos: Vec3 = v3(); private _deltaPos: Vec3 = v3(0, 0, 0); private _targetPos: Vec3 = v3(); private _isMoving = false; private _curMoveIndex = 0; start () { } reset() { this._curMoveIndex = 0; } setInputActive(active: boolean) { if (active) { systemEvent.on(SystemEvent.EventType.MOUSE_UP, this.onMouseUp, this); } else { systemEvent.off(SystemEvent.EventType.MOUSE_UP, this.onMouseUp, this); } } onMouseUp(event: EventMouse) { if (event.getButton() === 0) { this.jumpByStep(1); } else if (event.getButton() === 2) { this.jumpByStep(2); } } jumpByStep(step: number) { if (this._isMoving) { return; } this._startJump = true; this._jumpStep = step; this._curJumpTime = 0; this._curJumpSpeed = this._jumpStep / this._jumpTime; this.node.getPosition(this._curPos); Vec3.add(this._targetPos, this._curPos, v3(this._jumpStep, 0, 0)); this._isMoving = true; this.CocosAnim.getState('cocos_anim_jump').speed = 3.5; //跳跃动画时间比较长，这里加速播放 this.CocosAnim.play('cocos_anim_jump'); //播放跳跃动画 if (step === 1) { //this.BodyAnim.play('oneStep'); } else if (step === 2) { this.BodyAnim.play('twoStep'); } this._curMoveIndex += step; } onOnceJumpEnd() { this._isMoving = false; this.CocosAnim.play('cocos_anim_idle'); this.node.emit('JumpEnd', this._curMoveIndex); } update (deltaTime: number) { if (this._startJump) { this._curJumpTime += deltaTime; if (this._curJumpTime > this._jumpTime) { // end this.node.setPosition(this._targetPos); this._startJump = false; this.onOnceJumpEnd(); } else { // tween this.node.getPosition(this._curPos); this._deltaPos.x = this._curJumpSpeed * deltaTime; Vec3.add(this._curPos, this._curPos, this._deltaPos); this.node.setPosition(this._curPos); } } } } GameManager.ts import { _decorator, Component, Prefab, instantiate, Node, LabelComponent, CCInteger, v3} from \"cc\"; import { PlayerController } from \"./PlayerController\"; const { ccclass, property } = _decorator; enum BlockType{ BT_NONE, BT_STONE, }; enum GameState{ GS_INIT, GS_PLAYING, GS_END, }; @ccclass(\"GameManager\") export class GameManager extends Component { @property({type: Prefab}) public cubePrfb: Prefab = null; @property({type: CCInteger}) public roadLength: Number = 50; private _road: number[] = []; @property({type: Node}) public startMenu: Node = null; @property({type: PlayerController}) public playerCtrl: PlayerController = null; private _curState: GameState = GameState.GS_INIT; @property({type: LabelComponent}) public stepsLabel: LabelComponent = null; start () { this.curState = GameState.GS_INIT; this.playerCtrl.node.on('JumpEnd', this.onPlayerJumpEnd, this); } init() { this.startMenu.active = true; this.generateRoad(); this.playerCtrl.setInputActive(false); this.playerCtrl.node.setPosition(v3()); this.playerCtrl.reset(); } set curState (value: GameState) { switch(value) { case GameState.GS_INIT: this.init(); break; case GameState.GS_PLAYING: this.startMenu.active = false; this.stepsLabel.string = '0'; // 将步数重置为0 setTimeout(() => { //直接设置active会直接开始监听鼠标事件，做了一下延迟处理 this.playerCtrl.setInputActive(true); }, 0.1); break; case GameState.GS_END: break; } this._curState = value; } generateRoad() { this.node.removeAllChildren(); this._road = []; // startPos this._road.push(BlockType.BT_STONE); for (let i = 1; i 总结 恭喜您完成了用 Cocos Creator 3D 制作的第一个游戏！在 这里 可以下载完整的工程，希望这篇快速入门教程能帮助您了解 Cocos Creator 3D 游戏开发流程中的基本概念和工作流程。如果您对编写和学习脚本编程不感兴趣，也可以直接从完成版的项目工程中把写好的脚本复制过来使用。 接下来您还可以继续完善游戏的各方各面，以下是一些推荐的改进方向： 为游戏增加难度，当角色在原地停留1秒就算失败 改为无限跑道，动态的删除已经跑过的跑道，延长后面的跑道。 增加游戏音效 为游戏增加结束菜单界面，统计玩家跳跃步数和所花的时间 用更漂亮的资源替换角色和跑道 可以增加一些可拾取物品来引导玩家“犯错” 添加一些粒子特效，例如角色运动时的拖尾、落地时的灰尘 为触屏设备加入两个操作按钮来代替鼠标左右键操作 此外如果希望将完成的游戏发布到服务器上分享给好友玩耍，可以阅读 发布工作流 一节的内容。 "},"editor/publish/publish-baidu-mini-game.html":{"url":"editor/publish/publish-baidu-mini-game.html","title":"发布到百度小游戏","keywords":"","body":"发布到百度小游戏 Cocos Creator 3D从 v1.0.3 版本开始正式支持将游戏发布到百度小游戏。 百度小游戏是基于手机百度 app 上的智能小程序进行扩展的小游戏，它不仅提供了强大的游戏能力，还和智能小程序一样，提供了大量的原生接口，比如支付，文件系统，位置，分享等。相当于同时结合了 WEB 易于传播以及 Native 功能丰富的优势。 百度小游戏的运行环境和微信小游戏类似，基本思路也是封装必要的 WEB 接口提供给用户，尽可能追求和 WEB 同样的开发体验。百度小游戏在智能小程序环境的基础上提供了 WebGL 接口的封装，使得渲染能力和性能有了大幅度提升。不过由于这些接口都是百度团队通过自研的原生实现封装的，所以并不可以等同为浏览器环境。 作为引擎方，为了尽可能简化开发者的工作量，我们为用户完成的主要工作包括： 引擎框架适配百度小游戏 API，纯游戏逻辑层面，用户不需要任何额外的修改 Cocos Creator 3D编辑器提供了快捷的打包流程，直接发布为百度小游戏 自动加载远程资源，缓存资源以及缓存资源版本控制 具体百度小游戏的申请入驻，开发准备，游戏提交，审核和发布流程可以参考 百度小游戏注册指导文档。 使用 Cocos Creator 3D 发布百度小游戏 准备工作 在 百度开发者工具文档 里下载并安装百度开发者工具 在手机的应用商店中下载并安装百度应用 登录 智能小程序平台，找到 appid 发布流程 在 构建发布 面板中选择 发布平台 为 百度小游戏，填入 appid，然后点击 构建。 构建完成后，会在发布包的目录下生成一个 baidugame 的百度小游戏工程文件夹，其中已经包含了百度小游戏环境的配置文件：game.json 和 project.swan.json 使用 百度开发者工具 打开构建生成的 baidugame 文件夹，即可打开百度小游戏项目及预览调试游戏内容。百度开发者工具 的使用方式请参考 百度开发者工具文档。 注意： 请不要升级 百度开发者工具 到 2.0.10 版本。 预览调试时若出现了 当前版本的开发者工具无法发布小程序，请更新最新的开发者工具 的提示，说明填写的 appid 是小程序的 appid，不是小游戏的 appid，请重新申请一个小游戏 appid。 百度小游戏环境的资源管理 百度小游戏与微信小游戏类似，都存在着包体限制，超过 4MB 的额外资源，必须通过网络请求下载。 我们建议用户只保存脚本文件在小游戏包内，其他资源都从远程服务器下载。Cocos Creator 3D已经帮用户做好了远程资源的下载、缓存和版本管理。具体的实现逻辑和微信小游戏类似，具体可参考 微信小游戏资源管理。 同时，当开启引擎的 md5Cache 功能后，文件的 url 会随着文件内容的改变而改变，这样当游戏发布新版本后，旧版本的资源在缓存中就自然失效了，只能从服务器请求新的资源，也就达到了版本控制的效果。 具体来说，开发者需要做的是： 构建时，在 构建发布 面板中勾选 md5Cache 功能。 设置 远程服务器地址，然后点击 构建。 构建完成后将百度小游戏发布包目录下的 res 文件夹完整的上传到服务器。 删除本地发布包目录下的 res 文件夹。 注意： 百度在真机上加载远程服务器上的资源时，目前只支持通过 https 访问，所以必须将资源文件放在 https 服务器上，否则会出现加载资源失败的情况。 如果缓存资源超过百度环境限制，用户需要手动清除资源，可以在百度小游戏中使用 remoteDownloader.cleanAllCaches() 和 remoteDownloader.cleanOldCaches() 接口来清除缓存。前者会清除缓存目录下的所有缓存资源，请慎重使用；而后者会清除缓存目录下目前应用中未使用到的缓存资源。 百度小游戏分包加载 百度小游戏的分包加载方式和微信小游戏类似，其包体限制如下： 所有包的总大小不超过 8MB 单个分包/主包大小不超过 4MB 具体的分包加载机制可参考 分包加载。 平台 SDK 接入 除了纯游戏内容以外，百度小游戏环境还提供了非常强大的原生 SDK 接口，这些接口都是仅存在于百度小游戏环境中的，等同于其他平台的第三方 SDK 接口。这类 SDK 接口的移植工作在现阶段还是需要开发者自己处理。下面列举一些百度小游戏所提供的强大 SDK 能力： 用户接口：登陆，授权，用户信息等 百度收银台支付 转发信息 文件上传下载 其他：图片、位置、广告、设备信息等等 百度小游戏已知问题： 目前 Cocos Creator 3D 对百度小游戏的适配工作还未完全结束，暂时还不支持以下组件： VideoPlayer WebView 参考链接 百度小游戏注册指导文档 百度开发者工具文档 百度小游戏 API 文档 "},"module-map/":{"url":"module-map/","title":"功能地图","keywords":"","body":"引擎功能地图导览 图形渲染渲染系统，包括材质，光照，粒子等 UI系统UI系统，包括与UI 相关的全部内容 动画系统基于动画帧数据及骨骼顶点数据的通用动画及骨骼动画体系 音频控制声音片段的播放暂停等 物理模拟物理仿真模拟，主要包括刚体和碰撞等 脚本指南及事件系统用于实现用户定义行为的脚本使用指南，包括事件的触发机制等 组件用于为游戏对象添加不同功能的组件说明 资源引擎使用到的各种不同资源介绍及整体资源工作流概述 场景及环境设置场景结构及环境相关设置 "},"module-map/graphics.html":{"url":"module-map/graphics.html","title":"图形渲染","keywords":"","body":"图形渲染 材质着色器控制的模型表面外形 光照光照、阴影控制及环境设置 粒子系统各种类型粒子特效的创建及使用 "},"ui-system/components/editor/ui-coordinate-tracker.html":{"url":"ui-system/components/editor/ui-coordinate-tracker.html","title":"UICoordinateTracker 组件参考","keywords":"","body":"UICoordinateTracker UI 坐标跟踪映射组件 该组件是在 UI 上执行坐标转换以及模拟透视相机下 3D 物体近大远小效果。通过事件的方式将转换后的坐标以及物体在视口下的占比返回。适用于 3D 人物血条以及姓名条之类功能。 UICoordinateTracker 属性 属性 功能说明 Target 目标对象。需要转换到哪一个 UI 节点下。 Camera 照射相机。 UseScale 是否是缩放映射。如果是透视相机，勾选此项，返回一个物体在视口下的占比。 Distance 距相机多少距离为正常显示计算大小。根据模型在相机下的照射效果调整最佳位置，以该位置为分界线计算在视口占比。 CoordinateDataEvents 映射数据事件。回调的第一个参数是映射后的本地坐标，第二个是距相机距离比。 案例可参照：https://github.com/cocos-creator/demo-ui/tree/3d 的 rocker 场景。 该组件即将在 1.2 版本上移除。 "},"submit-pr/submit-pr.html":{"url":"submit-pr/submit-pr.html","title":"向 Cocos 提交代码","keywords":"","body":"如何向 Cocos 提交代码 和 Cocos2d-x-lite 一样，Cocos Creator 3D 也是一个开源引擎，连同范例、文档都是开源的。 在你开发游戏的过程中，当发现了引擎、文档或者范例不够完善的地方，如果仅仅是向官方团队提出建议，官方团队可能会因为人力资源的紧张而无法及时跟进。在此我们欢迎所有用户主动向我们提交 PR，帮助 Cocos 越做越好。引擎有 Bug？提 PR！范例难看？提 PR！API 注释不清晰？提 PR！文档有错别字？提 PR！想要把你的宝贵修改贡献给游戏社区？提 PR！以下几个是目前官方比较常用的开源仓库，这些仓库都可以提交 PR。 JavaScript 引擎：https://github.com/cocos-creator/engine/tree/3d Cocos2d-x-lite 引擎：https://github.com/cocos-creator/cocos2d-x-lite jsb-adapter：https://github.com/cocos-creator-packages/jsb-adapter 下面让我们来看一下，如何从零开始在 GitHub 上向 Cocos 提交代码。 注册一个 GitHub 账号 打开 GitHub 网站 注册账号。若之前已经有注册过，那直接登录就可以了。 环境配置 安装 Git 首先先确认电脑是否已经安装 Git，命令行输入 git，安装过则会输出以下内容： 未安装过则 下载 Git 并安装。安装过程中的所有选项保留默认就可以了，一直点 next，直到安装完成。 安装 Git 客户端 —— GitKraken GitKraken 是比较常用的 Git 客户端工具。如果不使用 GitKraken 的话，Git 操作全部要通过命令行操作完成，比较麻烦。下面以 Windows 版本为例进行演示。 1、下载 GitKraken 并解压缩，进行安装。 安装完成后界面如下图所示： Fork 项目 以手册文档的代码仓库 docs-3d 为例。进入手册文档仓库页面，点击右上角的 Fork 按钮，如下图所示： Fork 完成后，会自动跳转到你的 GitHub 仓库页面，可以看到已经生成了 docs-3d 项目副本，如下图所示： 将远程仓库克隆到本地仓库 1、首先需要到你的远程仓库复制 远程仓库项目地址，如下图所示： 2、切换到 GitKraken 后点击上方的 Clone a repo 按钮，跳转到 Clone 页面，粘贴刚才复制的 远程仓库项目地址，然后填入相关配置。如果想让本地的文件夹名称和项目名称一样，那么在本地存储路径后添加 /docs-3d。配置完成后点击 Clone。 克隆完成后就会在本地自动创建 docs-3d 文件夹并且在 GitKraken 上自动打开项目。 上传本地修改到远程仓库 1、检出需要的分支。在左侧的 REMOTE 目录下有一个 origin 仓库，这是你自己的远程仓库。例如要修改的分支是 next 分支，则点击 origin 后双击 next 分支。如下图所示： 注意：根据不同的版本，还需要切换不同的分支，例如： vX.Y 分支：对应 X.Y 版本所用分支 next 分支： 用于 2.0 分支 master/develop 分支：当前最新版本所用分支 2、打开本地 docs-3d 项目进行修改，修改完成后查看仓库详情，如下图所示： 3、提交暂存区文件到本地仓库。将你要上传的修改文件提交到本地暂存区，然后在下方备注提交内容注释。完成之后点击 Commit，将暂存区文件提交到本地仓库。完成后点击 Push 。步骤如下图所示： 4、将本地仓库的修改推送到自己的远程仓库 origin。 5、完成之后，到 GitHub 自己的 docs-3d 远程仓库查看（可以从 右上方的头像 -> Your profile -> Repositories -> docs-3d 进入你的远程仓库），可以看到已经有本次的提交信息了。然后点击 New pull request。 6、点击 New pull request 后会跳转到官方仓库的 Open a pull request。标题会自动填入刚才提交的信息，也可自行修改。下方的填写信息区域需要对提交内容进行适当的补充。特别是针对引擎本身的修改，请将问题描述、改动内容、涉及版本、相关平台等信息补充完整。如果有相关 Issue，或者论坛地址也可以贴上来。最下方的是本次提交的 PR 的改动详情。填写完成后点击 Create pull request。 7、创建完成后在官方仓库 docs-3d 的 pull requests 页面中可以看到创建了一个新的 PR。官方人员会收到提醒并将 PR 指派给相关人员进行 review 和合并。到此 PR 创建完成，若官方审核通过，就会把这个 PR 的修改合并到官方仓库中了。如果上方的Open图标变为Merged图标，则表示修改已合并到官网。若官方觉得有需要，也会在该 PR 上展开进一步讨论。请留意 GitHub 相关消息或关注 PR 所在页面，以免错过讨论。如果你需要修改 PR 提交的内容，请重复 上传本地修改到远程仓库 中的 2、3、4 步骤。 添加官方仓库 如果距离上次克隆仓库已经挺长时间，那么请在提交 PR 前先从官方仓库获取最新的修改以防和其他人的修改发生冲突。 1、添加官方仓库。点击 GitKraken 左边列表的 REMOTE + ，如下图所示： 2、在 GitKraken 的 docs-3d 本地仓库的左侧，可以看到有 origin 和 cocos-creator3D 两个远程仓库，分别是自己的远程仓库和官方仓库。可以看到 远程 -> cocos-creator3D 下已经有了官方仓库的各个分支，如下图所示： 3、从官方仓库拉取最新更新。切换到要拉取的分支，然后点击左上方的 Pull。如下图所示： 注意：在更新官方版本前，如果你完全不熟悉 Git 的操作，建议先确保没有在本地的 Git 仓库中进行任何文件的改动。如果有的话，建议先手动还原，然后等更新完毕后再手动把改动添加回来。 如何反馈文档有关的问题 针对文档本身的问题，建议通过 GitHub issue 进行反馈，下面我们简单演示一下。在提交问题之前请先确认： 文档版本和 Creator 3D 版本是否一致 操作步骤是否正确 是否是文档本身的问题，例如代码错误或者根据文档步骤执行出现异常等。 若以上问题都是确定的，那么，有以下两种提交方式： 1、可在 creator 3D 官方文档的右下方点击 提交反馈 进入提交 issue 界面。 填写完成后点击 Submit new issue 提交 issue，就完成了。 2、或者也可以进入官方仓库 docs-3d，选择 Issue -> New issue 进入提交 issue 界面，填写内容并提交。 本次提交 pr 和提交 issue 的教程到这里就结束了，若有不理解或者有误的地方请根据上述步骤向我们反馈。 有些人可能会问，为什么要这么麻烦的提交问题。其实，正确的提交问题可以节省很多的沟通成本，而且有些问题可能在初步排查的时候就可以解决了，或者会发现只是由于自己粗心大意导致的。而官方节省下来的人力就可以更好的去服务于 Creator 3D ，让 Creator 3D 能更好地为游戏开发者服务。 "}}