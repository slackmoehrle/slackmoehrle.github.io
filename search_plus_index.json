{"./":{"url":"./","title":"Introduction","keywords":"","body":"Cocos Creator 3D 用户手册 欢迎使用 Cocos Creator 3D 用户手册！本手册包括详尽的使用说明、面向不同职能用户的工作流程和 step by step 的新手教程。能够帮您快速掌握使用 Cocos Creator 3D 开发跨平台游戏的方法。 注意：请在右上角根据您使用的 Cocos Creator 3D 版本选择相应的手册版本。 总导读 使用功能地图快速了解引擎功能 功能地图 图形渲染 材质 光照 粒子系统 UI系统 动画系统 音频 物理模拟 脚本指南及事件系统 组件 资源 场景及环境设置 新手入门 新手上路 Dashboard Hello world! 快速上手：制作第一个游戏 注意事项 编辑器手册 快速入门 面板介绍 项目预览调试 粒子编辑器 动画系统 地形系统 构建发布 从第三方工具导出模型资源 引擎手册 场景及环境 光照 材质 声音 粒子 动画 缓动 物理 UI 组件 可定制的渲染管线 脚本指南及事件机制 资源手册 演示和范例项目 展示范例集合：从基本组件的使用到渲染效果的展示，这个项目里包括了多个侧重功能不同的场景及多个游戏 Demo 供用户参考 一步两步：也就是 快速上手 文档里分步讲解制作的游戏 物理测试范例: 包含了一些物理测试例和一些案例工程，如吞噬黑洞、简化小车、坠落小球等，测试例和案例介绍了一些基础的功能和使用方法，方便您结合文档了解物理功能 Simple-Games：简单小游戏集合演示 Demo, 用户可通过此案例学习完成一些简单并且常见的小游戏 模块展示集合: 引擎各个功能的范例项目，基本涵盖了引擎的大部分功能模块，用户在使用功能时可参考此项目中的用法进行开发 UI 展示 Demo：各类 UI 组件组合使用的演示 Demo 弹弹乐 3D：用户可通过此项目制作弹弹球游戏。 快上车 3D：基于物理的游戏制作 demo，用户可通过此项目制作快上车游戏。 注意，这些项目会不定期跟随版本进行更新。它们在 GitHub 上的默认分支是 master，对应的一般是最新的 Cocos Creator 3D 及 版本。如果仍在使用旧版本的 Cocos Creator 3D，这些项目有可能会打不开，可尝试切换到和旧版本相同命名的分支。 项目视频教程 快上车视频教程 "},"getting-started/dashboard/":{"url":"getting-started/dashboard/","title":"Dashboard","keywords":"","body":"使用Dashboard Dashboard为起始页，您可以浏览、创建、导入项目。 界面总览 打开项目 选择标签栏的打开项目 新建项目 选择标签栏的新建项目，并选择一个项目模板及路径后，点击下方的新建项目按钮。 帮助 选择标签栏的帮助，帮助能使您对cocos creator有一个初步的了解。 "},"getting-started/attention/":{"url":"getting-started/attention/","title":"注意事项","keywords":"","body":"注意事项 语法格式 Cocos Creator 3D 不同于 Cocos Creator 的语法格式，Cocos Creator 3D 已全面支持 ES6 和 TS，因此在 Cocos Creator 3D 上只支持 ES6 和 TS 的 class，此外，我们还支持了 TS 的语法提示。针对 Cocos Creator 支持 ES5 语法的 cc.Class 形式已不再作出支持，请各位开发者悉知。 "},"editor/":{"url":"editor/","title":"面板介绍","keywords":"","body":"编辑器界面介绍 这一章将会介绍编辑器界面，熟悉组成编辑器的各个面板、菜单和功能按钮。Cocos Creator 编辑器由多个面板组成，面板可以自由移动、组合，以适应不同项目和开发者的需要。我们在这里将会以默认编辑器布局为例，快速浏览各个面板的名称和作用： 场景编辑器 场景编辑器 是用来展示和编辑场景中可视内容的工作区域。所见即所得的场景搭建工作都依靠场景编辑器中的显示来完成。 详情请阅读 场景编辑器 一节。 层级管理器 层级管理器 用树状列表的形式展示场景中的所有节点和他们的层级关系，所有在 场景编辑器 中看到的内容都可以在 层级管理器 中找到对应的节点条目，在编辑场景时这两个面板的内容会同步显示，一般我们也会同时使用这两个面板来搭建场景。 详情请阅读 层级管理器 一节。 资源管理器 资源管理器 里显示了项目资源文件夹（assets）中的所有资源。这里会以树状结构显示文件夹并自动同步在操作系统中对项目资源文件夹内容的修改。您可以将文件从项目外面直接拖拽进来，或使用菜单导入资源。 详情请阅读 资源管理器 一节。 属性检查器 属性检查器 是我们查看并编辑当前选中节点和组件属性的工作区域，这个面板会以最适合的形式展示和编辑来自脚本定义的属性数据。 详情请阅读 属性检查器 一节。 控制台 控制台 会显示报错、警告或其他编辑器和引擎生成的日志信息。 详情请阅读 控制台 一节。 动画编辑器 动画编辑器 可以编辑并存储动画数据。 详情请阅读 熟悉动画编辑器 一节。 偏好设置 偏好设置 里提供各种编辑器个性化的全局设置，包括原生开发环境、游戏预览、其他插件的全局设置等。 详情请阅读 偏好设置 一节。 项目设置 项目设置 里提供各种项目特定的个性化设置，包括分组管理、模块设置、项目预览、自定义引擎等。 详情请阅读 项目设置 一节。 "},"editor/scene/":{"url":"editor/scene/","title":"场景编辑器","keywords":"","body":"场景编辑器 场景编辑器 是内容创作的核心工作区域，您将使用它选择和摆放场景图像、角色、特效、UI 等各类游戏元素。在这个工作区域里，您可以选中并通过 变换工具 修改节点的位置、旋转、缩放、尺寸等属性，并可以获得所见即所得的场景效果预览。 视图介绍 导航 3D视图和2D视图的导航方式有所不同，通过工具栏中的3D/2D按钮可以切换3D和2D视图，3D视图用于3D场景编辑，2D视图主要用于UI，Sprite等2D元素的编辑。 3D视图 在3D视图下，您可以通过以下操作来移动和定位 场景编辑器 的视图： 鼠标左键+Alt：摄像机围绕视图中心点旋转。 鼠标中键：平移视图。 鼠标滚轮：摄像机前后移动。 鼠标右键+WASD：摄像机漫游。 F 快捷键：摄像机聚焦到当前选中节点。 2D视图 在2D视图下，您可以通过以下操作来移动和定位 场景编辑器 的视图： 鼠标中键：平移视图。 鼠标滚轮：以当前鼠标悬停位置为中心缩放视图。 鼠标右键：平移视图。 F 快捷键：摄像机聚焦到当前选中节点。 坐标系和网格 场景中网格是我们摆放场景元素时位置的重要参考信息，关于坐标系和位置等节点属性的关系，请阅读 坐标系和变换 一节 场景Gizmo 场景Gizmo在场景视图的右上角，它显示了当前场景相机的观察方向，可以通过点击它来快速切换不同的观察角度。 点击6个方向轴，可以快速切换到上，下，左，右，前，后六个角度来观察场景。 点击中心的立方体，可以在正交视图和透视视图间切换。 选择节点 在场景视图中点击鼠标左键选择物体所在节点，选择节点是使用变换工具设置节点位置、旋转、缩放等操作的前提。 Gizmo 操作简介 场景编辑器 的核心功能就是以所见即所得的方式编辑和布置场景中的可见元素，我们主要通过 Gizmo 工具来辅助完成场景的可视化编辑。 变换工具Gizmo 摄像机Gizmo 灯光Gizmo 碰撞器Gizmo 粒子系统Gizmo "},"editor/hierarchy/":{"url":"editor/hierarchy/","title":"层级管理器","keywords":"","body":"层级管理器 层级面板 面板上主要有顶部菜单区，底部树形列表区。用来展现当前场景里可编辑的节点之间的关系。场景中仍有一些不可见的私有节点，不会在此显示。 你可以单选，多选，创建，复制，移动，删除，重命名节点，任意节点都可创建出子节点，子节点的坐标相对于父级节点，跟随父级节点移动。 顶部菜单的功能有：新建节点按钮 ，搜索类型按钮 ，搜索框，全部折叠或展开按钮 ，刷新列表按钮 。 树形列表区主要体现节点的层级关系，根节点是 场景节点，编辑 prefab 文件时，自身的节点作为根节点。 选中节点，节点呈现蓝底白字的高亮状态，节点的详细属性会在 属性检查器 中显示。点击树形空白区域，可以 取消选中。 面板按钮和节点支持右击菜单指令。 面板支持键盘快捷方式： 复制：Ctrl or Cmd + C 粘贴：Ctrl or Cmd + V 克隆：Ctrl or Cmd + D，Ctrl + 拖动节点 删除：Delete 上下选择：上下箭头 节点的折叠：左箭头 节点的展开：右箭头 多选：Ctrl or Cmd + 点击 多选：Shift + 点击 重命名： Enter/F2 取消输入：Esc 新建节点 点击 新建节点按钮 新增节点的时候，会先出现一个 输入框 要求填入节点的名称，节点的名称允许为空。 树形列表中如果没有选中项，则默认新建到当前根节点上； 如果有多个选中项，此时会新建到第一个选中节点里。 此外节点的右击菜单中也有 新建 的入口。 对于 UI 节点，为了让其正常显示，它的任意上级节点至少得有一个含有 cc.UITransformComponent 组件，所以创建的时候，如果不符合规则，会辅助添加一个 Canvas 节点作为它的父级。 此外可以通过 资源管理器 中拖动一个 prefab 资源到 层级管理器 里生成一个节点。 可以通过 层级管理器 中拖动一个 prefab 节点到 资源管理器 里生成一个资源。 移动节点 移动分为被移动的节点 和 目标放置节点，其中对 目标放置节点 的高度进行偏上，中部，偏下三部分识别，分别表示： 偏上，将 被移动的节点 移到 目标放置节点 的上方，两者是平级的。 中部，将 被移动的节点 移到 目标放置节点 的内部，排在最末尾。 偏下，将 被移动的节点 移到 目标放置节点 的下方，两者是平级的。 搜索节点 搜索类型有：搜索名称，搜索 UUID，搜索 Path，搜索组件名称。 其中 搜索组件名称 是搜索节点组件，可在 属性检查器 查看到组件名称，如 cc.ModelComponent 搜索框 是即时变动搜索的，在搜索结果中选中节点，清空搜索内容后，会重新定位到该选中的节点。 重命名节点 选中某个节点，通过快捷键 Enter 或者 F2， 或通过右击菜单的 重命名 可以进入修改名称，节点名称允许为空，按快捷键 Esc 能取消此次重命名。 不同节点可以有相同的名称。 "},"editor/assets/":{"url":"editor/assets/","title":"资源管理器","keywords":"","body":"资源管理器 资源管理器 面板是我们用来访问和管理项目资源的重要工具。 在开始制作游戏时，导入资源 通常是必须的步骤。您可以在新建项目时使用模板项目，新建步骤完成后会自动打开项目，默认布局中包含了 资源管理器 面板，里面有两个资源库，简称 DB，assets 和 internal, internal 属于默认的内置资源，内置资源可以复制出来，但不能直接修改。 面板操作预览 面板介绍 资源管理器 面板上主要有 头部菜单区， 树形列表区： 头部菜单区 的功能有：新建资源按钮 ，排序方式按钮 ，搜索过滤 ，搜索框，全部折叠或展开按钮 ，刷新列表按钮 树形列表区 主要体现资源之间的关系，根节点如 assets 类似操作系统里的文件管理器，编辑器中称之为一个 DB assets 是项目资源，新项目下默认为空； internal 是内置资源，属于只读资源，不可进行增删改操作，但可以作为资源模板，复制到 Assets DB 上进行粘贴，即新建了一个项目资源。 面板和节点都有右击菜单事件，是重要的操作功能，灰色为不可用菜单。 面板的快捷方式目前支持资源的操作： 复制：Ctrl or Cmd + C 粘贴：Ctrl or Cmd + V 克隆：Ctrl or Cmd + D，Ctrl + 拖动资源 删除：Delete 上下选择：上下箭头 文件夹的折叠：左箭头 文件夹的展开：右箭头 多选：Ctrl or Cmd + 点击 多选：Shift + 点击 重命名： Enter/F2 取消输入：Esc 新建资源 + 号是 assets 新建资源按钮，或者文件夹的右击菜单，都可以进入创建资源。 文件夹内新增资源，会先出现一个 输入框 要求填入新资源的名称，名称不能为空。 选中资源 在列表中可以使用以下操作选中资源： 单击可单选资源 键盘上下箭头可以上下切换选中资源 按住 Ctrl or Cmd + 点击，可以多选资源 按住 Shift + 点击，可以多选资源 移动资源 通过拖动来实现资源的移动： 移动资源，资源从树形列表中的一个文件夹里拖出到另一个文件夹，此时会有一个目标文件夹的位置框跟随变动。 拖出资源到 场景面板 或 层级面板 去生成节点，目前支持 cc.Prefab, cc.Mesh, cc.SpriteFrame 资源。 从 系统的文件管理器 拖动文件到列表中，实现导入资源。 拖入节点，从 层级面板 拖动节点到 资源面板 里某个文件夹，可实现保存该节点为一个 cc.Prefab 资源, 详见 预制资源（Prefab）； 删除资源 可操作右击菜单中的 删除 按钮，或快捷键 Delete，支持多选后批量删除，资源删除后保留在 系统的回收站 里，必要时可将其还原。 在文件夹内全选 右击菜单中的 全选 可实现在该文件夹内全选子资源。 在文件夹内搜索 右击菜单中的 文件夹内搜索 可缩小搜索范围。 在文件管理器中显示 右击菜单中的 在文件管理器中显示 可定位资源所在的系统目录。 重新导入资源 右击菜单中的 重新导入资源 可以更新项目里 ./library 内对应的资源，这些生成过的数据才可被编辑器和引擎识别；支持多选后批量重新导入。 排序资源 头部菜单中的 排序方式按钮 有 2 种排序方式：按名称排序，按类型排序， 排序方式有记忆，下次打开编辑器会保持已存的排序方式。 搜索资源 搜索功能是一种组合的功能，可限定搜索类型，且指定搜索字段。 限定搜索类型 是一个大前提，这点需要特别注意，可能会导致树形列表为空，该按钮高亮即表示有启用该功能。 可多选，选择类型里面的 All 才能返回正常的树形列表。 指定搜索字段有 3 种方式：搜索名称，搜索 UUID，搜索路径。其中 UUID 和 路径 PATH 可从右击菜单最后一项中输出数据。 搜索框 是即时变动的； 在搜索结果中选中资源，清空搜索，视窗会重新定位到该资源，达到通过搜索来找到资源的目的；此外搜索结果中双击文件夹，可快速定位到树形中该文件夹。 折叠资源 头部菜单区 全部折叠或展开按钮 作用于全局； 树形节点的三角图标，可按 alt 键实现子资源全部展开或折叠 重命名资源 选中某个资源 快捷键 F2，快捷键 Enter，进入名称修改 快捷键 Esc 取消重命名 此外 ts 脚本资源的初始名称会处理为它的 className, 而 className 是不能重复的。 大图预览 此外可与 Assets Preview 面板配合， 点击一个文件夹，可按类型排列显示大图子资源，对于图片资源会较为直观。 "},"editor/inspector/":{"url":"editor/inspector/","title":"属性检查器","keywords":"","body":"属性检查器 属性检查器 是我们查看并编辑节点或资源属性的重要渠道。可编辑节点的位置，节点上的组件，图片，材质，模型等资源，面板功能细节多，较为复杂。 在 场景编辑器 ，层级管理器 选中节点，或者在 资源管理器 选中资源，就能在 属性检查器 中显示并开始编辑它的属性。 头部公共部分 左边的 两个箭头 是历史记录，点击可切换编辑项; 右边的 锁图标 可锁定面板，固定住编辑的对象，不让面板随新的选中项而变动。 编辑节点 节点与 层级管理器 中的树形结构里的节点对应，显示一样的名称。 1、左上角的复选框表示节点的激活状态，默认勾选，不勾选表示节点处于非激活状态，此时节点将会被暂停渲染，整个节点包括子节点在运行时就会被隐藏。 2、输入框里是节点的名称，名称可以为空。 3、接下来是节点的几个通用属性：位置 Position, 旋转 Rotation, 缩放 Scale, Layer。 4、右边的节点菜单，里面的菜单可执行复制，粘贴节点属性的值，也可以粘贴一个新组件。 5、添加组件 按钮，点击后会出现组件列表，包含系统提供的组件和自定义脚本组件。 添加组件的列表有一个搜索框，支持键盘上的上下箭头切换，以及 Enter 确定选中。 编辑节点的组件 面板能显示出节点组件及组件的属性。 和节点通用属性一样，每个组件都有一个可折叠或展开的头部。 当节点挂载多个组件的情况下，可以通过折叠不常修改的组件来减少滚动范围，提高编辑效率。 组件名称的右侧有帮助文档和组件菜单按钮。 帮助文档按钮可以跳转到该组件的 API 文档链接；组件菜单里可以操作：移除、上移、下移、复制、粘贴值，粘贴为新组件。 用户通过脚本创建的组件，编辑节点时，可直接拖入到 属性检查器 里生成一个组件。 脚本组件里的不同属性是用户自己在脚本代码里声明的，不同类型的属性编辑时编辑器会自动识别给与合适的 UI 组件。 我们将在 声明属性 一节中详细介绍属性的定义方法。 部分 UI 组件的使用方法 属性分为 值类型 和 引用类型 两大类。 值类型属性 值类型 包括数字、字符串、布尔、枚举等简单的占用很少内存的变量类型： 数值（Number）：可以直接使用键盘输入，也可以按输入框旁边的上下箭头逐步增减属性值。 向量（Vec2）：向量的控件是两个数值输入组合在一起，并且输入框上会以 x，y 标识每个数值对应的子属性名。 字符串（String）：直接在文本框里用键盘输入字符串，字符串输入控件分为单行和多行两种，多行文本框可以按回车换行。 布尔（Boolean）：以复选框的形式来编辑，选中状态表示属性值为 true，非选中状态表示 false。 枚举（Enum）：以下拉菜单的形式编辑，点击枚举菜单，然后从弹出的菜单列表里选择一项，即可完成枚举值的修改。 颜色（Color）：点击颜色属性预览框，会弹 颜色取色器 窗口，在这个窗口里可以用鼠标直接点选需要的颜色，或在下面的 RGBA 颜色输入框中直接输入指定的颜色。点击 颜色取色器 窗口以外的任何位置会关闭窗口并以最后选定的颜色作为属性值。 例如颜色取色器组件： 引用类型属性 引用类型 包括 object 对象，比如节点、组件或资源。可通过 拖动 或 弹出资源面板 的方式选择并赋值。 批量操作 1、可多选节点，不一致的属性将不可以修改，在 input 组件中以 - 表示不可修改。 2、批量赋值材质，图片，动画等资源，可多个拖动。 编辑 prefab 节点 prefab 节点的编辑，头部按钮有：取消关联，关联，定位资源，从资源还原，更新到资源 1.取消关联，是指把 prefab 节点与资源断开联系，变为普通节点，颜色不再是绿色。 2.关联，是指先选中一个 prefab 资源，再与当前 prefab 节点进行关联。 普通节点和 prefab 资源的全新关联，可在编辑器顶层菜单 编辑（Edit） 中找到操作指令： 3.定位资源，是指在 assets 面板上定位到 prefab 资源，并让其闪烁。 4.从资源还原，是指把一个已经编辑过的 prefab 节点，连同它的子节点，都回退到初始状态。 5.更新到资源，是指把已经编辑过的 prefab 节点数据更新到 prefab 资源。 编辑资源 编辑资源时请注意最后点击保存，如下图中的绿色打勾图标 即为保存按钮。 "},"editor/console/":{"url":"editor/console/","title":"控制台","keywords":"","body":"控制台 控制台 会显示报错、警告或其他编辑器和引擎生成的日志信息。不同重要级别的信息会以不同颜色显示。 关于日志 日志系统基于 js 的 console 模块。编辑器运行的时候，会捕获每一个进程里 console 打印出来的必要日志，并以颜色进行区分。 会被捕获的日志类型以及显示颜色： 日志（console.log）: 灰色文字，编辑器以及插件内开发者觉得有必要打印到控制台的内容。 警告（console.warn）: 黄色文字，程序运行遇到的不影响结果的异常情况。 错误（console.error）: 红色文字，运行中遇到的会影响结果的一场，必须解决的问题，或者是未被捕获的错误信息。 面板操作 控制台所有的功能都在顶部的一条工具栏上，从左到右的功能依次是： 清空当前控制台内的所有日志 打开日志记录文件 输入文本以过滤显示的日志 输入文本是否启用正则匹配 过滤显示的日志类型 其他设置 控制台的其他设置在偏好设置内，请参考 偏好设置 里的扩展设置。 "},"editor/animation/":{"url":"editor/animation/","title":"动画编辑器","keywords":"","body":"动画系统 本章将介绍 Cocos Creator 3D 的动画系统，除了标准的位移、旋转、缩放动画和序列帧动画以外，这套动画系统还支持任意组件属性和用户自定义属性的驱动，再加上可任意编辑的时间曲线和创新的移动轨迹编辑功能，能够让内容生产人员不写一行代码就制作出细腻的各种动态效果。 注意：Cocos Creator 3D 自带的动画编辑器适用于制作一些不太复杂的、需要与逻辑进行联动的动画，例如 UI 动画。 关于 Animation 熟悉动画编辑器 创建 Animation 组件和动画剪辑 编辑动画序列 制作帧动画 编辑动画曲线 动画事件 先从关于 Animation开始了解。 "},"editor/preferences/":{"url":"editor/preferences/","title":"偏好设置","keywords":"","body":"偏好设置 偏好设置 面板中提供了编辑器的个性化设置，要打开 偏好设置 面板，请从主菜单的 Cocos Creator 3D -> 偏好设置 菜单进入。 设置可以分成下列几部分： 通用设置 通用设置主要是针对编辑器相关的一些基础数据进行配置。 编辑器语言：可以选择中文或英文，修改语言设置后要重新启动 Cocos Creator 才能生效。 选择本机 IP 地址：用户可以在本机有多个 IP 地址的情况下，手动选择其中之一作为预览时的默认地址和二维码地址。这里会列出所有本机的 IP，编辑器默认自动挑选一个 IP。 数值调节钮步长：在属性检查器里，所有数值属性输入框的旁边都有一组上下箭头，可以用于步进输入的数值： 当鼠标悬浮在数值属性的名称附近时，光标会变成 这样的形状，然后左右拖动鼠标，也可以按照一定的步进幅度连续增加或减小数值。 以上两种修改数值的方式，默认的步长都是 0.1，而设置里 数值调节钮步长 这里设置的就是每次点击步进按钮或拖拽鼠标时数值变化的步长幅度。举例来说，如果您在脚本中使用的数字以整数为主，就可以把这个步长设置为 1，可以更方便的进行调节。 原生开发环境 这个分类用于设置构建发布到原生平台（iOS, Android, Mac, Windows）时，所需的开发环境路径。 使用内置 JavaScript 引擎：是否使用 Cocos Creator 3D 安装路径下自带的 engine 路径作为 JavaScript 引擎路径。这个引擎用于场景编辑器里场景的渲染，内置组件的声明和其他 Web 环境下的引擎模块。 自定义 JavaScript 引擎路径：除了使用自带的 engine，您也可以前往 engine 仓库 来克隆或 fork 一份引擎到本地的任意位置进行定制，然后取消勾选 使用内置 JavaScript 引擎，然后设置 JavaScript 引擎路径 到您定制好的引擎路径，就可以在编辑器中使用这份定制后的引擎了。 WeChatGame 程序路径：设置 WeChatGame 程序路径，详情见 发布到微信小游戏。 Android NDK 路径：设置 Android NDK 路径，详情见 安装配置原生开发环境。 Android SDK 路径：设置 Android SDK 路径，详情见 安装配置原生开发环境。 数据编辑 数据编辑内存放的是一些与资源编辑、数据修改相关的配置。 外部脚本编辑器：可以选用任意外部文本编辑工具的可执行文件，作为在资源管理器里双击脚本文件时的打开方式。 外部图片编辑器：和上面的选项类似，这里用来设置在资源管理器中双击图片文件时，默认打开图片用的应用程序路径。 扩展 插件内允许直接注入配置项目到偏好设置里。注册到偏好设置里的配置项就会显示在这里。具体需要参考各个插件的文档。 实验室 关于实验室： 实验室会不定期提供一些新的技术方案或实验性质的功能，你可以通过开关选项来开启或关闭相应的功能，大部分情况下我们会默认开启。 在未来的版本中，这些功能可能被合并，但也有可能出现破坏兼容性的修改，甚至可能会被取消。如果你想在开发环境中使用这些功能，请务必严格测试，并保持关注新版本的更新公告。 我们欢迎用户开启试用这些功能，并且在论坛提供宝贵的反馈意见，你可以让这些功能更适合自己的使用场景，给自己的项目更强大的助力。 使用弹窗方式添加组件 之前有很多用户反馈添加组件无法进行组件搜索，在遇到一些自定义脚本组件繁多的项目中，找到自己编写的脚本组件十分困难。 但是搜索相对于鼠标直接上移直接显示菜单而言会多一步操作，由于一些内部基础建设的关系，我们暂时无法提供鼠标直接上移并且可以搜索的功能。目前先提供使用搜索弹窗添加组件的功能，当然你可以关闭该选项回到最初的使用方式。 为了方便使用，我们还添加一些辅助设计： 打开弹窗时焦点将会在搜索框内，你可以直接搜索相关关键词而无需鼠标点击展开； 在搜索找到相关组件时，你可以直接使用 ↑↓快捷键来快速的切换组件选项，按下 enter 键即可添加该组件； 对于这个功能，如果你有更好的建议欢迎到论坛告诉我们。 开启地形功能 具体的使用文档可以参考 地形系统。 "},"editor/project/":{"url":"editor/project/","title":"项目设置","keywords":"","body":"项目设置 项目设置 面板通过主菜单的 项目 -> 项目设置 菜单打开，这里包括所有特定项目相关的设置,这些设置将会影响到整个游戏项目的预览、构建等。这些设置会保存在项目的 settings / packages 文件夹里。如果需要在不同开发者之间同步项目设置，请将 settings 目录加入到版本控制。 通用设置 默认 Canvas 设置 默认 Canvas 设置包括设计分辨率和适配屏幕宽度/高度，用于规定在新建场景或 Canvas 组件 时，Canvas 中默认的设计分辨率数值，以及 Fit Height、Fit Width 选项。 更多内容可以参考 多分辨率适配方案 项目预览 项目预览 分页提供的选项主要用于设置初始预览场景等等，但只对当前项目生效。 保存场景后自动刷新 勾选后，只要保存场景，就会刷新所有预览打开的页面； 初始化预览场景 指定按下 预览运行 按钮时，会打开项目中哪个场景。如果设置为 当前打开场景，就会运行当前正在编辑的场景，此外也可以设置成一个固定的场景（比如项目总是需要从登录场景开始游戏）。 自定义设备数据 用于添加在预览时的设备信息，添加的设备信息将会出现在预览页面的设备选项里。 模块设置 这里的设置是针对发布游戏时引擎中使用的模块进行裁剪，达到减小发布版引擎包体的效果。在列表中选中的模块在打包时将被引擎包括，未选中的模块会被裁剪掉。 在这里设置裁剪能够大幅度的减小引擎包体，建议打包后进行完整的测试，避免在场景和脚本中使用裁剪掉的模块。 引擎设置 这里的设置与偏好设置内的引擎设置类似，不同的是这些设置是存储在项目本地的，在仅针对某个项目使用自定义引擎时可以在这里设置。 其中 javascript 引擎设置的修改将会影响到针对启动编辑器、预览、构建时的游戏，所以这个配置修改后需要重启编辑才会生效。 Layers Layers 能让相机渲染部分场景，让灯光照亮部分场景。也可以在射线检测时通过 Layers 处理物体是否碰撞。 可自定义 0 到 19 个 Layers，当您把输入框清空时即删除原先的设置。 后 12 个 Layers 是引擎内置的，不可修改。 目前使用的位置有：编辑 node 节点时， inspector 面板上的 Layer 属性; 编辑 Camera 节点时的 Visibility 属性。 骨骼贴图布局设置 显式指定骨骼贴图布局，用于辅助蒙皮模型的 instancing，具体参考 这里。 "},"editor/engine-customization/engine-customization.html":{"url":"editor/engine-customization/engine-customization.html","title":"引擎定制工作流程","keywords":"","body":"引擎定制工作流程 Cocos Creator 3D 的引擎部分包括 JavaScript、Cocos2d-x-lite 和 adapter 三个部分(暂不支持Cocos2d-x-lite 和 adapter 引擎定制)。引擎在 github 上开源。地址在： JavaScript 引擎：https://github.com/cocos-creator/engine 建议你通过 GitHub 的 fork 工作流程来维护自己定制的代码，以便在将来引擎升级时，可以方便地将定制的部分更新上去，具体操作方式请阅读 Fork a repo。如果你愿意帮助 Cocos 越做越好，欢迎在 GitHub 提交你的修改，请参考 如何向 Cocos 提交代码。关于更多 GitHub 相关工作流程请参考 GitHub Help。 另外，根据不同的 Creator 3D 版本，还需要切换不同的引擎分支，例如： master/develop 分支：当前最新版本所用分支 vX.Y-release 分支：对应 X.Y 版本所用分支 vX.Y 分支：和 vX.Y-release 分支相同，主要用于范例工程 next 分支：大型重构所用分支 通常建议使用和所用 Creator 3D 相同版本的 vX.Y-release 分支，如果找不到的话，则使用 master 分支。 1 定制 JavaScript 引擎 如果您只需要定制 Web 版游戏的引擎功能，或只需要修改纯 JavaScript 层逻辑（如 UI 系统，动画系统），那么您只要按照下面的流程修改 JS 引擎就可以了。 1.1 获取 JS 引擎 如果您仅需基于当前的版本做一些调整，那么在 Cocos Creator 3D 内置的引擎基础上修改就可以了。点击 Creator 3D 编辑器右上方的 打开程序安装路径，然后将内置的 engine 目录拷贝到本地其他路径。 如果您想获得官方正在开发中的最新版本，首先您需要从 github 上 fork 或者克隆 JavaScript 引擎的原始版本（地址见上文）。JavaScript 引擎在使用前请根据 Creator 3D 版本切换相对应的分支。下载完成后存放到任意本地路径。 1.2 安装编译依赖 # 在命令行中进入引擎路径 cd /Users/yufang/engine # 安装 gulp 构建工具 npm install -g gulp # 安装依赖的模块 npm install 备注：生成debuginfos需要gulp构建工具。 1.3 进行修改然后编译 接下来您可以定制引擎修改了，修改之后请在命令行中继续执行： npm run build 也可以在 Cocos Creator 3D 中通过 开发者 -> 编译引擎 选项进行编译。 该命令会在引擎目录下生成一个 bin 文件夹，并将引擎源码编译到 bin 目录下。 1.4 在 Cocos Creator 3D 中使用定制版引擎 通过 项目 -> 项目设置 面板的 引擎设置 选项卡，设置本地定制后的 JavaScript 引擎路径。 "},"editor/preview/":{"url":"editor/preview/","title":"项目预览调试","keywords":"","body":"项目预览调试 在使用主要编辑器面板进行资源导入、场景搭建、组件配置、属性调整之后，我们可以通过预览来查看调试游戏在 Web 平台运行的实际效果。 注意：Cocos Creator 3D 目前仅支持 web 平台的预览模式，模拟器预览会在之后的版本迭代中接入。 浏览器预览 预览流程简介与常见错误处理 先从 浏览器预览 开始了解。 "},"editor/preview/browser.html":{"url":"editor/preview/browser.html","title":"浏览器预览","keywords":"","body":"浏览器预览 预览 在编辑器工具栏上选择 浏览器 后，点击旁边的按钮，会在用户的默认桌面浏览器中直接运行游戏的网页版本。推荐使用谷歌浏览器（Chrome）作为开发过程中预览调试用的浏览器，因为谷歌浏览器（Chrome）的开发者工具是最为全面强大的。 浏览器预览界面的最上边有一系列控制按钮可以对预览效果进行控制： 最左边选择预览窗口的比例大小，来模拟在不同移动设备上的显示效果 Rotate 按钮决定显示横屏还是竖屏 Debug Mode 里可以选择脚本中哪些级别的日志会输出到浏览器控制台中 Show FPS 按钮可以选择是否显示每秒帧数和 Drawcall 数量等调试信息 FPS 限制最高每秒帧数 Pause 暂停游戏 刷新预览 如果在编辑器内对场景做了修改，想要刷新预览效果，直接在浏览器里面刷新或者点击编辑器的刷新按钮即可。不同在于，编辑器的刷新按钮，将会刷新所有的预览页面。如果想要让预览页面自动刷新，保存场景即可。保存场景自动刷新的设置在 项目设置 -> 项目预览 里可以修改。 预览场景 预览场景默认是当前打开场景，如果需要调整可以在 项目设置 -> 项目预览 里修改预览的初始场景（详情请参考项目设置）。 手机端预览 调试手机端的预览效果有以下方式： 使用浏览器开发者工具的手机端预览模式 扫描预览二维码 将鼠标移动到编辑器工具栏左边的 ip 预览地址上，会显示一个预览的二维码，用手机扫描即可。 直接在手机浏览器里输入预览地址 注意：手机需要和电脑在同一网段。由于电脑的网络有可能有多个，如果编辑器预览 url 的 ip 地址选择不正确，可以在 偏好设置 -> 通用设置 -> 选择本机预览地址 里面修改，详情可以参考偏好设置的说明。 自定义预览设备数据 打开 项目 -> 项目设置 -> 项目设置预览 可以参考自定义设备菜单选项，在选项虚线区域设置好需要添加的设备信息，点击 Add 按钮即可添加。添加的设备信息将会出现在预览页面的设备选项里。 自定义预览模板 预览也支持自定义的模板方便用户自定义需要的预览效果，自定义的预览模板可以放置在项目目录下的 preview-template 文件夹内。编辑器内的预览也是使用模板来注入最新的项目数据，预览时将会查找该目录下的 index 文件，如果存在就是要该文件作为预览的模板。点击编辑器菜单的项目 -> 生成预览模板就可以获取最新的预览模板。 project-folder |--assets |--build |--preview-template |--index.ejs 注意：预览模板里存在一些预览菜单项以及预览调试工具等内容，所以在增删一些模板语法写的内容时要稍加注意，如果随意修改有可能会导致预览模板不可用，建议使用 ejs 注入的内容都保留去添加需要的内容即可。另外，假如 index.html 与 index.ejs 共存时，index.html 将会替代 index.ejs 成为预览的页面内容。 使用示例 以下示例可以在 test-case-3d 仓库内查看 点击菜单 项目 -> 生成预览模板 ，生成预览模板，console 面板内将会打印出预览模板生成的地址。 添加需要使用的脚本如 test.js，其中 中包含的是默认的启动游戏逻辑，添加的脚本可以根据需要在游戏逻辑启动前、后来决定放置的位置，下面示例中 test.js 在游戏启动后加载。 打开 index.ejs 修改如下： ... ... // 游戏启动处理逻辑 // 新增脚本 test.js 放置在页面内标识的相对路径（只能在 preview-template 文件夹内） |--preview-template |--index.ejs |--test.js 使用浏览器开发者工具进行调试 以谷歌浏览器为例，通过功能菜单的 开发者/开发者工具 可以打开开发者工具界面，如上图所示。在开发者工具中，我们可以查看运行日志、打断点进行调试、在调用堆栈中查看每一步各个变量的值、甚至进行资源加载和性能分析。 要学习使用开发者工具进行调试，请阅读 极客学院的 Chrome Dev Tools 使用指南，或其他浏览器的开发者工具帮助。 浏览器兼容性 Cocos Creator 3D 开发过程中测试的桌面浏览器包括： Chrome，Firefox（火狐）， 其他浏览器只要内核版本够高也可以正常使用，对部分浏览器来说请勿开启 IE6 兼容模式。 移动设备上测试的浏览器包括：Safari (iOS)，Chrome，QQ 浏览器，UC 浏览器，微信内置 Webview。 继续了解 预览流程简介与常见错误处理 "},"particle-system/editor/":{"url":"particle-system/editor/","title":"粒子编辑器","keywords":"","body":"粒子编辑器 粒子编辑器主要包括编辑粒子属性的界面介绍以及如何查看与编辑已选中粒子的状态，主要有以下几个部分组成： 曲线编辑器 渐变色编辑器 控制面板 "},"particle-system/editor/curve-editor.html":{"url":"particle-system/editor/curve-editor.html","title":"曲线编辑器","keywords":"","body":"曲线编辑器 曲线编辑器可以设置粒子中某个属性随时间变化的曲线，曲线编辑器的界面如下图 曲线编辑器可以进行如下操作： 横坐标表示粒子的单位化的生命周期，比如一个粒子的生命周期为5s，则0.5代表2.5s。纵坐标表示属性值，可通过上方编辑栏调整纵坐标区间，默认区间为[-1,1]。 右键单击曲线上一点可以添加一个关键帧。 拖动关键帧可以改变其坐标。 通过转动关键帧旁的线段可以改变该点的斜率。 编辑器下方有内置的曲线模板，单击某个模板可直接将其应用到当前曲线中。 "},"particle-system/editor/gradient-editor.html":{"url":"particle-system/editor/gradient-editor.html","title":"渐变色编辑器","keywords":"","body":"渐变色编辑器 渐变色编辑器可以设置粒子中某个属性随时间变化的颜色，渐变色编辑器的界面如下图 渐变色编辑器可以进行如下操作： Mode可以选择两种模式，Blend模式会按照当前时刻相邻的两个关键帧进行插值得到当前帧的颜色，Fixed模式会直接使用当前时刻的前一个关键帧颜色。 点击色带上方的空白处可以插入一个 alpha 关键帧，点击色带下方的空白处可以插入一个 rgb 关键帧。 拖动关键帧左右移动可以调节关键帧位置，拖动关键帧上下移动可以删除该关键帧。 在 Color/Alpha 编辑框内可以编辑对应的 rgb 或 alpha 值。 Location 可以编辑已选中的关键帧的位置。 "},"particle-system/editor/particle-effect-panel.html":{"url":"particle-system/editor/particle-effect-panel.html","title":"控制面板","keywords":"","body":"粒子控制面板 粒子控制面板可对在编辑器中选中的粒子进行一些操作，界面如下图： 可进行如下操作： ：播放/暂停粒子 ：重新播放粒子 ：停止播放粒子 Playback Speed：调整粒子播放速度Playback Time：显示粒子播放时长Particles：显示当前粒子数量 "},"editor/animation/animation.html":{"url":"editor/animation/animation.html","title":"关于 Animation","keywords":"","body":"关于Animation 在制作动画之前首先需要先为节点添加动画组件，并为组件挂载 clip 文件后才能编辑。在此之前，有必要先了解一下 clip 动画剪辑和 Animation 组件的相关概念。 Animation 组件 之前我们了解到 Cocos Creator 3D 是组件式的结构,那么 Animation 也不例外，它也是节点上的一个组件，只有为节点添加动画组件后，才能赋予节点参与到动画的的能力。因而点击相关节点后，如果节点没有动画组件，动画编辑器的界面上将会显示 添加 Animation 组件 按钮，点击即可添加。 Clip 动画剪辑 动画剪辑就是一份动画的声明数据，我们将它挂载到 Animation 组件上，就能够将这份动画数据应用到节点上，一个动画组件可以挂载多份动画剪辑。在没有 clip 的节点上是不能够编辑动画的，点击相关节点后，如果节点只有 Animation 组件却没有 clip 文件，动画编辑器将会显示 创建 clip 文件 按钮，点击即可创建并赋给组件。在动画编辑模式下亦可以通过动画编辑器左下角的 clip 选项来切换编辑不同的动画剪辑。 动画编辑模式 动画在普通模式下是不允许编辑的，只有在动画编辑模式下，才能够编辑动画文件。但是在动画编辑模式下，无法对节点进行 添加 / 删除 / 重命名 操作。 打开编辑模式： 选中一个包含 Animation 组件，并且包含有一个以上 clip 文件的节点，然后在动画编辑器左上角点击进入 动画编辑模式 的按钮。 Ctrl / Cmd + E 退出编辑模式： 点击动画编辑器上点击右上角的退出按钮，或者在场景编辑器左上角的关闭按钮 Ctrl / Cmd + E 更多细节参见 Animation 的系统设计以及 Animation 的脚本控制。 继续前往 熟悉编辑器 说明文档。 "},"editor/animation/animation-editor.html":{"url":"editor/animation/animation-editor.html","title":"熟悉动画编辑器","keywords":"","body":"熟悉动画编辑器 编辑器的主要面板介绍 动画编辑器一共可以划分为 6 个主要部分。 a. 工具栏 b. 时间轴与事件 c. 节点列表 d. 节点内关键帧预览 e. 属性列表 f. 属性轨道关键帧预览 a.工具栏 这里负责显示一些常用功能按钮 功能 图标 快捷键 备注 移动到第一帧 Ctrl / Cmd + Left - 移动到前一帧 Left - 播放/暂停 Ctrl / Cmd + P - 移动到下一帧 Right - 移动到最后一帧 Ctrl / Cmd + Right 移动到有效范围的最后一帧 停止动画 Ctrl / Cmd + S 点击停止当前动画，停止后将会移动到第一帧 添加事件关键帧 - 点击将会在当前时间控制线的位置添加事件关键帧 退出动画编辑模式 Ctrl + Q 点击退出动画编辑模式 切换时间轴显示刻度方式 - 默认是 00-00的方式，点击可以切换为 frame （以关键帧数）显示的方式。具体关于时间轴刻度可以参见 时间轴的刻度单位表示方式。 显示当前时间与跳转到对应时间 - 显示当前时间控制线的具体时间，也可以手动输入来使当前时间控制线调整到对应时间，支持直接输入 frame 或者是 00-00 的时间刻度。 调整默认关键帧间隔数 - 填入的关键帧间隔数将作为有多个关键帧同时生成时取做间隔数（例如：制作帧动画一次性拖入多张图片，此时添加的多个关键帧之间的间隔会取该值） 排列选中关键帧 - 选中的关键帧将以第一个帧为基准，以输入框内的数值作为间隔依次排列。 b.时间轴与事件 这里主要是显示时间轴，添加的自定义事件帧也会在这里显示。同时右键点击可以将事件控制先移动到对应位置，右键菜单可以进行 添加/移除、复制/粘贴 事件关键帧等，同时动画的有效长度也会有对应的显示效果。 时间轴的刻度表现方式 默认时间轴上刻度的表示法是 01-05。该数值由两部分组成，前面的数字表示当前秒数，后面的数字表示在当前这一秒里的第几帧。 01-05 表示该刻度在时间轴上位于从动画开始经过了 1 秒又 5 帧 的时间。 因为帧率（sample）可以随时调整，因此同一个刻度表示的时间点也会随着帧率变化而有所不同。 当帧率为 30 时，01-05 表示动画开始后 1 + 5/30 = 1.1667 秒。 当帧率为 10 时，01-05 表示动画开始后 1 + 5/10 = 1.5 秒。 虽然当前刻度表示的时间点会随着帧率变化，但一旦在一个位置添加了关键帧，该关键帧所在的总帧数是不会改变的， 假如我们在帧率 30 时向 01-05 刻度上添加了关键帧，该关键帧位于动画开始后总第 35 帧。之后把帧率修改为 10，该关键帧仍然处在动画开始后第 35 帧，而此时关键帧所在位置的刻度读数为 03-05。换算成时间以后正好是之前的 3 倍。 点击按钮 可以将刻度更改为 frame 的方式，并来回切换。 事件关键帧 在时间轴位置右键或者点击时间轴按钮可以添加事件关键帧，点击事件关键帧邮件菜单可以对齐进行移除、复制等操作，同时选中后也支持一系列的复制粘贴、删除快捷键。 c.节点列表 clip 动画数据中索引节点的方式是以挂载 Animation 组件的节点为根节点的相对路径， 因而在同个父节点下的同名节点，只能够产生一份动画数据，并且只能应用到第一个同名节点上。 这里的节点与层级管理器的节点是一一映射的，利用这个关系，当节点列表的节点数量过多难于查阅时，可以利用层级管理器的搜索功能来定位节点。在层级管理器点击节点，在动画编辑器内也会相应的跳转到对应节点位置来达到合理的显示效果。 选中节点图示 由于动画编辑器的节点列表融合了 clip 里面的数据后有可能会出现比原节点更多的节点信息，但这部分多余的节点就是丢失的节点，是无法编辑与使用的，界面上会显示为黄色同时关键帧轨道处也是置灰的状态。这时候可以将丢失的节点通过右键菜单的迁移数据来将数据转移到其他节点上。 具体的操作指南可以参见后续创建动画剪辑的章节。 d.节点内关键帧预览 这里主要是显示各个节点上的所有帧的预览。在此处关键帧位置右键菜单可以删除关键帧，亦可以移动关键帧的位置。同时单击此处不同节点的关键帧将会选中对应的节点，双击关键帧可以将时间控制线移动到该位置，在没有选中属性的情况下，Ctrl / Cmd + Shift + Left / Right 可以将时间控制线向上/下一个关键帧位置处移动。 e.属性列表 主要显示当前选中节点上参与动画的属性列表，每条属性显示项上有关键帧的 icon 图示，对应当前属性轨道对应当前时间控制线位置的关键帧状态，点击可以添加/移除对应关键帧。右键菜单可以移除当前轨道或清空数据等。在上方的加号按钮点击可以为当前选中节点添加属性轨道。 与节点一样的是，属性轨道也有存在丢失的可能，当前节点上不存在动画 clip 里记录的属性，该属性便是当前节点下丢失的属性。丢失的属性一样显示为黄色，这种情况下可以退出编辑模式后给对应节点添加相关属性或是直接移除该丢失的属性轨道。 f.属性轨道关键帧预览 主要显示各个属性轨道上具体的关键帧设置情况，也是关键帧编辑的主要区域。可以直接在轨道上右键来添加关键帧，亦可以拖动时间控制线到对应位置后按下 enter 键添加。同时在该区域也支持框选、点选关键帧来进行移动、复制、粘贴等操作。 基本操作指南 切换不同的动画剪辑进行编辑 点击动画编辑器左下角的 clip 选项，选择需要编辑的 clip 既可 更改关键帧显示区域 a. 更改时间轴缩放比例 在操作中如果觉得动画编辑器显示的范围太小，需要按比例缩小，让更多的关键帧显示到编辑器内怎么办？ 在图中b、d、f区域内滚动鼠标滚轮，可以放大，或者缩小时间轴的显示比例。 b. 移动显示区域 如果想看动画编辑器右侧超出编辑器被隐藏的关键帧或是左侧被隐藏的关键帧，这时候就需要移动显示区域： 在图中b、d、f区域内按下鼠标中键/右键拖拽。 c. 拖动更改动画编辑器布局 节点列表与时间之间的分界线，以及属性列表与时间轴之间的分界线都是可以用于拖拽更改布局的，通过拖拽可以自由的调整成适合编辑的布局效果。 ![](./animation-editor/layout.gif) 更改当前选中的时间 在时间轴（图 b 区域）区域内点击任意位置或者拖拽时间控制线，都可以更改当前的时间节点。 拖拽时间控制线 在工具栏点击控制时间控制线的按钮 双击关键帧，可以将当前时间跳转到对应位置 使用快捷键控制当前时间位置s 播放/暂停动画 在图 a 区域内点击播放按钮，按钮会自动变更为暂停，再次点击则是播放 播放状态下，保存场景等操作会终止播放 快捷键 Ctrl / Cmd + P 控制 更多关于关键帧的操作，请查看 编辑动画序列 章节 快捷键汇总 功能 快捷键 说明 进入 / 退出动画编辑器 Ctrl / Cmd + E - 保存动画数据 Ctrl / Cmd + S - 向前移动一帧 Left(←) 如果已经在第 0 帧，则忽略当前操作，未选中关键帧时移动的是小红线，选中节点后移动的是关键帧； 向后移动一帧 Right(→) 未选中关键帧时移动的是小红线，选中节点后移动的是关键帧； 移动到第一帧 Ctrl / Cmd + Left(←) - 移动到最后一帧 Ctrl / Cmd + Left(←) 当前 clip 内的有效帧数 删除当前选中关键帧 Delete / Cmd + Backspace - 播放/暂停动画 Alt + P - 停止动画 Alt + S 当前时间将变为 0 添加关键帧 I 选中属性轨道后，将会在在时间控制线位置添加关键帧，没有选中情况则忽略 跳到上一个关键帧 Ctrl / Cmd + Shift + Left(←) 移动到时间控制线左边最近的一个关键帧（选中属性轨道上或选中节点上） 跳到下一个关键帧 Ctrl / Cmd + Shift + Right(→) 移动到时间控制线右边最近的一个关键帧（选中属性轨道上或选中节点上） 多选关键帧 Ctrl 按住 Ctrl 点击关键帧可多选关键帧 全选轨道关键帧 Ctrl / Cmd + A 全选选中属性轨道的全部关键帧 复制生成关键帧 Alt 选中关键帧后，按下 Alt 不放 并拖动选中的关键帧可以复制对应的关键帧到新的移动位置 复制选中的关键帧 Ctrl / Cmd + C - 粘贴上一次复制的关键帧 Ctrl / Cmd + V - 取消选中的关键帧或事件帧 Esc - "},"editor/animation/animation-create.html":{"url":"editor/animation/animation-create.html","title":"创建 Animation 组件和动画剪辑","keywords":"","body":"创建Animation组件和动画剪辑 创建 Animation 组件 在每个节点上，我们都可以添加不同的组件。如果我们想在这个节点上创建动画，也必须为它新建一个 Animation 组件。 创建的方法有两种： 选中相应的节点，在属性检查器中点击下方的添加组件，在 Components 中选择 AnimationComponent。 打开动画编辑器，然后在层级管理器中选中需要添加动画的节点，在动画编辑器中点击添加 Animation 组件按钮。 具体 Animation 组件的参数使用可以参见Animation组件参考 创建与挂载动画剪辑 现在节点上已经有了 Animation 组件了，但是还没有相应的动画剪辑数据，动画剪辑也有两种创建方式： 在资源管理器中点击左上方的+，或者右键空白区域，选择 Animation Clip，这时候会在管理器中创建一个名为 'New AnimationClip' 的剪辑文件。 单单创建还是不够的，我们再次在层级管理器中点选刚刚的节点，在属性检查器中找到 Animation，这时候的 Clips 显示的是 0，我们将它改成 1。 然后将刚刚在资源管理器中创建的 'New AnimationClip' ，拖入刚刚出现的animation-clip 选择框内。 如果 Animation 组件中还没有添加动画剪辑文件，也可以在动画编辑器中直接点击 新建 AnimationClip 按钮，根据弹出的窗口创建一个新的动画剪辑文件，新建完的动画剪辑会自动附在动画组件上。 注意: 如果选择覆盖已有的剪辑文件，被覆盖的文件内容会被清空。 至此我们已经完成了动画制作之前的准备工作，下一步就是要 编辑动画序列 了。 "},"editor/animation/animation-clip.html":{"url":"editor/animation/animation-clip.html","title":"编辑动画序列","keywords":"","body":"编辑动画序列 在节点上挂载了动画剪辑后，点击进入动画编辑模式就可以进入动画编辑模式了，之后便可以在动画剪辑中创建一些动画帧数据。 首先需要了解一下动画属性，动画属性包括了节点自有的 position、rotation 等属性，也包含了组件 Component 中自定义的属性。 组件包含的属性前会加上组件的名字，比如 cc.SpriteComponent.spriteFrame。 属性轨道上对应的蓝色棱形就是关键帧。 Animation（动画） 组件可以以动画方式驱动所在节点和子节点上的节点和组件属性，包括用户自定义脚本中的属性。根据这个特性，可以灵活实现各种动画需求。具体的动画实现依不同的动画需求，步骤不同，案例可以参考官方的 example-3d 。这里主要介绍一些常见的编辑操作方法，便于快速的编辑实现效果 修改 clip 常见属性 sample： 定义当前动画数据每秒的帧率，默认为 60，这个参数会影响时间轴上每两个整数秒刻度之间的帧数量（也就是两秒之内有多少格）。 speed： 当前动画的播放速度，默认为 1。 duration： 当动画播放速度为 1 的时候，动画的持续时间。 real time： 动画从开始播放到结束，真正持续的时间，对应编辑器右下角括号内的数字。 wrap mode： 循环模式，具体配置效果请参见 循环模式 在编辑器面板上的对应控件修改对应属性后，焦点离开后即生效。 更多关于动画序列的设计部分以及脚本编写动画的内容，可以参见 动画剪辑 。 节点数据常见操作 动画剪辑通过节点的名字定义数据的位置，本身忽略了根节点，其余的子节点通过与根节点的相对路径索引找到对应的数据。 清空节点数据：在动画编辑器的节点项位置右键，选择 清空数据，在弹窗提示后选择 清除 即可 迁移节点数据：有时候我们会在制作完成动画后，将节点重命名，这样会造成动画数据所以出现问题，如下图： 这时候我们可以在丢失节点上右键点击 迁移数据，之后再去点击其他节点，将数据迁移上去。如果点击迁移数据后不想迁移了，直接在时间轴区域点击或者是在点击其他节点后的弹窗点击取消即可。 注意：节点数据迁移默认将会覆盖原节点上的数据 属性轨道数据常见操作 一个动画剪辑内可能包含了多个节点，每个节点上挂载多个动画属性，每个属性内的数据才是实际的关键帧，属性内的关键帧操作上面已经提到过了。这边主要介绍一些针对整个属性轨道的操作： 添加属性轨道：点击属性列表旁边的 + 小按钮，弹出可添加的属性菜单后，点击需要添加的属性即可 移除属性轨道：右键点击属性列表项，选择移除属性轨道 清空轨道数据：右键点击属性列表项，选择清空属性轨道 复制、粘贴轨道数据：右键点击属性列表项，选择复制轨道数据或者按下 Ctrl + C，之后点击与该复制轨道同类型的轨道，右键点击将会看到粘贴选项，点击或者按下 Ctrl + V 即可粘贴； 关键帧常见操作 在动画的制作过程中，经常会有一些对关键帧的操作处理，这里集合了动画编辑器的各种对关键帧处理的方法，了解这些方法技巧能更快编辑动画剪辑。 选中关键帧 点击我们创建的关键帧后，关键帧会呈现选中状态，此时关键帧由蓝变白，目前有以下方式可以选中： 右键点击关键帧即可选中，按下 Ctrl 再右击可多选 直接在关键帧区域拖动框选关键帧 在选中属性轨道后，按下 Ctrl / Cmd + A 可以全选轨道关键帧 添加关键帧 在对应的属性轨道位置上右键，选择 添加关键帧即可，右键菜单上同时也会出现当前添加关键帧帧数 选中对应节点和对应的属性，移动时间控制线到需要添加关键帧的位置，按下 I(inset) 键 移动时间控制线到需要添加关键帧的位置，在对应的属性列表项里，点击 即可 选中对应节点和对应属性轨道后，动画编辑器的中部将会出现对应属性的编辑器控件，修改即可打上关键帧 添加属性轨道后，直接在属性检查器的对应位置修改属性或者进行场景操作即可自动生成关键帧 移除关键帧 选中需要删除的关键帧，按下 delete / Cmd + backspace 键 在需要删除的关键帧位置右键点击，弹出菜单后，选中 移除关键帧 拖动时间控制线到需要移除关键帧的位置或者直接双击关键帧后，在对应的属性列表项里，点击 即可 修改关键帧数据 在时间轴上双击需要修改的关键帧，时间控制线将会移动到该位置或者直接拖动时间控制线到对应位置，直接在 属性检查器 内修改相对应的属性即可（确保动画编辑器处于编辑状态）。例如属性列表中有 position、x、y 三个属性轨道，选中关键帧之后，则可以修改 属性检查器 中的 position、x、y 属性。 在动画编辑模式下，将时间控制线移动到时间轴上没有关键帧的位置，然后在属性检查器中修改相对应的属性，也会自动插入一帧。 移动关键帧 选中关键帧后，在选中的关键帧上按住右键不放进行拖动，松开鼠标即移动完成。单选关键帧在移动过程中会在关键帧下方出现白色小方框，里面有移动距离和最终位置帧数的信息提示。多选关键帧则会在首尾的辅助线旁，分别有首尾关键帧的移动后的位置信息提示。 缩放关键帧 在选中多个关键帧后，会显示出左右两个控制辅助杆，拖动任意一个控制杆移动即可进行关键帧的整体缩放 间隔排列关键帧 选中多个关键帧后，调整好间隔关键帧数，按下间隔排列关键帧按钮后，选中的关键帧将会按照设置的间隔数依次排列好各个关键帧。 复制/粘贴关键帧 选中关键帧后，按照常规快捷键 C / V 即可进行复制粘贴，注意快捷键粘贴的位置将会以当前关键帧为起点 选中关键帧后，在选中的关键帧上右键，选择 复制关键帧 ，之后选择其他位置右键，选择 粘贴关键帧 即可 选中关键帧后，按下 Alt 键，在选中的关键帧上按住不放进行拖动，松开鼠标后关键帧将会复制到移动的对应位置 Tips: 短距离内的单个关键帧复制粘贴，推荐使用 alt + 鼠标拖动；长距离以及多个关键帧建议使用快捷键复制，鼠标右键粘贴的方式。 继续前往 制作帧动画 说明文档。 "},"editor/animation/sprite-animation.html":{"url":"editor/animation/sprite-animation.html","title":"编辑帧动画","keywords":"","body":"制作帧动画 我们刚刚了解了属性帧的操作，现在来看看具体怎么创建一个帧动画。 为节点新增 Sprite 组件 首先我们需要让节点能正常显示纹理，所以需要为节点增加Sprite组件。 选中节点后在属性检查器中通过 添加组件 按钮，选择 UI -> Render -> Sprite。 在属性列表中添加 cc.Sprite.spriteFrame 节点可以正常显示纹理后，还需要为纹理创建一个属性轨道。 在动画编辑器属性列表旁点击 +，然后选择 cc.SpriteComponent -> spriteFrame 添加帧 从资源管理器中，将纹理拖拽到属性帧区域，放在 cc.Sprite.spriteFrame 轨道上。 再将下一帧需要显示的纹理拖到指定位置，然后点击播放就可以预览刚刚创建的动画了。 如果同时拖拽多个纹理到属性轨道上，轨道上将按钮纹理选中的顺序，将其按照顺序，以工具栏上显示间隔数来排列生成关键帧。 排列修改关键帧间隔 帧动画的间隔帧数通常是固定的，有时添加了多个张纹理后，想要调整间隔数，就可以先在工具栏上方填写想要的间隔帧数，之后选中需要排列的关键帧，点击工具栏上的排列按钮或者在选中的关键帧上右击，选择 排列选中的关键帧 即可。 继续前往 编辑动画曲线 说明文档。 "},"editor/animation/animation-curve.html":{"url":"editor/animation/animation-curve.html","title":"编辑动画曲线","keywords":"","body":"编辑动画曲线 我们已经创建了基本的动画了。 但有时候我们会需要在两帧之间实现 EaseInOut 等缓动效果，那么在动画编辑器中怎么实现呢？ 我们首先需要在一条轨道上创建两个不相等的帧，比如在 position 上创建两帧，从 0,0 到 100,100。 这时候两帧之间会出现一根连接线（连接关键帧之间的蓝色线段），双击连接线，可以打开曲线编辑器。 曲线编辑器打开时，如果当前的动画曲线数据是预设里的，左边的预设对应项会有金黄色边框的选中效果。动画曲线的修改都是实时的，无需点击保存，修改完点击右上角的关闭按钮即可。 使用预设曲线 我们在曲线编辑器左侧可以选择预设的各种效果。比如说 Ease In 等，通过点击对应的曲线就可应用到当前的动画曲线上。 自定义曲线 有时候预设的曲线不能够满足动画需求时，我们也可以自己修改曲线。 在曲线编辑器的预览曲线图内，有两个灰色的控制点，拖拽控制点可以更改曲线的轨迹。 如果控制点需要拖出视野外，则可以使用鼠标滚轮缩放预览图。 修改过程中的曲线数据会实时的显示在曲线区域左上角的输入框内，同时该输入框还支持手动输入曲线数据来生成曲线，当然曲线数据的格式必须是四个数字用逗号隔开的格式，否则无法正常应用。 保存自定义曲线 有时项目需求的一些自定义曲线数据需要复用，就可以将其保存在 User 的预设库内。具体可以在编辑需要保存的曲线数据后，在左上方的预设菜单选择 User 选项再在左下方的输入框内输入希望保存的曲线数据名称，点击 add 即可添加。 注意：同名曲线会做覆盖处理，自定义曲线的保存是没有做撤销处理的，所以如果被覆盖了就需要重新添加的。 保存在预设里的自定义曲线，和其他库的预设曲线一样，点击即可应用。同时，鼠标移到曲线上方，会出现一个删除的图标，点击即可删除对应曲线数据。 更多关于动画曲线的设计以及脚本控制代码的部分可以参考 动画曲线 继续前往 添加动画事件 说明文档。 "},"editor/animation/animation-event.html":{"url":"editor/animation/animation-event.html","title":"动画事件","keywords":"","body":"动画事件 在游戏中，经常需要在动画结束或者某一帧的特定时刻，执行一些函数方法。这时候就可以通过添加动画事件来实现，在某个关键帧上添加事件函数后，动画系统将会在动画执行到该关键帧时，去匹配动画根节点身上的对应函数方法并执行它们。在脚本内添加帧事件的相关处理，以及更多内容请参考 帧事件。 添加事件帧 首先将时间控制线移动到需要添加事件的位置，然后点击工具栏区域的按钮，这时候在对应的时间轴上会出现一个一样的金色图标，这就是我们添加的事件。 删除事件帧 在添加的时间帧位置，右键点击，选择删除即可，在此处的删除将会删除该时间位置所有的时间帧函数。 添加事件帧函数 在事件函数编辑器的左上方点击 + 按钮，即可添加新的事件帧函数 删除时间帧函数 需要单独删除对应时间位置的某个帧函数，可以在事件函数编辑器中，点击函数名旁边的删除按钮。 编辑指定事件触发函数 双击刚添加的事件帧，可以打开事件编辑器，在编辑器内，我们可以手动输入需要触发的 function 名字，触发的时候会根据这个函数名，去动画根节点的各个组件内匹配相应的方法。 如果需要添加传入的参数，则在 Params 旁点击 + 或者 - ，目前只支持 Boolean、String、Number 三种类型的参数。 出现修改后，事件函数编辑器的标题旁会出现红色的星号，事件函数的修改是需要手动保存的，修改后点击上方的保存按钮即可保存。如果没有保存，在关闭事件编辑器也会有提示保存的弹框。 "},"editor/terrain/":{"url":"editor/terrain/","title":"地形系统","keywords":"","body":"地形系统 地形系统以一种高效的方式来展示大自然的山川地貌。开发者可以很方便的使用画刷来雕刻出盆地、山脉、峡谷、平原等地貌。 创建 创建需要两个步骤: 在 Hierarchy(层级管理器) 中点击鼠标右键，在弹出菜单中点击Create(创建)->Terrain(地形)来创建地形节点(地形节点可移动,但不支持旋转与缩放)。 在Assets中点击鼠标右键，在弹出菜单中点击Create(创建)->Terrain(地形)来创建地形资源。 使用 点击创建后的地形节点,此时在Inspector中存在地形组件,把已经创建好的地形资源赋予地形组件中的Asset中。 编辑 赋值完地形资源后可在Scene中弹出编辑面板,Cocos Creator 3D中的地形编辑主要包括三大功能：管理（Manage），雕刻（Sculpt），描绘（Paint）。可以通过点击三个Tab标签页来进行三个功能的切换。 除了编辑面板,也可以在toolbars上对各种不同模式进行切换。 管理（Manage） 用于调整地形的各种参数。Tile是地形的最小单位，Tile组成地形块（Block），目前一个Block由32x32个Tile组成，一个地形由至少1个Block组成。 参数 描述 TileSize 地形Tile的大小，目前一个地形块由32 x 32个Tile组成，所以一个地形块的边长是32 x TileSize。 BlockCount 地形块在两个维度上的数量(注意:该值调整过大会造成顶点数过多造成卡顿) WeightMapSize 权重图大小 LightMapSize 光照贴图大小 雕刻（Sculpt） 用于改变地形的形状。 画刷功能 隆起/凹下，鼠标左键/Shift+鼠标左键。 平滑,隆起凹下的操作往往会使地形看上去很尖锐,此时就可以使用平滑的功能。画刷类型 目前只支持圆形画刷 画刷参数设置 参数 描述 BrushSize 画刷的大小 BrushStrength 画刷的力度 描绘（Paint） 用于描绘地形的纹理 Layer编辑 点击+/-可以进行Layer的添加和删除(最多支持4层layer)。 选中某个Layer后可以编辑DetailMap和TileSize 参数| 描述 ---|--- DetailMap | 当前Layer的纹理 TileSize | 纹理的平铺大小，值越小会在同样大小的区域内进行更多次的平铺 画刷类型 目前只支持圆形画刷 画刷参数设置 参数 描述 BrushSize 画刷的大小 BrushStrength 画刷的力度 Brush Falloff 画刷衰减度，这个值决定了画刷边缘的锐利程度。0.0意味着画刷在整个范围内都有完全效果（全部被当前层纹理覆盖），具有尖锐的边缘，1.0意味着画刷仅在它中心具有完全效果，在到达边缘的过程中影响会衰减。 "},"editor/lightmap/":{"url":"editor/lightmap/","title":"烘焙系统","keywords":"","body":"烘焙系统 烘焙系统是通过计算引擎场景中所有光源对物体的影响最终生成光照贴图并在场景中应用的过程，该系统的目的是减少实时光源的运算，从而提高场景运行效率。 创建 开启烘焙系统需要三个步骤: 在顶部菜单栏 Project(项目) 中单击该菜单按钮，在弹出菜单栏中单击Lightmap(光照贴图)按钮，弹出lightmap面板。 在烘焙前需要在编辑器中设置光源组件的Bakeable属性为true(注意:目前只支持一个主方向光源)。 在弹出的lightmap面板中，设置好对应参数后可点击Lightmap Generate(生成光照贴图)按钮，选择对应存储文件夹即可生成光照贴图(注意:存储文件夹一定要在assets下才可生效)。 使用 生成烘焙贴图过程中会有生成的进度提示，生成后可在lightmap面板中的->Baked tab中查看。 其中Baked result(烘焙结果显示面板)显示了烘焙后的lightmap贴图, Lightmap clear(清空按钮)可以删除烘焙的生成结果，信息输出面板显示了每张烘焙图片的信息(文件名,大小等)。(注意: v1.1中只支持地形lightmap,在v1.1.1版本后也支持了模型的lightmap，但是模型在开启lightmap前，需要模型中包含两套uv，第二套uv用来access lightmap，同时材质也需要勾选 lightmap选项才能应用模型烘焙后的阴影信息。) 编辑 烘焙过程是根据面板设置的各个参数来计算生成的结果，如下图： 下表描述了各个参数的具体含义。 参数| 描述 ---|--- MSAA | 多重采样: 有以下值(1, 2, 4, 8) Resolution | 烘培贴图大小: 有以下值(128, 256, 512, 1024, 2048) Gamma | Gamma 矫正值 GIScale | 全局光照缩放系数 GISamples | 全局光照采样系数 AOLevel | AO级别 AOStrength | AO强度 AORadius | AO半径 AOColor | AO颜色 "},"editor/publish/":{"url":"editor/publish/","title":"构建发布","keywords":"","body":"发布工作流 在项目正常开发，预览效果达到要求的情况下，可以构建项目来进行更多的测试。 导读 熟悉构建发布面板 了解通用构建参数 发布到 web 平台 发布到原生平台 安装配置原生环境 原生平台 JavaScript 调试 发布到支付宝小游戏 发布到华为快游戏 发布到字节小游戏 发布到 Cocos Play 发布到微信小游戏 启用微信小游戏引擎插件 发布到 OPPO 小游戏 发布到 vivo 小游戏 发布到百度小游戏 发布到小米快游戏 命令行发布项目 定制项目的构建模版 构建流程简介与常见错误处理 先从 熟悉构建发布面板 开始了解。 "},"editor/publish/build-panel.html":{"url":"editor/publish/build-panel.html","title":"熟悉构建发布面板","keywords":"","body":"熟悉构建发布面板 构建发布面板使用简介 点击主菜单中的 项目 -> 构建发布 或者使用快捷键 Ctrl / Cmd + Shift + B 即可打开构建发布面板，构建发布是以构建任务的形式进行，如果同时添加了多个构建任务，编辑器将会按照任务添加的先后顺序，在该平台的构建任务完成后自动开始继续构建下一个任务。 平台插件相关选项 自 v1.0.3 起 ，所有的平台构建相关都内置为插件，这同时也是在为构建插件功能做内测，在将来稳定之后，我们将会开放给用户来方便对项目构建做一些定制化的插件。 也因此自 v1.0.3 起，构建界面的显示有所不同，平台相关的选项会单独的放在一个可折叠的 section 控件内（例如下图显示的微信平台选项），将来构建插件开放后，也允许用户插件用类似的方式注入界面选项，上面的名字便是插件名，在菜单里的 扩展-插件管理器 可以看到对应的平台插件。 新建构建任务 点击右上方的 新建构建任务 按钮，即可打开构建参数配置面板，在该区域内填写好相关的构建参数，点击构建即可。 在点击构建之前，请确保当前的场景数据没有未保存的内容。当前场景有内容尚未保存，点击构建后构建将会弹框提示，可以选择 保存、忽略 或者 取消构建。选择保存和忽略都会继续进行构建，而取消构建则会生成一条被取消的构建记录。 注：没有场景的项目构建是没有意义的，因而没有场景的项目是不允许添加构建任务的。 构建任务名 构建任务名，将会作为构建后生成的发布包文件夹名称，默认是无需修改的。同一个平台若执行多次构建，则会在原来的构建任务名后添加 -001、-002、-003...... 的后缀。如果想要覆盖旧有的发布包，将其手动改回原来的名称即可。 注意：Cocos Creator 是使用 发布平台 名称作为构建后生成的发布包文件夹名称，并且每次构建都会覆盖原有的发布包。而 Cocos Creator 3D 是使用 构建任务名 作为构建后生成的发布包文件夹名称，并且每次构建都会生成新的发布包，如果要覆盖原有的发布包，手动修改构建任务名与原有的发布包名称一致即可。 构建进度查看 点击构建后，可以在构建面板上看到当前的构建任务进行情况。如果构建成功，进度条会显示为绿色，并且会输出实际构建时间。第一次构建的时候，引擎编译会比较慢请耐心等待。如果构建失败，进度条则会显示为红色。 运行构建结果 目前大部分平台提供了在编辑器直接快速运行的方式，构建完成后，点击运行按钮即可预览构建后的项目效果，如果没有运行按钮则当前平台尚未支持在编辑器内直接运行，具体运行方式需要参考相关平台的文档。 注意：编辑器第一次运行微信项目时需要先配置微信开发者工具的路径并且做好一系列的登录配置工作才能正常唤起，具体可以参照编辑器控制台的提示处理。 构建 Log 信息查看 由于构建过程会产生非常多的 log 记录，默认情况下只有错误信息会打印到编辑器自带的控制台内。 如果需要查看到所有的日志信息有以下操作方式： 打开构建调试工具 通过点击菜单 开发者 -> 打开构建调试工具，即可查看在构建过程中打印出的全部 log 信息包括调用栈。 调整日志等级 点击菜单里的 Cocos Creator 3D -> 偏好设置 -> 插件 ，切换到 builder 来调整控制台打印相关信息的日志等级。 打开构建日志记录文件 自 v1.0.3 起，会记录每次构建过程中产生的报错信息，点击构建任务的按钮即可查看，在向 论坛 反馈构建相关问题时，可以直接贴上该 log 文件。 这里的 log 文件会存储在项目目录下的 temp/build-log 文件夹内。 构建参数查看 构建面板的构建任务下方有一个 按钮，点击即可查看或者调整之前的构建选项配置，调整完成后点击 重新构建 按钮，生成的发布包将会覆盖原来的。 在编辑器内构建过的构建任务信息，将会保存在项目目录下的 profiles/packages/build.json 文件中，只要没有在面板上删除对应构建任务或者删除对应的实体文件，就可以在重新打开编辑器后查看之前构建的参数配置、运行预览等操作。 注意：查看面板的修改操作是为了方便用户调整参数后重新构建，如果调整参数后没有点击 重新构建，则修改的内容不会被保存到当前构建任务中，只会作为下一次新建构建任务时的显示数据，查看的始终是上一次构建的配置参数而不是修改后的。这个按钮打开的面板虽然和新建类似但是意义不同，请不要混淆。 同时，点击构建构建后，编辑器也将打印出当前构建的参数内容，可以作为命令行构建的参数配置参考。 导出 / 导入构建选项配置 导出 构建面板右上方的导出选项可将当前构建选项的配置导出为 json 文件，主要是为了方便 命令行构建 以及同个项目内共享构建选项配置。导出的构建参数是按照平台区分的，对于使用命令行构建的开发者，可以直接将这份 json 配置文件作为命令行构建参数的 configPath 来使用。 导入 导入选项可读取 json 配置文件到构建面板，方便开发者共享构建配置信息。 重新编译 经常在打包后，会想要更改之前配置参数或者是之前的项目内 bug 修复后希望重新构建。而构建面板这边提供了两种重新编译的入口. 一种是直接在构建任务上，点击将会直接复用之前的构建配置参数进行重新构建。 另一种则是在点击 查看构建配置参数 后也会有 重新构建 的按钮出现。不同的是，后一种构建任务名与构建平台以外参数是不能修改的因为这会影响到实际的生成目录，并且直接修改重新构建面板的数据而没有重新构建，是不会保存到实际构建任务内的。 "},"editor/publish/build-options.html":{"url":"editor/publish/build-options.html","title":"通用构建参数介绍","keywords":"","body":"通用构建参数介绍 构建面板内的通用参数 发布路径 通过在 发布路径 的输入框中输入路径或者通过 ... 浏览按钮直接选择，我们可以为游戏指定一个发布路径，后续的多平台发布都会在这个发布路径中的子文件夹中创建资源或工程，发布后的文件夹名称会与构建任务对应名称（参见构建进度条项左上角）一致。 默认的发布路径在项目文件夹下的 build 文件夹中，如果您使用 git、svn 等版本控制系统，可以将 build 文件夹在版本控制中忽略。 替换插屏 自 v1.0.2 起，构建支持在微信等小游戏平台上替换插屏的功能，自 v1.0.3 起，所有平台都支持该功能。 鼠标上移到该选项后就会出现编辑的按钮图标，点击按钮后会打开插屏设置面板，项目在第一次使用该功能时会需要填写一份问卷，问卷里会有一些项目基础信息的调查，我们希望能更多收集到我们的游戏，接触到我们的 cp，未来也会有更多的扶持计划，希望开发者可以真实的填写。 替换插屏的编辑页面如下： 调试模式 在发布模式下，将会对资源的 uuid、构建出来的引擎脚本与项目脚本进行压缩和混淆，并且将对同类资源的 json 做分包处理，减少资源加载的次数。在需要对项目进行调试处理时，建议勾上此项方便定位问题。 参与构建场景 在构建过程中，除 resources 内的资源和脚本会全部打包出来外，其他资源都是根据参与构建的场景的使用情况来按需打包的。因而不勾选不需要发布的场景，可以减少构建后的包体体积。 初始场景 进入游戏后的第一个场景，可以直接在面板的 startScene 处选择，也可以在参与构建的场景列表处找到对应场景，在鼠标上移后点击出现的按钮即可。 Source Maps 构建默认会对引擎文件和项目脚本做压缩处理，如果需要生成 sourcemap 需要勾选此项。 压缩纹理 编辑器内可以对 spriteFrame 类型图片资源添加一些压缩选项，开启后构建时会根据这些压缩选项来生成对应的图像资源，如未勾选即便配置了压缩纹理也不会在构建时生效。具体配置选项可以参考 压缩纹理。 自动图集 自动图集是编辑器自带的合图功能，勾选后将会根据图集配置进行合图处理，如未勾选即便配置了合图配置也不会在构建时生效。具体配置选项可以参考 自动图集资源 合并初始场景依赖的所有 JSON 自动合并资源时，将初始场景依赖的所有 JSON 文件都合并到初始场景所在的包中。默认关闭，启用后不会增大总包体，但如果这些 JSON 也被其它场景公用，则后面再次加载它们时 CPU 开销可能会稍微增加。 MD5 Cache 给构建后的所有资源文件名将加上 MD5 信息，解决 CDN 资源缓存问题。 启用后，如果出现资源加载不了的情况，说明找不到重命名后的新文件。这通常是因为有些第三方资源没通过 cc.loader 加载引起的。这时可以在加载前先用以下方法转换 url ，转换后的路径就能正确加载。 url = cc.loader.md5Pipe.transformURL(url); 其他参与构建的参数配置 引擎模块设置 这部分设置可以在 项目设置-->模块设置 里更改，主要是用于剔除一些项目内不需要使用的引擎模块来减少打包后的包体，引擎模块有可能会跟随版本升级而发生变化，具体模块信息还需要以具体版本的编辑器为准，每次升级版本后还请重新确认一下模块信息后再进行构建发布。 Canvas 默认设置 这部分设置可以在 项目设置-->通用设置-->默认 Canvas 设置 里更改，主要用于设置多种分辨率的问题，如果项目内没有 Canvas 组件可以忽略该设置，详情请参见 多分辨率适配方案 "},"editor/publish/publish-web.html":{"url":"editor/publish/publish-web.html","title":"发布到 web 平台","keywords":"","body":"发布到 Web 平台 打开主菜单的 项目 -> 构建发布，打开构建发布面板。 Cocos Creator 3D 提供了两种 Web 平台的页面模板，可以通过 发布平台 的下拉菜单选择 Web Mobile 或 Web Desktop，他们的区别主要在于 Web Mobile 会默认将游戏视图撑满整个浏览器窗口，而 Web Desktop 允许在发布时指定一个游戏视图的分辨率，而且之后游戏视图也不会随着浏览器窗口大小变化而变化。 构建选项介绍 一些通用的构建通用参数介绍，请参考 通用构建参数介绍。 Web Desktop 参数名 可选 默认值 说明 polyfills 选填 { asyncFunctions: true } 自 v1.0.3 版本起，构建支持一些新特性的 polyfills，主要是在打包脚本时会做对应处理，开发者可以根据实际需求选择需要的 polyfills，这组选项暂时只有 异步函数，后续将会开放更多功能。 designWidth 必填 1280 游戏视图分辨率宽度 designHeight 必填 960 游戏视图分辨率高度 Web Mobile 参数名 可选 默认值 说明 polyfills 选填 { asyncFunctions: true } 自 v1.0.3 版本起，构建支持一些新特性的 polyfills，主要是在打包脚本时会做对应处理，开发者可以根据实际需求选择需要的 polyfills，这组选项暂时只有 异步函数，后续将会开放更多功能。 embedWebDebugger 选填 false 是否使用 vConsole，vConsole 类似 DevTools 的迷你版，用于辅助调试。 orientation 必填 'auto' 设备方向，可选值为 'auto'、'landscape'、'portrait'。 预览 URL 自 v1.0.3 版本起，构建支持同时预览多个 web 项目，因而构建的预览 URL 不再是统一的而是每个构建任务都会有一个单独的预览 URL 互不干扰。点击 URL 即可自动打开浏览器进行预览。具体的预览 URL 拼接规则为 ${偏好设置中的预览 IP 地址}:${编辑器预览端口号}/${构建平台}/${构建任务名}/index.html。 构建和预览 配置好构建参数后，点击 构建 按钮，开始 Web 平台版本构建。面板上会出现一个进度条，当进度条达到 100% 时，构建就完成了。 接下来可以点击 运行 按钮，在浏览器中打开构建后的游戏版本进行预览和调试。 上图所示就是 Web Mobile 平台的预览，可以看到游戏视图会占满整个窗口，而 Web Desktop 则不会撑满屏幕，如下图。 浏览器兼容性 Cocos Creator 3D 开发过程中测试的桌面浏览器包括： Chrome、Firefox（火狐）、Safari（Mac）、QQ 浏览器、360 浏览器。其他浏览器只要内核版本够高也可以正常使用，对部分浏览器来说请勿开启 IE6 兼容模式。 移动设备上测试的浏览器包括：Safari（iOS）、Chrome、QQ 浏览器、UC 浏览器和微信内置 WebView。 Retina 设置 可以在脚本中通过 view.enableRetina(true) 设置是否使用高分辨率，构建到 Web 平台时默认会开启 Retina 显示。 发布到 Web 服务器 要在互联网上发布或分享您的游戏，只要点击 发布路径 旁边的 打开 按钮，打开发布路径之后，按照当前构建任务名称，将构建出的对应文件夹里的内容整个复制到您的 Web 服务器上就可以通过相应的地址访问了。 关于 Web 服务器的架设，可以自行搜索 Apache、Nginx、IIS、Express 等相关解决方案。 "},"editor/publish/publish-native.html":{"url":"editor/publish/publish-native.html","title":"发布到原生平台","keywords":"","body":"发布到原生平台 Cocos Creator 3D 自 v1.0.3 起正式支持原生平台，点击菜单栏的 项目 -> 构建发布 选项，打开构建发布面板，参照文档配置完项目信息后即可打包。 支持的原生平台包括 Android、iOS、Mac、Windows 四个，其中 iOS、Mac 和 Windows 的选项只能在相应的操作系统中才会出现，目前原生平台是集合在一起打包的，可以在同一界面上配置各个原生平台的参数选项，打包一次即可生成所有原生平台的项目包。 环境配置 发布原生平台需要配置一些必要的环境，详情请参考 原生环境配置。 构建选项 一些通用构建参数的配置，请参照 通用构建参数介绍。 下面介绍一些平台特有以及通用选项内需要注意的点： MD5 Cache 作为通用选项，主要是给构建后的所有资源文件名将加上 MD5 信息，解决热更新时的 CDN 资源缓存问题。 启用后，如果出现资源加载不了的情况，说明找不到重命名后的新文件。这通常是因为有些 C++ 中用到的第三方资源没通过 cc.loader 加载引起的。这时可以在加载前先用以下方法转换 url ，转换后的路径就能正确加载，具体代码如下： auto cx = ScriptingCore::getInstance()->getGlobalContext(); JS::RootedValue returnParam(cx); ScriptingCore::getInstance()->evalString(\"cc.loader.md5Pipe.transformURL('url')\", &returnParam); string url; jsval_to_string(cx, returnParam, &url); Native 选项 由于目前构建机制上的调整，不同平台的处理均以插件的形式注入，在选择完原生平台后，将会看到除了原生具体平台的选项外还有 native 的选项，native 相关选项配置后将会影响到所有的原生平台。 选择源码模板（Template） 在 native 选项的 模板 (Template) 下拉菜单中有两种可用的引擎模板，我们可以从中选择一种： default，使用默认的 Cocos2d-x 源码版引擎构建项目 link，与 default 模板不同的是，link 模板不会拷贝 Cocos2d-x 源码到构建目录下，而是使用共享的 Cocos2d-x 源码。这样可以有效减少构建目录占用空间，以及对 Cocos2d-x 源码的修改可以得到共享。 关于源码引擎的概念，可以参照下文： Cocos2d-x 引擎中包括源码引擎。他们适用的范围是： 源码引擎初次构建和编译某个工程时需要很长的时间编译 C++ 代码，视电脑配置而定，这个时间可能在 5~20 分钟。对于同一个项目，已经编译过一次之后，下次再编译需要的时间会大大缩短。 源码引擎构建出的工程，使用原生开发环境编译和运行（如 Android Studio、Xcode 等 IDE），是可以进行调试和错误捕获的。 目前 Cocos Creator 3D 安装目录下已经包含了自带的 Cocos2d-x 源码引擎，在安装目录下的 resources/3d/cocos2d-x-lite 文件夹内可以查看到。 Polyfills 这里是脚本系统支持的一些新特性的 polyfills 选项，勾选后生成的项目会带上对应的 polyfills 也就是会增大包体，开发者可以根据实际需求选择需要的 polyfills, 这组选项暂时只有异步函数，后续将会开放更多功能。 Android 平台选项 设置包名（Package Name） （也称作 Package Name 或 Bundle Identifier），通常以产品网站 url 倒序排列，如 com.mycompany.myproduct。 注意：包名中只能包含数字、字母和下划线，此外包名最后一部分必须以字母开头，不能以下划线或数字开头。 Target API Level 设置编译 Android 平台所需的 Target API Level。点击旁边的 Set Android SDK 按钮即可快速跳转到配置页，具体配置请参考 原生环境配置。 APP ABI 设置 Android 需要支持的 CPU 类型，可以选择一个或多个选项，分别有 armeabi-v7a、arm64-v8a、x86 三种类型。 注意： 当你选择一个 ABI 构建完成之后，在不 Clean 的情况下，构建另外一个 ABI，此时两个 ABI 的 so 都会被打包到 apk 中，这个是 Android Studio 默认的行为。若用 Android Studio 导入工程，选择一个 ABI 构建完成之后，先执行一下 Build -> Clean Project 再构建另外一个 ABI，此时只有后面那个 ABI 会被打包到 apk 中。 项目工程用 Android Studio 导入后，是一个独立的存在，不依赖于构建面板。如果需要修改 ABI，直接修改 gradle.properties 中的 PROP_APP_ABI 属性即可。 密钥库 Android 要求所有 APK 必须先使用证书进行数字签署，然后才能安装。Cocos Creator 3D 提供了默认的密钥库，勾选 使用调试密钥库 就是使用默认密钥库，若用户需要自定义密钥库可去掉 使用调试密钥库 勾选。具体请参考 官方文档 Orientation 屏幕方向 portrait: 屏幕直立，home 键在下 landscapeLeft: 屏幕向左橫置，home 键在屏幕左侧的横屏 landscapeRight: 屏幕向右橫置，home 键在屏幕右侧的横屏 生成 App Bundle (Google Play) 勾选该项即可将游戏打包成 App Bundle 格式用于上传到 Google Play 商店。具体请参考 官方文档 。 Mac 平台选项 Bundle Identifier 包名 参见 Android Package Name 选项介绍。 iOS 平台选项 Bundle Identifier 包名 参见 Android Package Name 选项介绍。 Orientation 屏幕方向 参见 Android Orientation 选项介绍。 构建编译原生工程 选择发布平台，设置了初始场景以及对应平台配置项后，就可以开始构建了，点击右下角的 构建 按钮，开始构建流程。 构建结束后，我们得到的是一个标准的 Cocos2d-x 工程，和使用 Cocos Console 新建的工程有同样的结构。点击发布路径旁边的 打开 按钮，就会在操作系统的文件管理器中打开构建发布路径，例如 build/native，展开目录至下图所示，里面就包含了所有原生构建工程。目前编辑器尚未集成编译功能，需要手动在相应平台的 IDE （如 Xcode、Android Studio、Visual Studio）中打开构建好的原生工程，进行进一步的预览、调试和发布。 图中红框所示的就是不同原生平台的工程，下面简单介绍一下各个平台的手动编译方式： iOS 平台：使用 Xcode 打开构建目录下的 native\\frameworks\\runtime-src\\proj.ios_mac\\.xcodeproj 文件，在 Xcode 面板 General -> Signing 中设置签名，在 Xcode 左上方选择连接的设备后点击编译按钮进行编译运行。 Android 平台：使用 Android Studio 打开工程，如版本升级根据提示下载缺失的工具即可，再进行编译运行。 Mac 平台：使用 Xcode 打开构建目录下的 native\\frameworks\\runtime-src\\proj.ios_mac 文件夹后即可编译运行。 Windows 平台：使用 Visual Studio（推荐使用 Visual Studio 2017）打开构建目录下的 native\\frameworks\\runtime-src\\proj.win32\\.sln 文件或者直接双击该文件，即可编译运行。在安装 Visual Studio 时，请注意需要勾选安装 Windows 8.1 版本 SDK。 注意：在 MIUI 10 系统上运行 debug 模式构建的工程可能会弹出 “Detected problems with API compatibility” 的提示框，这是 MIUI 10 系统自身引入的问题，使用 release 模式构建即可。 要了解如何在原生平台上调试，请参考 原生平台 JavaScript 调试。 "},"editor/publish/setup-native-development.html":{"url":"editor/publish/setup-native-development.html","title":"安装配置原生环境","keywords":"","body":"安装配置原生开发环境 除了内置的 Web 版游戏发布功能外，Cocos Creator 3D 使用基于 cocos2d-x 引擎的 JSB 技术实现跨平台发布原生应用。在使用 Cocos Creator 3D 打包发布到原生平台之前，我们需要先配置好 cocos2d-x 相关的开发环境。 Android 平台相关依赖 要发布到 Android 平台，需要安装以下全部开发环境依赖。 如果您没有发布到 Android 平台的计划，或您的操作系统上已经有完整的 Android 开发环境，可以跳过这个部分。 下载 Java SDK（JDK） 编译 Android 工程需要本地电脑上有完整的 Java SDK 工具，请到以下地址下载： Java SE Development Kit 8 Downloads 下载时注意选择和本机匹配的操作系统和架构，下载完成后运行安装程序即可。 安装后请检查 JAVA 环境，在 Mac 终端或者 Windows 命令行工具中输入下面代码来查看： java -version 显示为 JAVA SE 则没有问题，如果系统中使用的是 JRE，则需要安装 JAVA SE 运行环境。 如果是 Windows 系统，请确认你的环境变量中包含 JAVA_HOME。可以通过右键点击我的电脑，选择属性，打开高级选项卡中来查看和修改环境变量。修改完成后 Windows 平台可能需要重启电脑才会生效。参考 如何设置或更改 JAVA 系统环境变量 下载安装 Android Studio Cocos Creator 3D 不支持 Eclipse 的 ANT 构建，需要使用 Android Studio 作为安卓平台的构建工具，并在 Android Studio 里下载所需的 SDK 和 NDK 包。首先请 安装 Android Studio。 下载发布 Android 平台所需的 SDK 和 NDK 安装 Android Studio 完成后，参考官方文档，打开 SDK Manager：SDK Manager 使用说明。 在 SDK Platforms 分页栏，勾选你希望安装的 API Level，也就是支持安卓系统的版本，推荐选择主流 API Level 23（6.0）、API Level 26（8.0）和 API Level 28（9.0）等。 在 SDK Tools 分页栏，首先勾选右下角的 Show Package Details，显示分版本的工具选择。 在 Android SDK Build-Tools 里，选择最新的 build tools 版本。 勾选 Android SDK Platform-Tools, Android SDK Tools 和 Android Support Library 勾选 NDK，建议使用的版本为 r17 - r19。 记住窗口上方所示的 Android SDK Location 指示的目录，稍后我们需要在 Cocos Creator 3D 里填写这个 SDK 所在位置。 点击 OK，根据提示完成安装。 安装 C++ 编译环境 Cocos2d-x 自带的编译工具 Cocos Console 需要以下运行环境： Python 2.7.5+，下载页，注意不要下载 Python 3.x 版本。 Windows 下需要安装 Visual Studio 2017 社区版。在安装 Visual Studio 时，请勾选 使用 C++ 的桌面开发 和 使用 C++ 的游戏开发 两个模块。 注意：在 使用 C++ 的游戏开发 模块中有一个 Cocos 选项，请勿勾选。 Mac 下需要安装 Xcode 和命令行工具，下载页 配置原生发布环境路径 下载安装好开发环境依赖后，让我们回到 Cocos Creator 3D 中配置构建发布原生平台的环境路径。在主菜单中选择 Cocos Creator 3D -> 偏好设置，打开偏好设置窗口： 我们在这里需要配置以下两个路径： NDK 路径，选择 Android SDK Location 路径下的 ndk-bundle 文件夹（NDK 是其根目录），不需要编译 Android 平台的话这里可以跳过。 Android SDK 路径，选择刚才在 SDK Manager 中记下的 Android SDK Location 路径（Android SDK 的目录下应该包含 build-tools、platforms 等文件夹），不需要编译 Android 平台的话这里可以跳过。 配置完成后点击 保存 按钮，保存并关闭窗口。 注意：这里的配置会在编译 原生工程 的时候生效。如果没有生效（一些 Mac 机器有可能出现这个情况），可能需要您尝试到 系统环境变量 设置这些值：COCOS_CONSOLE_ROOT, NDK_ROOT, ANDROID_SDK_ROOT。 注意事项 在之前的版本中收到了很多原生打包的问题反馈，这里补充一些可能的问题原因。 包名问题 检查构建发布面板中的包名，包名中只能包含数字、字母和下划线，此外包名最后一部分必须以字母开头，不能以下划线或数字开头。 Android 编译成功，但运行时提示 dlopen failed: cannot locate symbol \"xxxx\" referenced by \"libcocos2djs.so\"... 请检查 NDK 和 Android SDK 的架构和版本是否和测试用的 Android 系统相对应，另外可以尝试使用本文所用的 NDK 和 Android SDK 版本来测试。 最后，如果依然打包失败，可以尝试创建一个标准的 Cocos2d-x 工程，并尝试编译，如果 Cocos2d-x 工程可以编译，而 Cocos Creator 3D 无法打包，请将 bug 通过 论坛 反馈给我们。 现在您已经完成了全部原生开发环境的配置，接下来请继续前往 打包发布原生平台 说明文档。 "},"editor/publish/debug-jsb.html":{"url":"editor/publish/debug-jsb.html","title":"原生平台 JavaScript 调试","keywords":"","body":"原生平台 JavaScript 调试 游戏发布到原生平台后，由于运行环境不同，可能会出现在浏览器预览时无法重现的 Bug，这时我们就必须直接在原生平台下进行调试。Cocos Creator 3D 可以很方便地对原生平台中的 JavaScript 进行远程调试。 iOS 和 Android 真机调试 如果游戏只有在真机上才能运行，那就必须用真机对打包后的游戏进行调试。调试步骤如下： 确保 Android/iOS 设备与 Windows 或者 Mac 在同一个局域网中。注意在调试过程中请勿开启代理，否则可能导致无法正常调试。 在 Creator 3D 的 构建发布 面板选择 Android/iOS 平台、Debug 模式，构建编译运行工程（iOS 平台建议通过 Xcode 连接真机进行编译运行）。 用 Chrome 浏览器打开地址：devtools://devtools/bundled/js_app.html?v8only=true&ws={IP}:6086/00010002-0003-4004-8005-000600070008 即可进行调试。其中 {IP} 为 Android/iOS 设备的本地 IP。 Windows 平台及 Mac 平台调试 在 Windows 平台及 Mac 平台下调试游戏，步骤与真机调试类似，将工程用 IDE 编译运行之后，此时便可进行调试。步骤如下： 用 IDE 将打包好的工程编译并运行（Windows 平台请使用 Visual Studio， Mac 平台请使用 Xcode） 在游戏运行时打开 Chrome 浏览器，输入地址：devtools://devtools/bundled/js_app.html?v8only=true&ws=127.0.0.1:6086/00010002-0003-4004-8005-000600070008 即可进行调试。 使用 lldb 查看当前的 JS 调用栈 通过在 C++ 中断点我们能很便捷地看到 C++ 的调用栈, 但并不能同时看到 JS 的调用栈. 这个割裂的过程会常常打断调试的体验. 我们可以使用 lldb 提供的功能, 在调试过程中进行很多的操作, 包括查看调用栈. Xcode 和 Android Studio 都默认使用 lldb 作为调试器. 详细的 lldb 文档可以查看 https://lldb.llvm.org/use/tutorial.html lldb 的全局配置 lldb 在启动的时候 会加载 ~/.lldbinit 例如下面的配置: ~ % cat ~/.lldbinit target stop-hook add expr -- cocos2d::log(\".lldbinit ---- \\n%s\\n\", se::ScriptEngine::getInstance()->getCurrentStackTrace().c_str()) DONE 设置了每次断点后的行为, 执行代码 cocos2d::log(\".lldbinit ---- \\n%s\\n\", se::ScriptEngine::getInstance()->getCurrentStackTrace().c_str()) 输出 JS 调用栈的信息. 查看 target stop-hook 的用法 这种方法也有明显的缺陷 会对 所有项目 生效, 其他项目不存在相应符号, 导致报错. Xcode 在断点中编辑 action (只对具体的断点触发) 可以在 Debugger Command 中输入命令 expr -- cocos2d::log(\".lldbinit ---- \\n%s\\n\", se::ScriptEngine::getInstance()->getCurrentStackTrace().c_str()) 查看 expr 的用法 在断点触发后, 在 lldb console 中增加 回调 可以针对具体的断点, 进行更多的调用 同上, 也可以输入 expr -- cocos2d::log(\".lldbinit ---- \\n%s\\n\", se::ScriptEngine::getInstance()->getCurrentStackTrace().c_str()) 查看调用栈. 在 Android Studio 配置 lldb 在 Run/Debug Configuration/ Debugger 界面进行类似的配置 Android Studio 也提供了和 Xcode 类似的 lldb console. 进阶调试指南 如果需要在 Release 模式下调试，或者需要调试定制后的原生引擎，可参考更详细的 JSB 2.0 使用指南：远程调试与 Profile。 "},"editor/publish/publish-in-command-line.html":{"url":"editor/publish/publish-in-command-line.html","title":"命令行发布项目","keywords":"","body":"命令行发布项目 通过命令行发布项目可以帮助大家构建自己的自动化构建流程，大家可以修改命令行的参数来达到不同的构建需求。 命令行发布参考 例如：构建 web-desktop 平台、Debug 模式 Mac /Applications/CocosCreator3D.app/Contents/MacOS/CocosCreator3D --project projectPath --build \"platform=web-desktop;debug=true\" Windows CocosCreator3D/CocosCreator3D.exe --project projectPath --build \"platform=web-desktop;debug=true\" 目前命令行构建除了必填项外，如果不传递一律使用默认值来构建，具体参数默认值请参考下方描述以及平台的参数介绍。 进程退出码 332 构建失败 —— 构建参数不合法 334 构建失败 —— 构建过程出错失败，详情请参考构建日志 336 构建成功 构建参数 --project：必填，指定项目路径 --build：指定构建项目使用的参数 在 --build 后如果没有指定参数，则会使用 Cocos Creator 3D 中构建面板当前的平台、模板等设置来作为默认参数。如果指定了其他参数设置，则会使用指定的参数来覆盖默认参数。可选择的参数有： configPath - 参数文件路径。如果定义了这个字段，那么构建时将会按照 json 文件格式来加载这个数据，并作为构建参数。这个参数可以自己修改也可以直接从构建面板导出。 includedModules - 定制引擎的打包模块，有需要打包部分模块而不是全部模块的，可以传递此参数。具体模块可以从 这里 查找到，注意传递的是模块 entry 字段组成的数组。 taskName - 构建任务名，构建后生成的发布包文件夹名称。 name - 游戏名称 platform - 必填，构建的平台 buildPath - 构建的工作区，默认为 build 目录下 startScene - 主场景的 uuid 值（参与构建的场景将使用上一次的编辑器中的构建设置），未指定时将使用参与构建场景的第一个 scenes - 参与构建的场景信息，未指定时默认为全部场景 debug - 是否为 debug 模式，默认关闭 mergeStartScene - 是否合并初始场景依赖的所有 JSON，默认关闭 packAutoAtlas - 是否开启自动图集，默认关闭 compressTexture - 是否开启压缩纹理，默认关闭 replaceSplashScreen - 是否替换插屏，默认关闭 md5Cache - 是否开启 md5 缓存，默认关闭 自 v1.0.3 起，各个平台的构建会作为独立的插件嵌入到构建发布面板中，因而构建各个平台的构建参数位置也不同，各个平台的参数将会放置在 packages.平台名称.key 内，例如：为 wechatgame 指定构建参数，配置大体如下： { taskName: 'wechatgame', packages: { wechatgame: { appid: '*****', } } } 之后在构建插件支持对外开放，其他插件的配置参数也会通过同样的方式嵌入到构建面板中。具体各个平台的参数字段还请参照各个平台各自的文档，最好是通过构建面板的 导出 功能来获取配置参数，更加方便快捷。目前依旧兼容旧版本的参数来构建，但是将会在之后移除该兼容处理，请尽快升级配置参数。 在 Jenkins 上部署 Cocos Creator 3D 命令行运行的时候也是需要 GUI 环境的。如果你的 Jenkins 无法使用 Cocos Creator 3D 命令行运行，一个解决办法是：确保 Jenkins 运行在 agent 模式下，这样才能访问到 WindowServer。详见：https://stackoverflow.com/questions/13966595/build-unity-project-with-jenkins-failed 如果你的 Jenkins 在 Windows 下无法编译，请在 Windows 的 控制面板 -> 管理工具 -> 服务 中为 Jenkins 的服务指定一个本地用户，然后重启电脑就可以了。不必单独设置一个 master-slave 模式。 "},"editor/publish/custom-project-build-template.html":{"url":"editor/publish/custom-project-build-template.html","title":"定制项目的构建模版","keywords":"","body":"定制项目构建流程 自定义发布模版 Cocos Creator 3D 支持对每个项目分别定制发布模板，只需要在项目路径下添加一个 build-templates 目录，里面按照平台路径划分子目录，然后里面的所有文件在构建结束后都会自动按照对应的目录结构复制到构建出的工程里。目前除了原生平台外，其他所有平台都支持该功能，具体的平台名称可以参照下面的表格。 结构类似： project-folder |--assets |--build |--build-templates |--web-mobile |--index.html 这样如果当前构建的平台是 web-mobile 的话，那么 build-templates/web-mobile/index.html 就会在构建后被拷贝到对应构建任务文件夹下。 除此之外，还有另外两种构建模板的支持 1. ejs 类型 由于构建出来包的内容是不能保证每个版本完全一样，按照之前的使用方式，每次编辑器内部的构建模板有更新，开发者也需要更新项目内的构建模板。因而现在加入新的模板使用方式。可以点击菜单里的 项目 -> 创建构建模板 选择对应平台后将会生成对应平台支持的模板文件。例如： project-folder |--assets |--build |--build-templates |--web-mobile |--index.ejs 构建会对这些模板做参数注入，构建经常改动的东西都会放在该模板引用的子模板内，使用时只需要修改添加需要的内容即可，这样项目内的构建模板可以不用频繁更新。 需要 注意 的是，拷贝用户模板是发生在渲染对应支持模板之后的，也就是假如该目录下同时存在 index.ejs 与 index.html, 最终打包出来的是 index.html 文件而不是 index.ejs 渲染出来的文件。 2. json 类型的融合处理 许多小游戏平台都会有类似 game.json 之类的配置文件，当这些 json 文件在构建模板的对应目录下时，构建不会直接拷贝覆盖，而是会对其做数据融合，具体的规则就是在原本构建出来的对应 json 文件盖上构建模板内的 json 文件数据内容。 自定义构建模板平台支持表 具体各个小游戏平台有做对应数据融合的 json 文件列表如下: 平台 平台实际名称 自定义构建模板 微信小游戏 wechatgame game.ejs, game.json, project.config.json Web Mobile web-mobile index.ejs Web 桌面端 web-desktop index.ejs 小米快游戏 xiaomi-quick-game manifest.json Cocos Play cocos-play game.config.json 百度小游戏 baidu-mini-game game.json, project.swan.json OPPO 小游戏 oppo-mini-game manifest.json vivo 小游戏 vivo-mini-game project.config.json 华为快游戏 huawei-mini-game X（暂不支持） 支付宝小游戏 alipay-mini-game game.json 原生平台 native X（暂不推荐使用） 自定义构建插件 构建插件我们目前还在内测阶段，接口尚未稳定，暂时不对外开放。 "},"editor/publish/build-guide.html":{"url":"editor/publish/build-guide.html","title":"构建流程简介与常见错误处理","keywords":"","body":"构建流程简介与常见问题指南 构建基础结构介绍 构建主要有两个大流程，一个是 通用构建处理，一个是 平台适配处理。各个平台的适配处理逻辑将会以构建插件的形式注入到编辑器构建内，每个平台的适配构建都是相互隔离的。平台各自的一些构建参数在构建面板也会以比较特殊的方式显示在界面上，这一点将来构建插件开放，开发者一样可以去动态注入一些构建参数 UI 在界面上方便使用。 通用构建处理流程简介 Cocos Creator 3D 的通用构建流程，主要有以下部分内容： 构建参数初始化 构建数据整理 资源构建写入文件系统 整理 settings 数据 settings uuid 压缩与文件写入 构建参数初始化 这个步骤主要是将传递给构建的初始 options 初始化为构建内部的 options，做一些参数的格式转换以及构建资源数据库的资源数据初始化，加载最新的资源信息并分类。 构建数据整理 编辑器会先汇总 当前参与构建的场景以及所有在 resources 目录下的资源，每个资源的打包都会经过引擎的反序列化，查找出依赖资源再递归进行资源的打包。在反序列化之前会先配置整个项目的脚本环境，也就是加载所有的非插件项目脚本。因为脚本的加载正确与否会直接影响到反序列化的进行，因而如果脚本编写的不合法加载失败会直接导致构建失败。如果在反序列化过程中发现有依赖的资源丢失会发出警告，但会继续进行构建。这里的警告并不意味着问题不需要解决，如果资源丢失不解决，是难于保证构建后的内容不出问题的。 这一步骤也会找出根据构建内部划分的资源类型，比如场景、脚本、图片压缩任务、json 分组信息等进行整理，这一步骤将会剔除没有使用到的资源信息。需要注意的是，这个步骤之前会去加载所有的用户脚本， 资源构建写入文件系统 根据前两个步骤（参数初始化以及构建数据整理）的结果，将使用到的资源生成到文件系统内，打包之后，所有的序列化文件都会放置在构建后目录的 res/import 目录下，所有的资源的源文件将会放置在 res/raw-assets 目录下。具体可以分为以下几个步骤： 脚本构建：编辑器内对脚本的构建分为 插件脚本 和 非插件脚本 两类。 插件脚本会直接把源文件按照原来的目录结构拷到构建后文件夹的 src 目录下，所以插件脚本是不支持任何需要编译的脚本形式的比如 ts 或者是使用 es6 写法的 js。插件脚本的资源信息则会写进 settings 里的 jsList 数组内。 非插件脚本将会全部打包成 project.js（调试模式下是 project.dev.js），放在对应的 src 目录下。勾选 sourceMap 选项将会生成对应的 map 文件，根据 debug 选项来确定脚本是否压缩。 自动图集处理：查询项目内部的自动图集资源信息，根据自动图集资源的配置将图集下的 SpriteFrame 小图打包成大图、生成序列化文件等等。这一步骤会修改 json 分组信息、asset 资源分组信息以及添加纹理压缩任务。如果构建选项没有勾选自动图集，不进行任何处理。 纹理压缩：根据整理好的图片压缩任务，进行图片资源的压缩处理并写入到构建文件夹内，如果构建选项没有勾选纹理压缩，不进行任何处理。 引擎构建：根据项目设置内的引擎模块设置剔除没有使用到的引擎模块，打包为 cocos3d.js，生成到 src 文件夹下。勾选 sourceMap 选项将会生成对应的 map 文件，根据 debug 选项来确定脚本是否压缩。 引擎打包的主要步骤是： 获取项目设置里的引擎模块信息； 检查缓存中的引擎版本与当前需要编译的引擎是否一致，内容一致直接拷贝不编译； 如需编译，根据引擎接口，执行打包引擎的任务，之后拷贝编译后的 js 文件，并保存引擎的修改时间； 编译引擎时，可以查看 输出的 log 信息： 关于引擎文件的复用规则，这里有必要阐述下： 打包好的引擎文件将会放置在引擎目录的 bin/.cache/.editor-cache 文件夹下, 按照会影响引擎编译的参数生成的 hash 值存放，其中 .watch-file.json 是引擎各个文件的修改时间。 engine-folder |--bin |--.cache |--.editor-cache |-- 1dc4a547f9...63a43bb8965.watch-files.json |-- 1dc4a547f9...63a43bb8965 |-- 1dc4a547f9...63a43bb8965.map ... 只要任何相关的引擎构建参数发生更改，就会重新编译引擎，具体影响构建引擎缓存使用的有： debug: 是否打开调试模式 includeModules: 引擎模块设置 sourceMaps：是否开启 sourceMap platform：构建平台 引擎修改时间 json 构建：序列化 json 根据 json 分组进行合并写入文件系统(res/import 文件夹内)，如果是 release 模式还会对序列化 json 内的 uuid 进行压缩处理。 普通资源拷贝：一些原始资源（rawAssets）直接从 library 拷贝到构建后的 res/raw-assets 文件夹内。 md5 处理：将 res 文件夹内的资源全部加上 md5 后缀，并整理数据准备记录在 settings 内。 main.js 模板文件生成：根据用户选项注入一些项目设置到 main.js 文件夹内并生成到构建输出目录下。 整理 settings 数据 主要是根据之前资源整理的数据，准备游戏启动必要的配置信息。 关于 settings 结构的通用解析： { debug: boolean; // 是否为调试模式，取自构建配置面板 designResolution: { // canvas 分辨率设置，取自项目设置内数据 width: number; // canvas 分辨率宽度 height: number; // canvas 分辨率高度 policy: number; // 满屏的宽高适配模式 }; launchScene: string; // 初始场景的 url platform: string; // 平台 rawAssets: { [index: string]: { [uuid: string]: string[] } }; // 存储 resources 下加载的资源 url 与类型 // 示例: \"bba00d3a-2f17-4511-b47c-0d584b21b763@6c48a\": [\"test/right/texture\", \"cc.Texture2D\", \"bba0...@6c48a\"] // \"bba0...@6c48a\": [\"test/right/texture\", 1, 1] scenes: Array; // 参与运行的场景信息数组 scriptPackages: Array; // 脚本信息数组 jsList: string[]; // 脚本插件数组 moduleIds: string[]; // 所有用户脚本组件的信息 packedAssets: Record; // json 分组信息 md5AssetsMap: { [index: string]: Array }; // 勾选 md5Cache 后才有,数组部分以 [uuid_1, md5_1, uuid_2, md5_2, ...] 的格式存储的，其中 uuid_1 如果是个简单数字说明存储的是 uuids 数组内的 uuid 索引。 uuids: string[]; // uuid 数组，仅 release 模式下 assetTypes?: string[]; // 资源类型数组，仅 release 模式下 subpackages?: Record; // 分包资源信息，仅仅支持分包的平台存在 renderPipeline：string；// renderPipeline 信息，取自项目设置 } 这里的结构仅列举了通用流程下的 settings 结构，实际上在不同的平台打包时，会根据需要添加配置。 settings uuid 压缩与文件写入 资源打包过程中也会不断的收集参与资源构建的资源 uuid，最终会整理写进 setting.js。setting.js 会被写入在构建后文件夹的 src 目录下，生成之前将会根据是否为调试模式来决定是否对文件内的 uuid 做压缩处理，所有使用到的 uuid 会进行整理，将出现 两次以上 的存储进 uuids 数组内，之前使用 uuid 的位置替换为索引。所有出现两次的 assetType 也会存储到 assetTypes 数组中，使用的地方存储为索引。 构建资源 这一步骤内所指的对资源的打包是指除了脚本以外的资源文件，因为脚本是作为特殊文件来打包处理的。在打包资源阶段，编辑器会先汇总当前参与构建的场景以及所有在 resources 目录下的资源，每个资源的打包都会经过引擎的反序列化，查找出依赖资源再递归进行资源的打包。在反序列化之前会先配置整个项目的脚本环境，也就是加载所有的非插件项目脚本。因为脚本的加载正确与否会直接影响到反序列化的进行，因而如果脚本编写的不合法加载失败会直接导致构建失败。如果在反序列化过程中发现有依赖的资源丢失会发出警告，但会继续进行构建。这里的警告并不意味着问题不需要解决，如果资源丢失不解决，是难于保证构建后的内容不出问题的。 资源在打包过程中执行反序列化后会重新压缩序列化，以减小打包之后的包体。texture 资源的序列化文件会全部打包成一个 json 文件，其他序列化文件则根据构建配置参数来决定是否分包。 构建脚本 编辑器内对脚本的构建分为 插件脚本 和 非插件脚本 两类。 插件脚本会直接将源文件按照原来的目录结构拷贝到构建后生成的 build/src 目录下，所以 插件脚本是不支持任何需要编译的脚本形式 的比如 ts 或者是使用 es6 写法的 js。插件脚本的资源信息则会写进 settings 里的 jsList 数组内。 非插件脚本将会全部打包成 project.js（调试模式下是 project.dev.js），放在对应的 src 目录下。 平台适配处理 构建提供了部分生命周期的钩子函数，方便开发者在构建的不同处理时期参与构建，影响构建结果。同时构建也提供了开发者直接添加一些构建选项的方法，可以修改构建配置页的 UI 界面、数据检验等等。目前这些功能都尚未对外开放，这里只简单介绍，但编辑器内部的平台构建插件已经是以这种方式开发的。构建插件注入的构建选项将会存放在 options.packages 内部，因而目前命令行构建的选项参数编写方式也需要遵循此规则。 常见问题指南 构建的整个进程是在一个单独的 worker 内的，所以如果想要查看构建过程的 log 信息或者查看出现报错时完整的调用栈，需要在主菜单的 开发者 -> 打开构建调试工具 里打开。构建时其实会输出很多的 log 信息，但是为了不干扰用户只有错误和重要信息会被打印到编辑器的控制台，调试工具里的信息才是最完整的。当然，也可以在 偏好设置 -> 扩展 -> builder -> 日志等级 内修改日志等级，详情可以参考 构建相关文档。 有必要说明的是，在构建之前请先确保参与构建的场景是可以正常预览的。一些场景的资源丢失或者其他脚本问题，是在预览阶段就能暴露出来的。在保证预览正常的情况下构建能更好的节约时间以及排查问题。 资源加载 404 这种情况下，请复制报资源丢失信息里的 uuid 去资源管理器里面查找对应的资源，查看该资源依赖的资源是否都正常。资源加载 404 通常有以下几种情况： 在脚本内动态加载了没有放在 resources 中的资源。 原因：通过上面的介绍，我们知道只有在 resources 目录下的资源以及参与构建场景的资源才会被打包到最终的构建文件夹内，并且只有放进 resources 文件夹内的资源 url 才会写入到 settings.js。所以如果在脚本内使用了某个资源但这个资源没有放在 resources 目录下，之后加载就会出现 404 了。 解决方案：将使用到的资源移动在 resources 文件夹下。 加载的资源导入有问题，未能正常生成数据到 library 内 原因：构建时所有的原始数据都是通过读取 library 中的资源文件获得的，如果导入失败将无法获取到正确对应的资源信息。 解决方案：通过资源管理器找到对应资源，点击右键，选择菜单中的 重新导入资源。 资源丢失 原因：在前面的构建流程里介绍过，资源的构建会经过反序列查找依赖，而最经常出现问题的就是所依赖的资源在项目迭代过程中被不小心删除而导致资源丢失。这些资源的丢失可能平时并没有注意到，但一旦执行构建将会暴露出来。 解决方案：通过代码编辑器查找该 uuid 被哪些资源所引用，修改对应资源。 脚本资源加载报错 在前面介绍 构建数据整理 时有提到过，构建时需要配置脚本环境。如果报错信息与脚本相关，请参考报错内容对脚本进行修改。如果不清楚是哪个脚本的报错，可以在报错信息调用栈中找到对应脚本的 uuid，然后在资源管理器中查找定位。 如何查找到小图自动合图后的大图 自动图集在构建过程中会打印出原始小图与合成大图的 uuid 信息，直接在构建调试工具内就可以查看到，用查找到的大图 uuid 在打包后文件夹 res/raw-assets 内查看即可。如果合图太多，可以打开构建 log 用搜索 uuid 的方式查找。 引擎编译失败 如果是自定义引擎编译失败，请检查你修改的代码，或者自定义引擎路径。 如果是引擎编译失败，请附上 Creator 3D 版本、构建选项配置、构建任务中的构建日志文件以及可复现问题的 demo 到 论坛 提问。 其他报错 如果遇到其他无法自行解决的构建报错信息，请附上 Creator 3D 版本、构建选项配置、构建任务中的构建日志文件以及可复现问题的 demo 到 论坛 提问。 "},"editor/publish/publish-alipay-mini-game.html":{"url":"editor/publish/publish-alipay-mini-game.html","title":"发布到支付宝小游戏","keywords":"","body":"发布到支付宝小游戏 Cocos Creator 3D 从 v1.0.3 版本开始正式支持将游戏发布到支付宝小游戏。 参数选项说明 参数名 可选 默认值 说明 polyfills 选填 { asyncFunctions: true } 自 v1.0.3 版本起，构建支持一些新特性的 polyfills ，主要是在打包脚本时会做对应处理，开发者可以根据实际需求选择需要的 polyfills, 这组选项暂时只有异步函数，后续将会开放更多功能。 remoteUrl 选填 ' ' 服务器地址，指定了服务器地址后，资源将会从服务器上下载，具体加载规则可以参考微信小程序端 deviceOrientation | 必填 | 'auto' | 设备方向，可选值为'landscape' | 'portrait'。| 环境配置 桌面端下载 支付宝小程序开发者工具 并安装。 下载 支付宝，并安装到手机设备上。 支付宝客户端在 Android 上支持的最低版本为 10.1.75，在 iOS 为 10.1.78。 发布流程 一、使用 Cocos Creator 3D 打开需要发布的项目工程，在 构建发布 面板的 发布平台 中选择 Alipay Mini Game。然后点击 构建。 二、构建完成后点击 发布路径 后的 打开 按钮，可以看到在发布包 build 目录下生成了支付宝小游戏工程文件夹 alipay，其中已经包含了支付宝小游戏环境的配置文件 game.json。 三、使用 支付宝开发者工具 打开构建生成的 alipay 文件夹，即可打开支付宝小游戏项目以及预览调试游戏内容。 支付宝小游戏环境的资源管理 支付宝小游戏与微信小游戏类似，都存在着包体限制，超过 4MB 的额外资源，必须通过网络请求下载。 我们建议用户只保存脚本文件在小游戏包内，其他资源都从远程服务器下载。Cocos Creator 3D 已经帮用户做好了远程资源的下载、缓存和版本管理。具体的实现逻辑和微信小游戏类似，详情可参考 微信小游戏资源管理。 具体来说，开发者需要做的是： 构建时，设置 远程服务器地址，然后点击 构建。 构建完成后将支付宝小游戏发布包目录下的 res 文件夹完整的上传到服务器。 删除本地发布包目录下的 res 文件夹。 支付宝小游戏已知问题： 我们对支付宝小游戏的适配工作还未完全结束，目前已知在低端机上文本渲染效果可能不太理想。并且仍不支持以下模块： WebView VideoPlayer 分包加载 自定义字体 以上功能预计在以后的更新中会逐步支持，我们也将持续与支付宝小游戏的工程师们紧密沟通，不断优化适配效果。 文档相关 由于支付宝小游戏相关的文档目前只对内开放，开发者如果有需要的话可直接联系： 联系人 Email 李智 lz98684@alibaba-inc.com 黄娇 huangjiao.hj@alibaba-inc.com "},"editor/publish/publish-baidugame.html":{"url":"editor/publish/publish-baidugame.html","title":"Publishing to Baidu Mini Games","keywords":"","body":"Publishing to Baidu Mini Games Note: Some platforms only have Chinese documentation available when visiting the platforms website. It may be necessary to use Google Translate in-order to review the documentation. Cocos Creator 3D officially supports the release of games to the Baidu Mini Games. The runtime environment of the Baidu Mini Game is an extension of the Baidu Smart Mini Program. This provides a WebGL interface encapsulation based on the mini program environment. This greatly improves the rendering capabilities and performance. However, since these interfaces are encapsulated by the Baidu team, they are not equivalent to the browser environment. On the engine side, in order to make the developers' workload as easy as possible, our main tasks for developers include the following: The engine framework adapts to the Baidu Mini Game API, pure game logic level, developers do not need any additional modifications. The Cocos Creator 3D editor provides a fast packaging process, released directly as a Baidu Mini Game, and automatically evokes the Baidu DevTools. Automatically load remote assets, cache assets, and cache asset version control. Please refer to the Baidu Mini Game Developer Documentation documentation to review the game submission, the review, and the release process for a Baidu Mini Game. Publish Baidu Mini Games with Cocos Creator 3D Prerequisites Download and install Baidu DevTools in Baidu DevTools Documentation. Download and install the Baidu App in the app store of your phone. Log in to Baidu Smart Mini Progame Platform and find App ID. Release process Select the Baidu Mini Game in the Platform of the Build panel, fill in the appid, and then click Build. After a build is completed, a baidu-mini-game folder will be generated in the project's build directory (the name of the folder is based on the Build Task Name), which already contains the configuration files game.json and project.swan.json of the Baidu Mini Games environment. Use the Baidu DevTools to open the baidu-mini-game folder to preview and debug the game. Please refer to the Baidu DevTools documentation for details. About how ​​to use Baidu DevTools, please refer to Baidu DevTools Documentation for details. Note: When previewing and debugging, if a prompt appears stating: The current version of the developer tool can't publish mini program, please update to the latest devtools. This means the appid filled in the Build panel is the appid of the Baidu Smart Mini Program, not the appid of the Baidu Mini Game, please re-apply for the appid of the Baidu Mini Game. asset Management for Baidu Mini Game Environment Baidu Mini Game is similar to WeChat Mini Game. There are restrictions on the package size. Assets more than 4MB must be downloaded via a network request. It is recommended to only save script files in the mini-game packages, while other assets are uploaded to the remote server, and downloaded from the remote server as needed. The download, cache, and version management of remote assets, Cocos Creator 3D has already done it for you. The specific implementation logic is similar to the WeChat Mini Game. Please refer to the asset Management for WeChat Mini Game Environment documentation for details. When the MD5 Cache feature of the engine is enabled, the URL of the file will change as the content of the file changes. When the game releases a new version, the assets of the old version will naturally become invalid in the cache, and only the new assets can be requested from the server, which achieves the effect of version control. Specifically, developers need to do the following: When building, check the MD5 Cache in the Build panel. Set Remote server address in the Build panel and then click Build. After the build is complete, upload the build/baidu-mini-game/res folder to the server. Delete the res folder under the local release package directory. Note: When Baidu loads the assets on the remote server on the physical device, it only supports access via HTTPS, so the asset file must be placed on HTTPS, otherwise the loading of the asset will fail. Note: If the cache asset exceeds the environment limit of Baidu, you need to manually clear the asset. You can use the remoteDownloader.cleanAllCaches() and remoteDownloader.cleanOldCaches() interfaces to clear the cache in Baidu mini game. The former will clear all cache assets in the cache directory, please use it with caution. The latter will clear the cache assets that are not used in the current application in the cache directory. Baidu Mini Game Subpackage Loading The subpackage loading method of Baidu Mini Game is similar to WeChat, with the following package restrictions: The size of all subpackages of the entire Mini Game can not exceed 8MB. The size of a single subpackage / main package can not exceed 4MB. Please refer to the SubPackage Loading documentation for details. Platform SDK Access In addition to pure game content, the Baidu Mini Game environment also provides a very powerful native SDK interface. These interfaces only exist in Baidu Mini Game environment, equivalent to the third-party SDK interface of other platforms. The porting of such SDK interfaces still needs to be handled by developers at this stage. Here are some of the powerful SDK capabilities offered by Baidu Mini Game: User interface: login, authorization, user information, etc. Baidu cashier payment Forwarding information File upload and download Other: images, locations, ads, device information, etc. Baidu Mini Games known issues Currently, the adaptation work of Baidu Mini Game is not completely finished, and the following components are not supported for the time being: VideoPlayer WebView If needed, you can directly call Baidu's API as needed. Reference documentation Note: Some platforms only have Chinese documentation available when visiting the platforms website. It may be necessary to use Google Translate in-order to review the documentation. Baidu Mini Game Registration Guide Baidu DevTools documentation Baidu Mini Game API documentation "},"editor/publish/publish-bytedance-mini-game.html":{"url":"editor/publish/publish-bytedance-mini-game.html","title":"Publishing to ByteDance Mini Games","keywords":"","body":"Publishing to ByteDance Mini Games Note: Some platforms only have Chinese documentation available when visiting the platforms website. It may be necessary to use Google Translate in-order to review the documentation. ByteDance Mini Games are developed based on ByteDance full products, which do not require users to download. This is a brand-new game type that can be played on tap. The game submission, review and release process of a mini-game needs to comply with the requirements and standard processes of the Byte official specification. For specific information, please refer to the links at the end of this document. Publishing to ByteDance with Cocos Creator 3D Download the ByteDance DevTools on ByteDance Official Website. Log in to Developer Platformto find your mini game appid. For details, please refer to the official Access Guide documentation. Select the ByteDance Mini Game in the Platform in the Build panel, fill in the mini game appid, and then click Build Preview game Following this process, a bytedance-mini-game folder will be generated in the project's build directory (the name of the folder is based on the Build Task Name), then you can open your game with the ByteDance DevTools. Build Options Options Optional or not Default Explanation appid Required testId The appid of the ByteDance Mini Games, it will be written to project.config.json file. Remote server address Optional Empty The remote server address. Resources will then be obtained from this address. Open data context root Optional Empty If an Open Data Context exists, use this root to specify the relative path of the Open Data Context folder in the build directory so that the directory is not overwritten or modified during the build. Orientation Required landscape Device orientation, it will be written to game.json file. Asset Management for ByteDance Mini Game Environment In a ByteDance Mini Game environment, asset management is the most special part. It differs from the browser in the following four points: The size of the ByteDance Mini Game package cannot exceed 4MB, including all the code and assets. Additional assets must be downloaded via web request. For files downloaded from a remote server, the ByteDance Mini Game environment does not have the browser's caching and outdated update mechanism. For the assets in the ByteDance Mini Game package, they are not loaded on demand in the mini game environment, but rather all the assets in the package are loaded at once, and then the game page is launched. You cannot download script files from a remote server. This brings up two key issues, home page loading speed and remote asset caching and version management. For the home page loading speed, we recommend that developers only save the script file in the ByteDance Mini Game package, and all other assets are downloaded from the remote server. As for downloading, caching and version management of remote assets, Cocos Creator 3D has done the job for developers. Specifically, developers need to do the following: When building, enable the MD5 Cache in the Build config panel. Set the Remote service address, and then click Build. When the build is complete, upload the res folder in the mini game release package to the server. Delete the res folder inside the local release package. For the test phase, you may not be able to deploy to the official server, you need to use the local server to test, then open the details page in the WeChat DevTools, check the Does not verify valid domain names, web-view (business domain names), TLS versions and HTTPS certificates option in the Local Settings. Reference documentation Note: Some platforms only have Chinese documentation available when visiting the platforms website. It may be necessary to use Google Translate in-order to review the documentation. ByteDance Mini Game Developer Document Guide ByteDance Developer Platform ByteDance Mini Game API Documentation ByteDance DevTools Download ByteDance DevTools Documentation "},"editor/publish/publish-cocos-play.html":{"url":"editor/publish/publish-cocos-play.html","title":"发布到 Cocos Play","keywords":"","body":"发布到 Cocos Play（即刻玩） Cocos Creator 3D 从 v1.0.3 版本开始正式支持将游戏发布到 Cocos Play。 发布流程 准备工作 下载 游戏自测工具 并安装到 Android 设备（建议 Android Phone 6.0 或以上版本）。 构建 一、使用 Cocos Creator 3D 打开需要发布的项目工程，在 构建发布 面板的 发布平台 中选择 Cocos Play，然后点击 构建。 参数配置具体的填写规则如下： 小包模式 该项为选填项。游戏的包内体积包含代码和资源不能超过 10M，资源可以通过网络请求加载。小包模式 就是帮助用户将脚本文件保留在游戏包内，其他资源则上传到远程服务器，根据需要从远程服务器下载。而远程资源的下载、缓存和版本管理，Creator 3D 已经帮开发者做好了。开发者需要做的是以下步骤： 构建之前，填写 小包模式服务器路径。然后点击 构建。 首屏游戏资源打包到游戏包，该选项为选填项。 在小包模式下，由于首屏资源过多，下载和加载资源时间比较久，可能会导致首次进入游戏时出现短暂黑屏。如果在构建时勾选了 首屏游戏资源打包到游戏包，可以缩短首次进入游戏黑屏的时间。不过需要注意的是：res/import 资源暂不支持分割资源下载，整个 import 目录也会打包到首包。 开发者可以根据自己的需要选择是否勾选该项。然后点击 构建。 构建完成后，点击 发布路径 后面的 打开 按钮，将发布路径下的 res 目录上传到服务器。例如：默认发布路径是 build，构建任务名是 cocos-play，则需要上传 build/cocos-play/res 目录。 此时，构建出来的 cpk 将不再包含 res 目录，res 目录里的资源将通过网络请求从填写的 小包模式服务器地址 上下载。 命令行构建参数： tinyPackageMode: false, tinyPackageServer: '', packFirstScreenRes: false, 二、构建发布 面板的相关参数设置完成后，点击 构建。构建完成后点击对应构建任务下方的 文件图标 按钮来打开构建发布包。如果构建任务名是 cocos-play，可以看到在默认发布路径 build 目录下生成了 cocos-play 文件夹，该文件夹就是导出的 Cocos Play 游戏工程和 cpk，cpk 包在 build/cocos-play 目录下。 接入测试 开发者必须使用自测工具测试接入没有问题之后，才可以打包提交到平台审核。自测时没有要求包的大小，但如果是要提交审核的话，包的大小不能超过 10M。自测工具可以启动游戏并提供游戏登录、支付等功能。通过读取游戏配置参数，确定启动的游戏类型，以及游戏启动方式。具体可参考 自测工具。 打开之前已经安装完成的游戏自测工具，然后点击自测工具左上方的 配置游戏 按钮进入游戏配置页面。根据需求配置参数并保存。 参数配置 属性 功能说明 gameId 游戏 ID，可由后台获取 gameKey 游戏 Key，可由后台获取 gameSecret 游戏密钥，可由后台获取 gameType 游戏类型，可根据用户需求选择 对战 或者 非对战 gameMode 游戏模式，选择 Runtime lodeType 游戏加载类型，即游戏启动方式。包括 File 和 Url 两种。具体使用方式可查看下方 启动游戏 部分的介绍 path 游戏加载地址，配合 lodeType 使用。具体使用方式可查看下方 启动游戏 部分的介绍 启动游戏 游戏自测工具可以通过以下两种方法启动游戏。 方法一：以文件方式从指定位置加载游戏包（游戏加载类型为 File） 将构建生成的小游戏 cpk 文件（位于 build/cocos-play 目录下）拷贝到手机目录下。如果是拷贝到手机 sdcard 目录下，则需要在 sdcard 目录中新建一个文件夹（命名为 cocosplay），然后将 cpk 文件拷贝到 cocosplay 文件夹中。 游戏自测工具参数配置页面中的 lodeType 选择 File。 path 填写刚才拷贝 cpk 文件放置的新建文件夹，如：/cocosplay/game.cpk。 配置完成后点击 保存，然后点击 启动游戏，即可打开游戏。 方法二：以网页方式从指定网址打开游戏（游戏加载类型为 Url） 将 cpk 文件上传到服务器。 游戏自测工具参数配置页面中的 lodeType 选择 Url。 填写 path，如：http://192.168.0.1:8080/game.cpk。 配置完成后点击 保存，然后点击 启动游戏，即可打开游戏。 相关参考链接 Cocos Play 中心 Cocos Play 文档中心 Cocos Play API 文档 Cocos Play 自测工具 Cocos Play 自测工具下载 "},"editor/publish/publish-huawei-mini-game.html":{"url":"editor/publish/publish-huawei-mini-game.html","title":"发布到华为快游戏","keywords":"","body":"发布到华为快游戏平台 Cocos Creator 3D 从 v1.0.2 版本开始正式支持将游戏发布到华为快游戏平台。我们来看一下如何使用 Cocos Creator 3D 发布到华为快游戏平台。 环境配置 下载 华为快应用加载器，并安装到 Android 设备上（建议 Android Phone 6.0 或以上版本） PC 端全局安装 nodejs-8.1.4 或以上版本 发布流程 一、使用 Cocos Creator 3D 打开需要发布的项目工程，在 构建发布 面板的 发布平台 中选择 华为快游戏。 必填参数项：根据用户的需求及参数输入框的提示信息进行填写，包括：应用包名、应用名称、桌面图标、应用版本名称、应用版本号、支持的最小平台版本号。 选填参数项：包括 自定义 manifest 文件路径、小包模式、小包模式服务器路径 。 密钥库 以及两个签名文件（certificate.pem 路径 和 private.pem 路径），需要根据用户需求选择勾选 密钥库 或者填写两个路径。 相关参数配置具体的填写规则如下： 游戏名称 该项为必填项。是华为快游戏的名称。 游戏包名 该项为必填项，根据用户的需求进行填写。 桌面图标 该项为必填项。构建时 桌面图标 将会构建到华为快游戏的工程中。点击输入框右边的按钮即可选择图片。桌面图标建议使用 png 图片。 应用版本名称 该项为必填项，根据用户的需求进行填写。 应用版本号 该项为必填项，根据用户的需求进行填写。 支持的最小平台版本号 该项为必填项。根据华为的要求目前这个值必须大于或等于 1035。 自定义 manifest 文件路径 该项为选填项。为华为快游戏扩展功能。使用时需要选择 json 文件，文件中的数据类型要求为 json 格式。注意：当 json 数据的 key 值为 package、appType、name、versionName、versionCode、icon、minPlatformVersion、config、display 时不可用。否则在构建时会被 应用包名，应用名称，应用图标，应用版本号，应用版本名称 等数据覆盖。 小包模式和小包模式服务器路径 该项为选填项。快游戏的包内体积包含代码和资源不能超过 10M，资源可以通过网络请求加载。小包模式 就是帮助用户将脚本文件保留在快游戏包内，其他资源则上传到远程服务器，根据需要从远程服务器下载。而远程资源的下载、缓存和版本管理，Creator 3D 已经帮用户做好了。用户需要做的是以下两个步骤： 1、构建时，勾选 小包模式，填写 小包模式服务器路径。然后点击 构建。 2、构建完成后，点击 发布路径 后面的 打开 按钮，将发布路径下的 res 目录上传到小包模式服务器。例如：默认发布路径是 build，构建任务名是 huawei-quick-game，则需要上传 build/huawei-quick-game/res 目录。 此时，构建出来的 rpk 将不再包含 res 目录，res 目录里的资源将通过网络请求从填写的 小包模式服务器地址 上下载。 分包 v1.0.4 起添加该选项，默认开启，用于控制分包功能的开启。 密钥库 勾选 使用调试密钥库 时，表示默认使用的是 Creator 3D 自带的证书构建 rpk 包，仅用于 调试 时使用。 注意：若 rpk 包要用于提交审核，则构建时不要勾选该项。 如果不勾选 密钥库，则需要配置签名文件 certificate.pem 路径 和 private.pem 路径，此时构建出的是可以 直接发布 的 rpk 包。用户可通过输入框右边的按钮来配置两个签名文件。 有以下两种方式可以生成签名文件： 通过 构建发布 面板 certificate.pem 路径 后的 新建 按钮生成 通过命令行生成 release 签名 用户需要通过 openssl 命令等工具生成签名文件 private.pem、certificate.pem。 # 通过 openssl 命令工具生成签名文件 openssl req -newkey rsa:2048 -nodes -keyout private.pem -x509 -days 3650 -out certificate.pem 注意：openssl 工具在 linux 或 Mac 环境下可在终端直接打开。而在 Windows 环境下则需要安装 openssl 工具并且配置系统环境变量，配置完成后需重启 Creator 3D。 二、构建发布 构建发布 面板的相关参数设置完成后，点击 构建。构建完成后点击 发布路径 后面的 打开 按钮来打开构建发布包，可以看到在默认发布路径 build 目录下生成了与构建任务名称一致的目录，该目录就是导出的华为快游戏工程目录和 rpk，rpk 包在对应文件夹的 dist 目录下。 三、将打包出来的 rpk 运行到手机上。 目前仅支持手动拷贝到手机上运行。将构建生成的 rpk 包拷贝到手机 sdcard 目录下。然后在手机上打开 华为快应用加载器 后，点击手机的返回键会弹出一个列表，选择第一个选项 本地安装，选择路径为放置 rpk 的路径，即可将 rpk 运行到手机上。 四、分包 rpk 分包 rpk 是根据用户的需求选择是否使用。分包加载，即把游戏内容按一定规则拆分在几个包里，在首次启动的时候只下载必要的包，这个必要的包称为 主包，开发者可以在主包内触发下载其他子包，这样可以有效降低首次启动的消耗时间。若要使用该功能需要在 Creator 3D 中设置 分包加载，设置完成后在构建时就会自动分包。 构建完成后，生成的子包和主包会合并成一个 rpk，生成目录在 /build/huawei-mini-game/dist 目录下。 注意：目前华为不支持同时下载多个分包，需要下载多个分包时请按顺序下载，等待下一个分包下载完成后再下一个分包。 相关参考链接 华为快游戏开发文档 "},"editor/publish/publish-oppo-mini-game.html":{"url":"editor/publish/publish-oppo-mini-game.html","title":"发布到 OPPO 小游戏","keywords":"","body":"发布到 OPPO 小游戏 Cocos Creator 3D 从 v1.0.2 开始正式支持将游戏发布到 OPPO 小游戏。目前本文档是基于 v1.0.2 编写的，如果您使用的是其他低于该版本的编辑器，建议升级到 1.0.2 以上版本。下面我们来看一下具体的发布流程。 环境配置 下载 OPPO 小游戏调试器，并安装到 Android 设备上（建议 Android Phone 6.0 或以上版本） 全局安装 nodejs-8.1.4 或以上版本 根据用户自己的开发需求判断是否需要安装 调试工具。 发布流程 一、使用 Cocos Creator 3D 打开需要发布的项目工程，在 构建发布 面板的 发布平台 中选择 OPPO Mini Game。 必填参数项：根据用户的需求及参数输入框的提示信息进行填写，包括：游戏包名、游戏名称、桌面图标、游戏版本名称、游戏版本号、支持的最小平台版本号。 选填参数项：包括 小包模式、小包模式服务器路径 密钥库 以及两个签名文件（certificate.pem 路径 和 private.pem 路径），需要根据用户需求选择勾选 密钥库 或者填写两个路径。 相关参数配置具体的填写规则如下： 游戏包名 该项为必填项，根据用户的需求进行填写。 游戏名称 该项为必填项。是 OPPO 小游戏的名称。 桌面图标 桌面图标 为必填项。点击输入框后面的 ... 按钮选择所需的图标。构建时，图标将会被构建到 OPPO 小游戏的工程中。桌面图标建议使用 png 图片。 游戏版本名称 该项为必填项，根据用户的需求进行填写。 游戏版本号 该项为必填项，根据用户的需求进行填写。 支持的最小平台版本号 该项为必填项。根据 OPPO 的要求目前这个值必须大于或等于 1031。 小包模式和小包模式服务器路径 该项为选填项。小游戏的包内体积包含代码和资源不能超过 10M，资源可以通过网络请求加载。小包模式 就是帮助用户将脚本文件保留在小游戏包内，其他资源则上传到远程服务器，根据需要从远程服务器下载。而远程资源的下载、缓存和版本管理，Creator 3D 已经帮用户做好了。用户需要做的是以下两个步骤： 1、构建时，勾选 小包模式，填写 小包模式服务器路径。然后点击 构建。 2、构建完成后，点击 发布路径 后面的 打开 按钮，将发布路径下的 res 目录上传到小包模式服务器。例如：默认发布路径是 build，构建任务名为 oppo-mini-game, 则需要上传 /build/oppo-mini-game/res 目录。 此时，构建出来的 rpk 将不再包含 res 目录，res 目录里的资源将通过网络请求从填写的 小包模式服务器地址 上下载。 分包 v1.0.4 起添加该选项，默认开启，用于控制分包功能的开启。详情请查看本文档末尾的 分包 介绍。 密钥库 勾选 密钥库 时，表示默认用的是 Creator 3D 自带的证书构建 rpk 包，仅用于 调试 时使用。 注意：若 rpk 包要用于提交审核，则构建时不要勾选该项。 如果不勾选 密钥库，则需要配置签名文件 certificate.pem 路径 和 private.pem 路径，此时构建出的是可以 直接发布 的 rpk 包。用户可通过输入框右边的 ... 按钮来配置两个签名文件。 用户可以通过以下两种方式生成签名文件，如下： 通过 构建发布 面板 certificate.pem 路径 后的 新建 按钮生成。 通过命令行生成 release 签名。 用户需要通过 openssl 命令等工具生成签名文件 private.pem、certificate.pem。 # 通过 openssl 命令工具生成签名文件 openssl req -newkey rsa:2048 -nodes -keyout private.pem -x509 -days 3650 -out certificate.pem 注意：openssl 工具在 linux 或 Mac 环境下可在终端直接打开。而在 Windows 环境下则需要安装 openssl 工具并且配置系统环境变量，配置完成后需重启 Creator 3D。 二、构建发布 面板的相关参数设置完成后，点击 构建。构建完成后点击对应构建任务上的 在文件夹中显示 打开构建发布包位置，可以看到在默认发布路径 build 目录下生成了与构建任务名称相同的目录，该目录就是导出的 OPPO 小游戏工程目录和 rpk，rpk 包在对应目录的 dist 文件夹下。 三、将构建出来的 rpk 运行到手机上。 将构建生成的小游戏 rpk 包（ dist 目录中）拷贝到手机 SD 卡的 /sdcard/games/ 目录。然后在 Android 设备上打开之前已经安装完成的 OPPO 小游戏调试器，点击 OPPO 小游戏 栏目，然后找到填写游戏名相对应的图标即可，如没有发现，可点击右上角的更多按钮-刷新按钮进行刷新。 注意：OPPO 小游戏调试器为 V3.2.0 及以上的需要将准备好的 rpk 拷贝到手机 sdcard 的 Android/data/com.nearme.instant.platform/files/games 中, 无 games 目录则需新建 四、分包 rpk 编辑器自 v1.0.4 开始支持 OPPO 的分包功能，并将分包开关集成到构建面板内，构建之前可以通过该选项快速的关闭和开启分包功能。 分包加载，即把游戏内容按一定规则拆分成几个包，在首次启动的时候只下载必要的包，这个必要的包称为 主包，开发者可以在主包内触发下载其他子包，这样可以有效降低首次启动的消耗时间。若要使用该功能需要在 Creator 3D 中设置 分包配置，设置完成后构建时就会自动分包。 构建完成后，分包的目录在 dist 目录下。 这时需要在 Android 设备的 sdcard 目录下，新建一个 subPkg 目录，然后把 dist 目录下的 .rpk 文件拷贝到 subPkg 目录中。 然后切换到 OPPO 小游戏调试器 的 分包加载 栏目，点击右上方的刷新即可看到分包的游戏名称，点击 秒开 即可跟正常打包的 rpk 一样使用。 注意：分包 rpk 需要拷贝到 Android 设备的 /sdcard/subPkg/ 目录，未分包的 rpk 需要拷贝到 Android 设备的 /sdcard/games/ 目录，两者不可混用。 相关参考链接 OPPO 小游戏调试说明 OPPO 小游戏教程 OPPO 小游戏 API 文档 OPPO 小游戏工具下载 "},"editor/publish/publish-vivo-mini-game.html":{"url":"editor/publish/publish-vivo-mini-game.html","title":"发布到 vivo 小游戏","keywords":"","body":"发布到 vivo 小游戏 环境配置 下载 快应用 & vivo 小游戏调试器 和 vivo 小游戏引擎，并安装到 Android 设备上（建议 Android Phone 6.0 或以上版本） 全局安装 nodejs-8.9.0 或以上版本 注意：安装 nodejs 后，需要注意 npm 源地址是否为 https://registry.npmjs.org/ # 查看当前 npm 源地址 npm config get registry # 若不是，重新设置 npm 源地址 npm config set registry https://registry.npmjs.org/ 全局安装 vivo-minigame/cli。确定 npm 源地址后，安装 vivo-minigame/cli： npm install -g @vivo-minigame/cli 若 vivo-minigame/cli 安装失败，可能是因为 nodejs 版本过低导致的，请检查 node 版本并升级。 发布流程 一、使用 Cocos Creator 3D 打开需要发布的项目工程，在 构建发布 面板的 发布平台 中选择 vivo Mini Game。 相关参数配置具体的填写规则如下： 游戏包名 该项为必填项，根据用户的需求进行填写。 游戏名称 该项为必填项，是 vivo 小游戏的名称。 桌面图标 桌面图标 为必填项。点击输入框后面的按钮选择所需的图标。构建时，图标将会被构建到 vivo 小游戏的工程中。桌面图标 建议使用 .png 图片。 游戏版本名称 该项为必填项。游戏版本名称 是真实的版本，如：1.0.0 游戏版本号 该项为必填项。游戏版本号 与 游戏版本名称 不同，游戏版本号 主要用于区别版本更新。每次提交审核时应用版本号都要比上次提交审核的值至少 +1，一定不能等于或者小于上次提交审核的值，建议每次提交审核时应用版本号递归 +1。注意：应用版本号 必须为正整数。 支持的最小平台版本号 该项为必填项。具体填写值可通过点击 更新记录 来查看最新的 vivo 引擎版本号。 小包模式 该项为选填项。小游戏的包内体积包含代码和资源不能超过 4M，资源可以通过网络请求加载。小包模式 就是帮助用户将脚本文件保留在小游戏包内，其他资源则上传到远程服务器，根据需要从远程服务器下载。而远程资源的下载、缓存和版本管理，Creator 3D 已经帮用户做好了。用户需要做的是以下几个步骤： 构建时，勾选 小包模式，填写 小包模式服务器路径。 首屏游戏资源打包到游戏包 在小包模式下，由于首屏资源过多，下载和加载资源时间比较久，可能会导致首次进入游戏时出现短暂黑屏。如果在构建时勾选了 首屏游戏资源打包到游戏包，可以缩短首次进入游戏黑屏的时间。不过需要注意的是：res/import 资源暂不支持分割资源下载，整个 import 目录也会打包到首包。 开发者可以根据自己的需要看是否勾选该项。然后点击 构建。 构建完成后，点击 发布路径 后面的 打开 按钮，将发布路径下的 res 目录上传到小包模式服务器。例如：默认发布路径是 build，构建任务名为 vivo-mini-game, 则需要上传 /build/vivo-mini-game/res 目录。 注意：如果是命令行编译小包模式，记得备份 build/vivo-mini-game/res 目录，然后删除 build/vivo-mini-game/res 目录，再进行命令行编译（npm run build）。 2、 此时，构建出来的 rpk 将不再包含 res 目录，res 目录里的资源将通过网络请求从填写的 小包模式服务器路径 上下载。 分包 v1.0.4 起添加该选项，默认值为 true，用于控制分包功能的开启。 密钥库 勾选 密钥库 时，表示默认用的是 Creator 3D 自带的证书构建 rpk 包，仅用于 测试和调试 时使用。 如果不勾选 密钥库，则需要配置签名文件 certificate.pem 路径 和 private.pem 路径，此时构建出的是可以 直接发布 的 rpk 包。用户可通过输入框右边的 ... 按钮来配置两个签名文件。注意：这两个签名文件建议不要放在发布包 build/qgame 目录下，否则每次构建时都会清空该目录，导致文件丢失。 有以下两种方式可以生成签名文件： 通过 构建发布 面板 certificate.pem 路径 后的 新建 按钮生成。 通过命令行生成 release 签名 用户需要通过 openssl 命令等工具生成签名文件 private.pem、certificate.pem。 # 通过 openssl 命令工具生成签名文件 openssl req -newkey rsa:2048 -nodes -keyout private.pem -x509 -days 3650 -out certificate.pem 注意：openssl 工具在 linux 或 Mac 环境下可在终端直接打开，而在 Windows 环境下则需要安装 openssl 工具并且配置系统环境变量。 二、构建发布 面板的相关参数设置完成后，点击 构建。构建完成后点击 发布路径 后面的 打开 按钮来打开构建发布包，可以看到在默认发布路径 build 目录下生成了与构建任务名称相同的目录例如 vivo-mini-game，该目录就是导出的 vivo 小游戏工程原始目录，但并不是编译目录。打开编辑器安装目录下的 resources/tools/vivo-pack-tools 的文件夹，该文件夹内存放了 vivo 的本地打包工具，每次构建会将项目里的信息生成到这里构建出 rpk 后再拷贝会源目录，如果想要自行编译项目需要在该目录下进行。 并且在 /build/vivo-mini-game/dist 目录下会生成 rpk 包。 三、将打包出来的 rpk 运行到手机上。有以下三种方式可将 rpk 运行到手机上： 方法一： 在 构建发布 面板点击 运行 按钮，等待二维码界面生成 然后在 Android 设备上打开之前已经安装完成的 快应用 & vivo 小游戏调试器，点击 扫码安装 按钮直接扫描二维码即可打开 rpk。 方法二： 将构建生成的小游戏 rpk 文件（位于打包出的小游戏工程目录下的 dist 目录中）拷贝到手机 sdcard 目录下。 在 Android 设备上打开之前已经安装完成的 快应用 & vivo 小游戏调试器，点击 本地安装，然后从手机 sdcard 目录中找到 rpk 文件，选择打开即可。 方法三： 利用 vivo 小游戏打包工具命令生成网址和二维码 # 先把命令行指定到编辑器安装目录下的 resources/tools/vivo-pack-tools 目录下 cd ${CocosCreator3D}/resources/tools/vivo-pack-tools # 生成网址和二维码 npm run server 然后在 Android 设备上打开之前已经安装完成的 快应用 & vivo 小游戏调试器 最后点击 扫码安装 按钮，将第一步中生成的网址拷贝到浏览器，然后直接扫描网页上的二维码即可打开 rpk。 分包加载 vivo 小游戏的分包加载，用法与微信小游戏类似。详情请参考 分包加载。 参考链接 vivo 小游戏开发文档 vivo 小游戏 API 文档 快应用 & vivo 小游戏调试器下载 "},"editor/publish/publish-wechatgame.html":{"url":"editor/publish/publish-wechatgame.html","title":"发布到微信小游戏","keywords":"","body":"发布到微信小游戏 微信小游戏的运行环境是微信小程序环境的扩展，在小程序环境的基础上提供了 WebGL 接口的封装，使得渲染能力和性能有了大幅度提升。不过由于这些接口都是微信团队通过自研的原生实现封装的，所以并不可以等同为浏览器环境。 作为引擎方，为了尽可能简化开发者的工作量，我们为用户完成的主要工作包括： 引擎框架适配微信小游戏 API，纯游戏逻辑层面，用户不需要任何额外的修改 Cocos Creator 3D 编辑器提供了快捷的打包流程，直接发布为微信小游戏，并自动唤起小游戏的开发者工具 自动加载远程资源，缓存资源以及缓存资源版本控制 除此之外，小游戏的游戏提交，审核和发布流程和小程序是没有区别的，都需要遵守微信团队的要求和标准流程，具体信息可以参考文末的链接。 使用 Cocos Creator 3D 发布微信小游戏 在 微信官方文档 下载微信开发者工具 在编辑器菜单栏的 Cocos Creator 3D -> 偏好设置 -> 原生开发环境 中设置微信开发者工具路径 登陆微信公众平台，找到 appid 在 构建发布 面板的 发布平台 中选择 微信小游戏，填入小游戏 appid，然后点击 构建 点击 运行 打开微信开发者工具 注意：微信开发者工具，如果之前在点击上没运行过，会出现：Please ensure that the IDE has been properly installed 的报错。需要手动打开一次微信开发者工具，然后才能在 Cocos Creator 3D 里直接点击 运行 调用。 预览部署 按照这样的流程，项目的 build 目录下就会生成一个微信小游戏的发布包 wechatgame 文件夹(具体构建任务名为准），其中已经包含了微信小游戏环境的配置文件：game.json 和 project.config.json 构建选项介绍 选项名 可选 默认值 说明 分包 可选 true 设是否开启分包功能 appid 必填 'wx6ac3f5090a6b99c5' 微信小游戏 appid，填写后将会写入在 project.config.json 内。 远程服务器地址 选填 空 远程服务器地址，之后将会从该地址获取资源 开放数据域代码目录 选填 空 如果存在开放数据域的话，通过这个字段来指定开放数据域文件夹在构建目录中的相对路径，这样在构建过程中就不会覆盖或修改该目录 设备方向 必填 landscape 设备方向，填写后将会写入在 game.json 内。 小游戏环境的资源管理 在小游戏环境中，资源管理是最特殊的部分，它和浏览器的不同在于下面四点： 小游戏的包内体积不能够超过 4MB，包含所有代码和资源，额外的资源必须通过网络请求下载。 对于从远程服务器下载的文件，小游戏环境没有浏览器的缓存以及过期更新机制。 对于小游戏包内资源，小游戏环境内并不是按需加载的，而是一次性加载所有包内资源，然后再启动页面。 不可以从远程服务器下载脚本文件。 这里引出了两个关键的问题，首页面加载速度和远程资源缓存及版本管理。对于首页面加载速度，我们建议用户只保存脚本文件在小游戏包内，其他资源都从远程服务器下载。而远程资源的下载、缓存和版本管理，其实在 Cocos Creator 3D 中，已经帮用户做好了。下面我就来解释一下这部分的逻辑。 在小游戏环境中，我们提供了一个 wxDownloader 对象，给它设置了 REMOTE_SERVER_ROOT 属性后，引擎下载资源的逻辑就变成： 检查资源是否在小游戏包内 不存在则查询本地缓存资源 如果没有缓存就从远程服务器下载 下载后保存到小游戏应用缓存内供再次访问时使用 缓存空间有大小限制，如果超出限制则会保存失败，此时打印提示信息并使用资源下载时的临时文件作为资源 注意：需要额外注意的是，一旦缓存空间占满之后，所有需要下载的资源都无法进行保存，只能使用下载保存的临时文件，而微信会在小游戏退出之后自动清理所有临时文件，所以下次再次运行小游戏时，这些资源又会再度下载，然后一直循环往复此过程。另外，缓存空间超出限制导致文件保存失败的问题不会在微信开发者工具上出现，因为微信开发者工具没有限制缓存大小，所以测试缓存时需要真实微信环境进行测试。 同时，当开启引擎的 md5Cache 功能后，文件的 url 会随着文件内容的改变而改变，这样当游戏发布新版本后，旧版本的资源在缓存中就自然失效了，只能从服务器请求新的资源，也就达到了版本控制的效果。 具体来说，开发者需要做的是： 构建时，在 构建发布配置 面板中勾选 md5Cache 功能。 设置 远程服务器地址，然后点击 构建。 构建完成后将微信小游戏发布包目录下的 res 文件夹完整的上传到服务器。 删除本地发布包目录下的 res 文件夹。 对于测试阶段来说，可能用户无法部署到正式服务器上，需要用本地服务器来测试，那么请在微信开发者工具中打开 详情 页面，勾选项目设置中的 不检验安全域名、TLS 版本以及 HTTPS 证书 选项。 注意：如果缓存资源超过微信环境限制，用户需要手动清除资源，可以在微信小游戏下使用 wx.downloader.cleanAllAssets() 和 wx.downloader.cleanOldAssets() 接口来清除缓存。前者会清除缓存目录下的所有缓存资源，请慎重使用；而后者会清除缓存目录下目前应用中未使用到的缓存资源。 微信小游戏分包加载 请参考 分包加载。 平台 SDK 接入 除了纯游戏内容以外，其实微信小游戏环境还提供了非常强大的原生 SDK 接口，其中最重要的就是用户、社交、支付等，这些接口都是仅存在于微信小游戏环境中的，等同于其他平台的第三方 SDK 接口。这类 SDK 接口的移植工作在现阶段还是需要开发者自己处理。下面列举一些微信小游戏所提供的强大 SDK 能力： 用户接口：登陆，授权，用户信息等 微信支付 转发以及获得转发信息 文件上传下载 媒体：图片、录音、相机等 其他：位置、设备信息、扫码、NFC、等等 微信小游戏已知问题： 我们对微信小游戏的适配工作还未完全结束，目前仍不支持以下组件： VideoPlayer WebView 用户如果有需要，目前可以先自己直接调用微信的 API 来使用。 参考链接 微信小游戏开发文档 微信公众平台 小游戏 API 文档 微信开发者工具下载 微信开发者工具文档 微信缓存空间溢出测试案例 "},"editor/publish/wechatgame-plugin.html":{"url":"editor/publish/wechatgame-plugin.html","title":"启用微信小游戏引擎插件","keywords":"","body":"微信小游戏引擎插件使用说明 游戏引擎插件是微信 v7.0.7 新增的一项功能。此插件内置了 Cocos Creator 3D 引擎的官方版本，若玩家首次体验的游戏中启用了此插件，则所有同样启用此插件的游戏，都无需再次下载 Cocos Creator 3D 引擎，只需直接使用公共插件库中的相同版本引擎，或者增量更新引擎即可。 例如，当一个玩家玩过了由 Cocos Creator 3D v1.0.2 开发的 A 游戏，里面已启用了此插件。然后他又玩了同样是 v1.0.2 开发的 B 游戏，如果 B 游戏也启用了此插件，那么就无需重新下载 Cocos Creator 3D 引擎。即使 B 使用的是 Cocos Creator 3D v1.0.2，微信也只需要增量更新引擎两个版本的差异部分。这样就可以大幅减少小游戏的下载量，提升小游戏启动速度 0.5 - 2s，获得更好的用户体验。 使用说明 Cocos Creator 3D 自 v1.0.2 起提供该功能，只需在构建发布面板中，勾选 分离引擎 选项，然后正常构建发布即可，无需其它人工操作。（此功能仅在编辑器使用内置引擎并且构建时使用 非调试模式 时生效） Q&A Q：引擎插件功能是否支持自定义引擎？ A：不支持，构建时如果版本不匹配或者启用了自定义引擎，虽然编辑器在出现报错后会继续构建，但是构建生成的包实际上无法正常使用引擎插件。 Q：项目开启了引擎的模块裁剪，要使用引擎插件的话需要还原为完整版引擎吗？ A：无需修改，项目可以按原来的方式继续裁剪引擎。引擎插件提供的是完整版引擎，能兼容所有的裁剪设置，不会影响原有项目的包体。 Q：启用引擎插件后，是否仍然会把引擎代码算入首包包体中？ A：根据微信的规则，目前仍然会计算在内。 Q：开启引擎插件后，是否可以在编辑器 模块设置 中移除所有模块，减小包体？ A：不可以，因为微信从 7.0.7 开始才支持引擎插件，如随意裁剪引擎可能导致游戏无法在低版本微信上运行。 Q：启用引擎插件后，在微信开发工具中提示 “代码包解包失败” 或者 “..., 登录用户不是该小程序的开发者”，但真机预览正常？ A：构建面板中默认的 appid 为通用测试 id。根据微信的规则，如需测试引擎分离功能，需要开发者在构建面板中填入自己开通的 appid。 Q：启用引擎插件后，在微信开发工具中提示 “插件未授权使用 添加插件”？ A：点击提示中的 添加插件，选择添加 CocosCreator3D 插件后重新编译即可。若添加插件时出现“可添加的插件信息为空”的提示，可尝试在微信开发者工具中选择 清缓存 -> 全部清除 后重试。 参考链接 微信小游戏引擎插件官方说明 "},"editor/publish/publish-xiaomi-quick-game.html":{"url":"editor/publish/publish-xiaomi-quick-game.html","title":"发布到小米快游戏","keywords":"","body":"发布到小米快游戏 Cocos Creator 3D 从 v1.0.3 版本开始正式支持将游戏发布到小米快游戏。 环境配置 桌面端全局安装 Node.js 8.1.4 或以上版本。 确保 Node.js 所带的 npm 版本最低是 5.2.0。升级 npm 命令如下： # 查看 npm 版本 npm -v # 若 npm 版本在 5.2.0 以下，可使用以下升级命令升级 npm npm install npm@latest -g 下载 小米快游戏调试器和小米快游戏运行环境，并安装到小米手机上（MIUI 8.5.0 或以上版本）。 发布流程 一、使用 Cocos Creator 3D 打开需要发布的项目工程，在 构建发布 面板的 发布平台 中选择 小米快游戏。 相关参数配置具体的填写规则如下： 应用包名 应用包名的格式是：com.yourcompany.projectname。该项为必填项，根据用户的需求进行填写。 注意： 从平台版本号 1062 开始，小米快游戏需要使用正式申请的应用包名，否则在调试时会出现“数据加载异常，请点击重试”的报错。应用包名申请可参考 小米快游戏相关参考链接。 桌面图标 该项为必填项。构建时 桌面图标 将会构建到小米快游戏的工程中。点击输入框右边的 ... 按钮即可选择图片。桌面图标建议使用 png 图片。 应用版本名称 该项为必填项。应用版本名称 是真实的版本，如：1.0.0 应用版本号 该项为必填项。应用版本号 与 应用版本名称 不同，应用版本号 主要用于区别版本更新。每次提交审核时应用版本号都要比上次提交审核的值至少 +1，一定不能等于或者小于上次提交审核的值，建议每次提交审核时应用版本号递归 +1。注意：应用版本号 必须为正整数。 支持的最小平台版本号 该项为必填项。根据小米快游戏的要求目前这个值必须大于或等于 1050。 小包模式服务器路径 该项为选填项。快游戏的包内体积包含代码和资源不能超过 10M，资源可以通过网络请求加载。小包模式 就是帮助用户将脚本文件保留在快游戏包内，其他资源则上传到远程服务器，根据需要从远程服务器下载。而远程资源的下载、缓存和版本管理，Creator 3D 已经帮用户做好了。用户需要做的是以下两个步骤： 1、构建之前，填写 小包模式服务器路径。然后点击 构建。 2、构建完成后，点击 发布路径 后面的 打开 按钮，将发布路径下的 xiaomi/res 目录上传到小包模式服务器。例如：默认发布路径是 build，则需要上传 build/xiaomi/res 目录。 此时，构建出来的 rpk 将不再包含 res 目录，res 目录里的资源将通过网络请求从填写的 小包模式服务器地址 上下载。 分包 v1.0.4 起添加该选项，默认值为 true，用于控制分包功能的开启。 密钥库 勾选 密钥库 时，表示默认使用的是 Creator 3D 自带的证书构建 rpk 包，仅用于 调试 时使用。注意：若 rpk 包要用于提交审核，则构建时不要勾选该项。 如果不勾选 密钥库，则需要配置签名文件 certificate.pem 路径 和 private.pem 路径，此时构建出的是可以 直接发布 的 rpk 包。用户可通过输入框右边的 ... 按钮来配置两个签名文件。注意：这两个签名文件建议不要放在发布包 build/xiaomi 目录下，否则每次构建时都会清空该目录，导致文件丢失。 有以下两种方式可以生成签名文件： 通过 构建发布 面板 certificate.pem 路径 后的 新建 按钮生成。点击 新建 按钮后，在弹出的 certificate 面板中填写相关信息，信息填写完成后点击保存，在控制台会输出日志 Generate certificate is complete!，表示生成签名文件完成。 通过命令行生成 release 签名 用户需要通过 openssl 命令等工具生成签名文件 private.pem、certificate.pem。 # 通过 openssl 命令工具生成签名文件 openssl req -newkey rsa:2048 -nodes -keyout private.pem -x509 -days 3650 -out certificate.pem 注意：openssl 工具在 linux 或 Mac 环境下可在终端直接打开。而在 Windows 环境下则需要安装 openssl 工具并且配置系统环境变量，配置完成后需重启 Creator 3D。 二、构建发布 构建发布 面板的相关参数设置完成后，点击 构建。构建完成后点击 发布路径 后面的 打开 按钮来打开构建发布包，可以看到在默认发布路径 build 目录下生成了 xiaomi-mini-game 目录，该目录就是导出的小米快游戏工程目录和 rpk，rpk 包在 /build/xiaomi/dist 目录下。 三、将打包出来的 rpk 运行到手机上。 启动游戏，有以下两种方式： 方法一： 在 构建发布 面板点击右下角的 运行 按钮，等待二维码界面生成。 然后在小米手机上打开之前已经安装完成的 快应用调试器，点击 扫码安装 按钮，直接扫描二维码即可打开 rpk。 方法二： 首先在小米手机上打开 设置-> 更多设置-> 开发者选项，开启开发者选项以及 USB 调试。 使用 USB 数据线将桌面端电脑与手机相连。 将构建生成的快游戏 rpk 文件（位于发布包 build/xiaomi/dist 目录下）拷贝到小米手机 sdcard 目录中。 在小米手机上打开之前已经安装完成的 快应用调试器，点击 本地安装，然后从手机 sdcard 目录中找到 rpk 文件，选择打开即可。 调试 调试必须基于真机进行调试，并且必须严格按照先运行游戏再启动调试功能的先后顺序。启动游戏后，让小米手机处于打开游戏运行的界面。然后使用 USB 数据线将桌面端电脑与小米手机相连，并且小米手机需要开启开发者选项以及 USB 调试。 目前可以通过命令行来启动调试： 指定到编辑器安装目录 resources/tools/xiaomi-pack-tools 目录下，执行命令：npm run debug，就会在 Chrome 浏览器中 自动 启动调试界面。 如果想要 手动 打开调试界面，那么执行命令：npm run debug -- --print-only，然后将运行后生成的 URL 地址拷贝到 Chrome 浏览器中打开即可启动调试界⾯。 # 指定到编辑器安装目录下的 resources/tools/xiaomi-pack-tools 目录下 cd ${CocosCreator3D}/tools/xiaomi-pack-tools # 自动在 Chrome 上打开调试界面 npm run debug # 手动在 Chrome 上打开调试页面 npm run debug -- --print-only 分包 rpk 分包 rpk 是根据用户的需求选择是否使用。分包加载，即把游戏内容按一定规则拆分在几个包里，在首次启动的时候只下载必要的包，这个必要的包称为 主包，开发者可以在主包内触发下载其他子包，这样可以有效降低首次启动的消耗时间。若要使用该功能需要在对应文件属性上勾选分包（参考：分包加载），设置完成后在构建时确认分包选项开启后点击构建就会自动分包。注意：单个分包/主包大小不能超过 5M，所有包体总和不能超过 10M。 构建完成后，会生成 .rpk，生成在 build/xiaomi-quick-game/dist 目录下。 相关参考链接 小米快游戏相关参考链接 "},"concepts/scene/":{"url":"concepts/scene/","title":"场景及环境","keywords":"","body":"场景 场景是游戏中的环境因素的抽象集合，是创建游戏环境的局部单位，我们可以理解为游戏开发设计人员通过在编辑器中制作一个场景，来表现游戏中的一部分世界内容。 本章节包括以下内容： 坐标系 场景结构 节点 天空盒 继续前往 坐标系 说明文档。 "},"concepts/scene/coord.html":{"url":"concepts/scene/coord.html","title":"坐标系","keywords":"","body":"坐标系 世界坐标系 Cocos Creator 3D 的世界坐标系，采用笛卡尔右手坐标系，原点在左下角，x 向右，y 向上，z 向外，同时我们使用-z轴为正前方朝向。 屏幕坐标系 Cocos Creator 3D 的屏幕坐标系原点为屏幕左下角，x 向右，y 向上。 继续前往 场景结构 说明文档。 "},"concepts/scene/scene.html":{"url":"concepts/scene/scene.html","title":"场景结构","keywords":"","body":"场景结构 Cocos Creator 3D 在 Creator 的 ECS 实体组件系统框架上增加了3D场景结构，3D 场景通过 RenderScene 表示，ECS 结构中相应的 Component 引用了 RenderScene 中维护的模型（Model）、相机（Camera）、灯光（Light）等元素，它们通过 Node 关联在一起，RenderScene 中更新元素的各种 Transform，也是通过 Node 来操作。 注意区别 ECS 结构中的 Scene 与 3D 场景结构中的 RenderScene，ECS 中的 Scene 作为 Node 的逻辑组织结构，而 RenderScene 是作为场景渲染元素的组织结构，ECS Scene 中包含了 RenderScene 成员变量，两者一一对应。 ECS 与 3D 场景结构的关系，如下图所示： 整个 3D 场景结构是被封装在 Component 之下的，通过 Node 建立起组织关系，这样对于 ECS 的上层用户来说，是完全透明的，用户层面对于 3D 场景结构对象是无感知的。 继续前往 节点 说明文档。 "},"concepts/scene/node.html":{"url":"concepts/scene/node.html","title":"节点","keywords":"","body":"节点 节点是场景的基础组成单位。节点之间是树状的组织关系，每个节点可以有多个子节点，同时对应一个父节点。 节点具有以下特性： 节点包含一组基础信息（位移、旋转、缩放），节点之间通过一组相对变换关系组织在一起 节点间的更新顺序是逐级更新的，子节点的更新依赖于父节点，子节点更随父节点变换 节点上可以添加组件，将多个组件与节点关联在一起 简而言之，节点是我们组织工程结构的基本手段，我们可以通过节点将多个元素归类，并且可以对节点进行层级操作，或对一组节点进行批量操作，如：变换、删除，或是按需要隐藏和显示他们，等。 继续前往 天空盒 说明文档。 "},"concepts/scene/skybox.html":{"url":"concepts/scene/skybox.html","title":"天空盒","keywords":"","body":"天空盒 游戏中的天空盒是一个包裹整个场景的立方体，天空盒可以很好的渲染整个环境的气氛，并表达整个场景的环境，在基于 PBR 的工作流中天空盒也是非常重要的部分。 Cocos Creator 3D 中的天空盒，如下图所示： 开启天空盒 在 Cocos Creator 3D 中开启天空盒的效果，只需要以下一步： Skybox 的面板处于 Scene 节点的属性面板上，将 Enabled 属性勾选上便开启了天空盒 注： Skybox 的 Envmap 属性为空时，使用和显示的将是像素贴图。 修改天空盒的环境贴图 在 Cocos Creator 3D 中修改天空盒的环境贴图，是通过设置 TextureCube 类型的资源。 而从资源导入到设置为 TextureCube ，并且设置到 Skybox 中，可以分为以下几步： 导入图片资源。（注：此处以全景图为示例，下面有制作 CubeMap 的介绍方法。） 选中导入的全景图，在右侧的属性面板上，将其设置为 TextureCube 类型，如下图所示。 将以上 TextureCube 资源拖入到 Skybox 面板上的 Envmap 属性上。 完成以上步骤后，应该就可以在编辑器的场景中看到最新替换的环境贴图。 确认 SkyIllum 参数 如果完成上一步之后，场景编辑器里并没有正确显示出天空盒的贴图，那么很有可能是 SkyIllum 参数设太低了。请检查一下 Scene 节点的属性面板里 ambient -> SkyIllum 参数。一般而言,SkyIllum 修改 Camera 的 Clear Flag 在完成以上步骤之后，虽然场景编辑器里面已经可以正确显示天空盒，但运行起来的时候仍然看不到。这时候需要修改 Camera 的 Clear Flag 为 SKYBOX，如下图 这样就完成了 Cocos Creator 3D 中设置天空盒的所有步骤。 Skybox 面板 以下介绍了面板的所有属性： 属性 解释 enabled 是否开启 Skybox envmap 环境贴图，类型为 TextureCube isRGBE 环境贴图的像素格式是否为 RGBE useIBL 是否使用环境光照 CubeMap CubeMap （立方体贴图）是天空盒的一种环境贴图资源，它由立方体上六个面的贴图资源组合而成，它可以当作 TextureCube 资源来使用。 制作与应用 CubeMap 在 Cocos Creator 3D 中制作一张 CubeMap 并且设置到 Skybox 中，只需要以下步骤： 新建 CubeMap 资源，并且导入预先准备好的六张贴图资源，并将这些贴图资源设置为 Texture 类型。 将导入的贴图资源拖入到相应的输入框中，完成后点击绿色勾选按钮，这样就完成了一张 CubeMap。 最后，将完成的 CubeMap 资源拖入到 Skybox 的 Envmap 属性框中，这样就完成了 CubeMap 的应用。 注： CubeMap 中未设置贴图的面将用默认的资源进行填充。 "},"concepts/scene/light.html":{"url":"concepts/scene/light.html","title":"光照","keywords":"","body":"光源 光源在游戏中表示具备发光能力的物体，并且能够照亮周围的环境 基于物理的光照（Physically Based Lighting） Cocos Creator 3D 中采用光学度量单位来描述光源参数。基于光学度量单位，我们可以将光源的相关参数全部转化为真实世界中的物理值。这样，设计人员可根据相关灯光的工业参数以及真实环境的实际物理参数来调节光照强度、颜色、范围等信息，使整体光照效果更加符合真实的自然环境。 详细介绍可参考下面链接： 基于物理的光照（Physically Based Lighting） Cocos Creator 3D 中支持三种类型的光源： 主方向光（Main Directional Light） 球面光（Sphere Light） 聚光灯（Spot Light） 继续前往 基于物理的光照 说明文档。 "},"concepts/scene/light/pbr-lighting.html":{"url":"concepts/scene/light/pbr-lighting.html","title":"基于物理的光照","keywords":"","body":"基于物理的光照（Physically Based Lighting） 真实世界中的光源 基于物理的光照符合真实世界中的光源描述，在真实环境中，我们所见到的光源产品都具有自身的工业参数，我们先来看一个宜家的灯泡💡 从产品包装上，我们可以了解到这个灯泡的几个重要工业参数： 功率 色温 尺寸 这三个重要参数影响真实世界中的光源表现效果，下面我们来重点讲解一下这三个参数的物理意义。 发光功率 发光功率就是我们通常所说的光源强度。Cocos Creator 3D 中使用 光学度量单位（Photometric Unit） 来计量光源强度： 发光功率（Luminous Power） ：单位 流明（lm） 描述光源从各个方向发出的光的总量。改变光源大小不会影响场景照明效果 亮度（Luminance） ：单位 坎德拉每平方米（cd/m2） 描述光线从光源表面上的点入射到接收表面上点，所具有的光源强度。改变光源大小会影响场景照明效果 照度（Illuminance） ：单位 勒克斯（lx） 描述光线从光源入射到接收表面处的光的总量。该值受光的传播距离影响。 在真实世界中，由于描述光源的重要物理参数不一样，我们通常用 发光功率（Luminous Power） 和 亮度（Luminance） 来描述生活中常见的带有照明面积的光源，用 照度（Illuminance） 来描述太阳光。 色温（ColorTemperature） 色温：是指绝对黑体从绝对零度(-273℃)开始加温后所呈现的颜色。 色温是影响光源颜色的重要属性，是个可选属性，当启用色温时，色温也参与了光源颜色的组成部分。 真实世界环境中，一天不同时段的环境色温也会动态发生变化： 可参考下表所示： 光源大小 真实世界中的光源都具有真实的物理尺寸，同时，光源大小也影响了光源强度。 继续前往 主方向光 说明文档。 "},"concepts/scene/light/dir-light.html":{"url":"concepts/scene/light/dir-light.html","title":"主方向光","keywords":"","body":"主方向光（Main Directional Light） Cocos Creator 3D 中只有一个主方向光，主方向光可以理解为场景中的主导性光源，通常是室外场景的太阳光。主方向光还会影响阴影的投影。 参数名称 说明 Color 光源颜色 UseColorTemperature 是否启用色温 ColorTemperature 色温 Illumiance 照度，单位勒克斯（lx） 继续前往 球面光 说明文档。 "},"concepts/scene/light/sphere-light.html":{"url":"concepts/scene/light/sphere-light.html","title":"球面光","keywords":"","body":"球面光（Sphere Light） Cocos Creator 3D 中使用球面光替代 点光源（Point Light），因为真实世界中的物理光源都具有光源大小属性。 参数名称 说明 Color 光源颜色 UseColorTemperature 是否启用色温 ColorTemperature 色温 Size 光源大小 Range 光照影响范围 Term 选用的光照强度单位术语球面光支持两种单位制系统：发光功率（LUMINOUS_POWER） 和 亮度（LUMINANCE） LuminousPower 发光功率，单位流明（lm）当 Term 指定为 LUMINOUS_POWER 时，选用流明来表示光照强度 Luminance 亮度，单位坎德拉每平方米（cd/m2）当 Term 指定为 LUMININANCE 时，选用亮度来表示光照强度 继续前往 聚光灯 说明文档。 "},"concepts/scene/light/spot-light.html":{"url":"concepts/scene/light/spot-light.html","title":"聚光灯","keywords":"","body":"聚光灯（Spot Light） 聚光灯 用于表现光束的聚焦，可以通过调节聚光角度可以控制光斑的大小。 参数名称 说明 Color 光源颜色 UseColorTemperature 是否启用色温 ColorTemperature 色温 Size 光源大小 Range 光照影响范围 SpotAngle 聚光角度 Term 选用的光照强度单位术语聚光灯支持两种单位制系统：发光功率（LUMINOUS_POWER） 和 亮度（LUMINANCE） LuminousPower 发光功率，单位流明（lm）。当 Term 指定为 LUMINOUS_POWER 时，选用流明来表示光照强度 Luminance 亮度，单位坎德拉每平方米（cd/m2）。当 Term 指定为 LUMININANCE 时，选用亮度来表示光照强度 继续前往 阴影 说明文档。 "},"concepts/scene/shadow.html":{"url":"concepts/scene/shadow.html","title":"阴影","keywords":"","body":"阴影 在 3D 世界中，光与影一直都是极其重要的组成部分，它们能够丰富整个环境，质量好的阴影可以达到以假乱真的效果，并且使得整个世界具有立体感。 以下为 Cocos Creator 3D 的阴影示例： 开启阴影 Cococs Creator 3D 目前支持高性价比的 Planar Shadow ，后面会提供更多 Shadow 类型，请留意更新公告。 在 Cococs Creator 3D 中开启 Planar Shadow 只需要两步： 在层级管理器上选择 Scene 节点，可以看到以下面板，将 planarShadows 的 Enabled 属性勾选上。 将需要显示阴影的模型组件中的 ShadowCastingMode 设置为 ON 。 注：Planar Shadow 只会投射在阴影面上，调节方向光角度可以调节阴影的投射。 PlanarShadows 面板 以下介绍了面板的所有属性： 属性 解释 enabled 是否开启 planar shadows normal 垂直与阴影平面的法线 distance 阴影平面在 normal 法线的方向上与坐标原点的距离 shadowColor 产生的阴影的颜色值 继续前往 环境光 说明文档。 "},"concepts/scene/ambient.html":{"url":"concepts/scene/ambient.html","title":"环境光","keywords":"","body":"环境光 在生活中，错综复杂的光线与凹凸不平的物体表面相互反射，使得整个环境都被照亮，仿佛整个场景被一层环境光所笼罩。通过调节环境光，是调节环境整体光照最为直接的方式，也是一种有效表达环境气氛的方式。 Cocos Creator 3D 中的环境光，如下图所示： 环境光面板 以下介绍了面板的所有属性： 属性 解释 groundAlbedo 地面反射光 skyColor 天空颜色 skyIllum 天空亮度 返回 光照 说明文档。 "},"material-system/overview.html":{"url":"material-system/overview.html","title":"材质","keywords":"","body":"材质系统总览 材质系统控制着每个模型最终的着色流程与顺序, 在引擎内相关类间结构如下: EffectAsset EffectAsset 是由用户书写的着色流程描述文件, 详细结构及书写指南可以参考这里. 这里主要介绍引擎读取 EffectAsset 资源的流程: 在编辑器导入 EffectAsset 时, 会对用户书写的内容做一次预处理, 替换 GL 字符串为管线内常量, 提取 shader 信息, 转换 shader 版本等. 还以 builtin-unlit.effect 为例, 编译输出的 EffectAsset 结构大致是这样的: { \"name\": \"builtin-unlit\", \"techniques\": [ {\"name\":\"opaque\", \"passes\":[{\"program\":\"builtin-unlit|unlit-vs:vert|unlit-fs:frag\", \"properties\":{\"mainTexture\":{\"value\":\"grey\", \"type\":28}, \"tilingOffset\":{\"value\":[1, 1, 0, 0], \"type\":16}, \"mainColor\":{\"value\":[1, 1, 1, 1], \"editor\":{\"type\":\"color\"}, \"type\":16}, \"colorScale\":{\"value\":[1, 1, 1], \"type\":15, \"handleInfo\":[\"colorScaleAndCutoff\", 0, 15]}, \"alphaThreshold\":{\"value\":[0.5], \"editor\":{\"parent\":\"USE_ALPHA_TEST\"}, \"type\":13, \"handleInfo\":[\"colorScaleAndCutoff\", 3, 13]}, \"color\":{\"editor\":{\"visible\":false}, \"type\":16, \"handleInfo\":[\"mainColor\", 0, 16]}, \"colorScaleAndCutoff\":{\"type\":16, \"editor\":{\"visible\":false, \"deprecated\":true}, \"value\":[1, 1, 1, 0.5]}}, \"migrations\":{\"properties\":{\"mainColor\":{\"formerlySerializedAs\":\"color\"}}}}]}, ], \"shaders\": [ { \"name\": \"builtin-unlit|unlit-vs:vert|unlit-fs:frag\", \"hash\": 2093221684, \"glsl4\": { \"vert\": \"// glsl 460 vert source, omitted here for brevity\", \"frag\": \"// glsl 460 frag source, omitted here for brevity\", }, \"glsl3\": { \"vert\": \"// glsl 300 es vert source, omitted here for brevity\", \"frag\": \"// glsl 300 es frag source, omitted here for brevity\", }, \"glsl1\": { \"vert\": \"// glsl 100 vert source, omitted here for brevity\", \"frag\": \"// glsl 100 frag source, omitted here for brevity\", }, \"attributes\": [ {\"tags\":[\"USE_BATCHING\"], \"name\":\"a_dyn_batch_id\", \"type\":13, \"count\":1, \"defines\":[\"USE_BATCHING\"], \"location\":1}, {\"name\":\"a_position\", \"type\":15, \"count\":1, \"defines\":[], \"location\":0}, {\"name\":\"a_weights\", \"type\":16, \"count\":1, \"defines\":[\"USE_SKINNING\"], \"location\":2}, {\"name\":\"a_joints\", \"type\":16, \"count\":1, \"defines\":[\"USE_SKINNING\"], \"location\":3}, {\"tags\":[\"USE_VERTEX_COLOR\"], \"name\":\"a_color\", \"type\":16, \"count\":1, \"defines\":[\"USE_VERTEX_COLOR\"], \"location\":4}, {\"tags\":[\"USE_TEXTURE\"], \"name\":\"a_texCoord\", \"type\":14, \"count\":1, \"defines\":[\"USE_TEXTURE\"], \"location\":5} ], \"varyings\": [ {\"name\":\"v_color\", \"type\":16, \"count\":1, \"defines\":[\"USE_VERTEX_COLOR\"], \"location\":0}, {\"name\":\"v_uv\", \"type\":14, \"count\":1, \"defines\":[\"USE_TEXTURE\"], \"location\":1} ], \"builtins\": {\"globals\":{\"blocks\":[{\"name\":\"CCGlobal\", \"defines\":[]}], \"samplers\":[]}, \"locals\":{\"blocks\":[{\"name\":\"CCLocalBatched\", \"defines\":[\"USE_BATCHING\"]}, {\"name\":\"CCLocal\", \"defines\":[]}, {\"name\":\"CCSkinningTexture\", \"defines\":[\"USE_SKINNING\", \"ANIMATION_BAKED\"]}, {\"name\":\"CCSkinningAnimation\", \"defines\":[\"USE_SKINNING\", \"ANIMATION_BAKED\"]}, {\"name\":\"CCSkinningFlexible\", \"defines\":[\"USE_SKINNING\"]}], \"samplers\":[{\"name\":\"cc_jointsTexture\", \"defines\":[\"USE_SKINNING\", \"ANIMATION_BAKED\"]}]}}, \"defines\": [ {\"name\":\"USE_BATCHING\", \"type\":\"boolean\", \"defines\":[]}, {\"name\":\"USE_SKINNING\", \"type\":\"boolean\", \"defines\":[]}, {\"name\":\"ANIMATION_BAKED\", \"type\":\"boolean\", \"defines\":[\"USE_SKINNING\"]}, {\"name\":\"CC_SUPPORT_FLOAT_TEXTURE\", \"type\":\"boolean\", \"defines\":[\"USE_SKINNING\", \"ANIMATION_BAKED\"]}, {\"name\":\"USE_VERTEX_COLOR\", \"type\":\"boolean\", \"defines\":[]}, {\"name\":\"USE_TEXTURE\", \"type\":\"boolean\", \"defines\":[]}, {\"name\":\"FLIP_UV\", \"type\":\"boolean\", \"defines\":[\"USE_TEXTURE\"]}, {\"name\":\"CC_USE_HDR\", \"type\":\"boolean\", \"defines\":[]}, {\"name\":\"USE_ALPHA_TEST\", \"type\":\"boolean\", \"defines\":[]}, {\"name\":\"ALPHA_TEST_CHANNEL\", \"type\":\"string\", \"defines\":[\"USE_ALPHA_TEST\"], \"options\":[\"a\", \"r\", \"g\", \"b\"]} ], \"blocks\": [ {\"name\": \"TexCoords\", \"defines\": [\"USE_TEXTURE\"], \"binding\": 0, \"members\": [ {\"name\":\"tilingOffset\", \"type\":16, \"count\":1} ]}, {\"name\": \"Constant\", \"defines\": [], \"binding\": 1, \"members\": [ {\"name\":\"mainColor\", \"type\":16, \"count\":1}, {\"name\":\"colorScaleAndCutoff\", \"type\":16, \"count\":1} ]} ], \"samplers\": [ {\"name\":\"mainTexture\", \"type\":28, \"count\":1, \"defines\":[\"USE_TEXTURE\"], \"binding\":30} ] } ] } 这里的信息量不小，但大多数时候这些细节都不需要普通开发者关心，重要的是： 对任意目标平台，所有着色必要的基础信息已经全部都在这里提前准备好，以保证跨平台和最高的运行效率， 同时在最后构建时会针对当前平台剔除所有冗余的信息，以保证最好的空间利用率。 Material Material 资源可以看成是 EffectAsset 在场景中的资源实例, 它本身的可配置参数有: effectAsset 或 effectName: effect 资源引用, 使用哪个 EffectAsset 所描述的流程进行渲染? (必备) technique: 使用 EffectAsset 中的第几个 technique? (默认为 0 号) defines: 宏定义列表, 需要开启哪些宏定义? (默认全部关闭) states: 管线状态重载列表, 对渲染管线状态 (深度模板透明混合等) 有哪些重载? (默认与 effect 声明一致) const mat = new Material(); mat.initialize({ effectName: 'pipeline/skybox', defines: { USE_RGBE_CUBEMAP: true } }); 有了这些信息后, Material 就可以被正确初始化(标志是生成渲染使用的 Pass 对象数组), 用于具体模型的渲染了. 根据所使用 EffectAsset 的信息, 可以进一步设置每个 Pass 的 uniform 参数等. mat.setProperty('cubeMap', someCubeMap); console.log(mat.getProperty('cubeMap') === someCubeMap); // true 这些属性都是在材质资源对象本身内部生效, 还并不涉及场景. Material 通过挂载到 RenderableComponent 上与场景连接, 所有需要设定材质的 Component (ModelComponent, SkinningModelComponent等) 都继承自它. const comp = someNode.getComponent(ModelComponent); comp.material = mat; comp.setMaterial(mat, 0); // 与上一行作用相同 根据子模型的数量, RenderableComponent 也可以引用多个 Material 资源: comp.setMaterial(mat, 1); // 赋给第二个 submodel 同一个 Material 也可挂载到任意多个 RenderableComponent 上, 一般在编辑器中通过拖拽的方式即可自动赋值. 而当场景中的某个模型的 Material 需要特化的设置, 会在从 RenderableComponent 获取 Material 时自动做拷贝实例化, 创建对应的 MaterialInstance，从而实现独立的定制. const comp2 = someNode2.getComponent(ModelComponent); const mat2 = comp2.material; // 拷贝实例化, mat2 是一个 MaterialInstance，接下来对 `mat2` 的修改只会影响 `comp2` 的模型 Material 与 MaterialInstance 的最大区别在于，MaterialInstance 从开始就永久地挂载在唯一的 RenderableComponent 上，只会对这个模型生效，而 Material 则无此限制。 对于一个已初始化的材质, 如果希望修改最初的基本信息, 可以直接再次调用 initialize 函数, 重新创建渲染资源. mat.initialize({ effectName: 'builtin-standard', technique: 1 }); 特别地, 如果只是希望修改 defines 或 states, 我们提供更高效的直接设置接口, 只需提供相对当前值的重载即可: mat2.recompileShaders({ USE_EMISSIVE: true }); mat2.overridePipelineStates({ rasterizerState: { cullMode: GFXCullMode.NONE } }); 但注意，这些接口只能对 MaterialInstance 实例调用，而不能对 Material 资源调用。 每帧动态更新 uniform 值是非常常见的需求, 在类似这种需要更高效接口的情景下, 可以手动调用对应 pass 的接口: // 初始化时保存以下变量 const pass = mat2.passes[0]; const hColor = pass.getHandle('albedo'); const color = new Color('#dadada'); // 每帧更新时： color.a = Math.sin(director.getTotalFrames() * 0.01) * 127 + 127; pass.setUniform(hColor, color); Builtins 编辑器内置了几种常见类型的材质，无光照的 unlit、基于物理光照的 standard、skybox、粒子、sprite 等； 这里列一下最常用的 standard 各项参数的意义和用法： Property Info tilingOffset 模型 UV 的平铺和偏移量，xy 对应平铺，zw 对应偏移 albedo/mainColor 漫反射颜色，指定模型的主要基色 albedoMap/mainTexture 漫反射贴图，如果有指定，这项会和漫反射颜色相乘 albedoScale 模型的漫反射强度，用于控制漫反射颜色对于最终颜色的影响权重 alphaThreshold 启用 alpha test 后的测试阈值，输出 alpha 值低于此值的像素会被 discard 掉 normalMap 法线贴图，用于增加表面细节 normalStrenth 法线贴图强度，控制凹凸质感的强弱 pbrMap PBR 材质参数贴图：环境遮挡、粗糙度和金属度采样结果会和常数项相乘每种属性具体的来源通道由 XX_CHANNEL 宏定义决定 metallicRoughnessMap 独立的粗糙度和金属度贴图采样结果会和常数项相乘每种属性具体的来源通道由 XX_CHANNEL 宏定义决定 occlusionMap 独立的环境遮挡贴图采样结果会和常数项相乘每种属性具体的来源通道由 XX_CHANNEL 宏定义决定 occlusion 环境遮挡常数 roughness 粗糙度常数 metallic 金属度常数 emissive 自发光颜色独立于光照计算的，模型本身直接发散出的颜色 emissiveMap 自发光贴图如果有指定，这项会和自发光颜色相乘，因此需要把自发光颜色（默认是黑色）调高才会有效果 emissiveScale 自发光强度用于控制自发光颜色对于最终颜色的影响权重 相对应的，还有控制这些参数的宏定义： Macro Info USE_BATCHING 是否启用动态合批？ USE_SKINNING 是否启用顶点蒙皮？ 对蒙皮模型必须启用 ANIMATION_BAKED 是否使用预烘焙的蒙皮动画？ ROUGHNESS_CHANNEL 指定粗糙度的数据来源通道，默认为 r 通道 METALLIC_CHANNEL 指定金属度的数据来源通道，默认为 g 通道 AO_CHANNEL 指定 AO 的数据来源通道，默认为 b 通道 HAS_SECOND_UV 是否存在第二套 UV？ ALBEDO_UV 指定采样漫反射贴图使用的 uv，默认为第一套 EMISSIVE_UV 指定采样自发光贴图使用的 uv，默认为第一套 ALPHA_TEST_CHANNEL 指定透明测试的测试通道 USE_VERTEX_COLOR 如果启用，顶点色会与漫反射项相乘 USE_ALPHA_TEST 是否开启透明测试（镂空效果）？ USE_ALBEDO_MAP 是否使用漫反射贴图？ USE_NORMAL_MAP 是否使用法线贴图？ USE_PBR_MAP 是否使用 PBR 材质参数贴图？ USE_EMISSIVE_MAP 是否使用自发光贴图？ "},"material-system/yaml-101.html":{"url":"material-system/yaml-101.html","title":"YAML 101","keywords":"","body":"YAML 101 我们使用的是符合 YAML 1.2 标准的解析器，这意味着首先它是与 JSON 完全兼容的，直接书写 JSON 完全不会有问题： \"techniques\": [{ \"passes\": [{ \"vert\": \"skybox-vs\", \"frag\": \"skybox-fs\", \"rasterizerState\": { \"cullMode\": \"none\" } # ... }] }] 当然这也意味着繁琐的语法，所以 YAML 提供了一些更简洁的数据表示方式： （如有疑问可复制代码示例到任何 在线 YAML JSON 转换器 观察生成的数据） 所有的引号和逗号都可以省略（但注意，冒号后的空格不可省略） key1: 1 key2: unquoted string 行首的空格缩进数量代表数据的层级1 object1: key1: false object2: key2: 3.14 key3: 0xdeadbeef nestedObject: key4: 'quoted string' 以 连字符+空格 开头，表示数组元素 - 42 - \"double-quoted string\" - arrayElement3: key1: punctuations? sure. key2: you can even have {}s as long as they are not the first character key3: { nested1: 'but no unquoted string allowed inside brackets', nested2: 'also notice the comma is back too' } 综合这几点，上面的 effect 内容就可以很简洁地写成这样： techniques: - passes: - vert: skybox-vs frag: skybox-fs rasterizerState: cullMode: none # ... 另一个对我们的情况非常有用的 YAML 特性是数据间的引用与继承，先来看引用： object1: &o1 key1: value1 object2: key2: value2 key3: *o1 这个数据解析出来是这样的： { \"object1\": { \"key1\": \"value1\" }, \"object2\": { \"key2\": \"value2\", \"key3\": { \"key1\": \"value1\" } } } 再来看继承： object1: &o1 key1: value1 key2: value2 object2: 这个数据解析出来是这样的： { \"object1\": { \"key1\": \"value1\", \"key2\": \"value2\" }, \"object2\": { \"key1\": \"value1\", \"key2\": \"value2\", \"key3\": \"value3\" } } 对应到我们的 effect 中，比如多个 pass 拥有相同的 property 内容，或很多其他情景下，都可以很方便地复用数据： techniques: - passes: - # pass 1 specifications... properties: &props # declare once... p1: { value: [ 1, 1, 1, 1 ] } p2: { sampler: { mipFilter: linear } } p3: { inspector: { type: color } } - # pass 2 specifications... properties: *props # reference anywhere 最后，在实际 effect 文件中任何流程声明都需要包在 CCEffect 语法块内： CCEffect %{ # YAML starts here }% 更多参考资料 https://en.wikipedia.org/wiki/YAML https://yaml.org/spec/1.2/spec.html [1] 标准 YAML 并不支持制表符，但在解析 effect 数据时，我们会先尝试把其中所有的制表符替换为 2 个空格，以避免偶然插入制表符带来的琐碎的麻烦。但整体上，请一定尽量避免插入制表符来确保编译无误。↩ "},"material-system/effect-syntax.html":{"url":"material-system/effect-syntax.html","title":"Effect Syntax","keywords":"","body":"Effect 语法 如果希望在引擎中实现自定义的着色效果, 需要书写自定义 Effect. Cocos Effect 是一种基于 YAML 和 GLSL 的单源码嵌入式领域特定语言 (single-source embedded domain-specific language)， YAML 部分声明流程控制清单, GLSL 部分声明实际的 shader 片段，这两部分内容上相互补充, 共同构成了一个完整的渲染流程描述。 我们推荐使用 VSCode，搜索安装 Cocos Effect 插件，来方便地编辑任何 effect 文件。 注意：这篇文档的目标受众是项目组中的 TA 或图形向的程序，如果你是有具体定制 shader 需求的美术，请联系项目 TA 或程序，把这篇文档丢给他~！ 语法框架 以 builtin-unlit.effect 为例, 这个 Effect 文件的内容大致是这样: 关于 effect 名称 在运行时可以通过 effect name 获取或使用 effect 资源： const effect = cc.EffectAsset.get('builtin-unlit'); // this is the EffectAsset resource instance const mat = new cc.Material(); mat.initialize({ effectName: 'builtin-standard' }); // now `mat` is a valid standard material 而 effect name 是基于 effect 文件名和所在路径两个信息自动生成的，路径部分固定为基于 assets/effects 目录的相对路径，文件名不包括扩展名。 因为编辑器内置 effect 资源全部位于 Internal DB 的 assets/effects 目录下，因而引用时没有路径部分。 在材质面板的 effect 下拉列表中可以看到所有当前可用的 effect name。 关于 YAML YAML 是一门面向数据序列化的，对人类书写十分友好的语言，但它引入了一些独特的语法来表示不同类型的数据， 对于不熟悉这门语言的开发者可能会有一点门槛，我们在 这里 快速总结了一下最常用的一些语法和语言特性，有需要可以参考。 Pass 中可配置的参数 每个 Pass 只有两个必填参数：vert 和 frag 声明了当前 pass 使用的 shader, 格式为 片段名:入口函数名 这个名字可以是本文件中声明的 shader 片段名, 也可以是引擎提供的标准头文件。 片段中不应出现 main 函数入口, 在 effect 编译期会插入 wrapper，将指定入口函数的返回值赋值给当前 shader 的输出（gl_Position 或最终的输出颜色）。 所有其他其他可选参数及默认值见 完整列表。 Shader 片段 Shader 片段在语法上基于 GLSL 300 ES，在资源加载时有相应的预处理编译流程。 这一节会介绍所有的 “领域特定” 扩展语法，更多实际使用示例，可参考编辑器内提供的 builtin effect。 在标准 GLSL 语法上，我们引入了一些非常自然的 C 风格语法扩展： Include 机制 类似 C/C++ 的头文件 include 机制, 你可以在任意 shader 代码（CCProgram 块或独立的头文件）中这样引入其他代码片段： #include #include \"../headers/my-shading-algorithm.chunk\" 相关规则和注意事项： 头文件默认扩展名为 .chunk，包含时可省略；尖括号和双引号没有区别； 在编译期的头文件展开过程中，每个头文件保证只会被展开一次，所以书写时不必担心，每个模块都可以（也应该）包含自己依赖的头文件，即使这中间有重复； 更进一步地，所有不参与运行时实际计算流程的函数声明也都会在编译期就被剔除，所以可以放心包含各类工具函数； 头文件引用可以指定基于当前文件目录的相对路径（以下统称\"相对路径\"），也可以指定基于 assets/chunks 目录的相对路径（以下统称\"项目绝对路径\"），两个位置如都有同名文件，后者优先； 引用编辑器其他 DB 的头文件（Internal 或各类插件 DB 等）只能指定项目绝对路径，多个 DB 此路径下有相同文件时，优先级：用户项目 DB > 插件 DB > Internal DB； 编辑器内置头文件资源就在 internal DB 的 assets/chunks 目录下, 所以可以不加目录，直接引用，主要包括一些常用的工具函数, 和标准光照模型等。 所有在同一个 effect 文件中声明的 CCProgram 代码块都可以相互引用。 预处理宏定义 目前 Effect 系统的设计倾向于在游戏项目运行时可以方便地利用 shader 中的各类预处理宏, 而减少 runtime branching。 编辑器会在加载资源时收集所有在 shader 中出现的 defines, 然后引擎在运行时动态地将需要的声明加入 shader 内容。 所以要使用这些预处理宏, 只需要如上面的截图例子中一样, 在 shader 中直接进行逻辑判断即可。 所有的 define 都会被序列化到 inspector 上, 供使用者调整。 几点相关的注意事项： 为尽可能多地在编译期做类型检查，目前的策略是直接将所有自定义宏置为 true （或根据 Macro Tags 指定的默认值）再交给后端尝试检查；所以如果设计上某些宏之间存在互斥关系（不可能同时为 true）的话，应统一使用一个通过 tag 声明的宏来处理； 运行时会显式定义所有 shader 中出现的自定义宏（默认定义为 0），所以除 GLSL 语言内置宏外（GL_ 开头的 extension 等），请不要使用 #ifdef 或 #if defined 这样的形式做判断，执行结果会始终为 true； 运行时会对宏定义组合计算 hash，目前的计算机制在宏定义组合数 2^32 以内（一个 int 的范围）相对高效，对应到 shader 中相当于 32 个 boolean 开关，请尽量不要超出此限制，定义过多运行时可调整的宏定义，影响运行效率； Macro Tags 虽然我们会尝试自动识别所有出现在预处理分支逻辑中 (#if) 的宏定义，但有时实际使用方式要比简单的布尔开关更复杂一些，如： // macro defined within certain numerical 'range' #if LAYERS == 4 // ... #elif LAYERS == 5 // ... #endif // multiple discrete 'options' float metallic = texture(pbrMap, uv).METALLIC_SOURCE; 针对这类有固定取值范围，或固定选项的宏定义，需要选择一个合适的 tag 显式声明： Tag Tag 参数 默认值 说明 range 一个长度为 2 的数组，首元素为最小值，末元素为最大值 [0, 3] 针对连续数字类型的宏定义，显式指定它的取值范围，范围应当控制到最小，有利于运行时的 shader 管理 options 一个任意长度的数组，每个元素都是一个可能的取值 如未显式声明则不会定义任何宏 针对有清晰选项的宏定义，显式指定它的可用选项 比如下面这样的声明： #pragma define LAYERS range([4, 5]) #pragma define METALLIC_SOURCE options([r, g, b, a]) 一个是名为 LAYERS 的宏定义，它在运行时可能的取值范围为 [4, 5]； 另一个是名为 METALLIC_SOURCE 的宏定义，它在运行时可能的取值为 'r', 'g', 'b', 'a' 四种。 注意：语法中每个 tag 只有一个参数，这个参数可以直接用 YAML 语法去指定。 Functional Macros 由于 WebGL1 不原生支持，我们将函数式宏定义提供为 effect 编译期的功能，输出的 shader 中就已经将此类宏定义展开。 这非常适用于 inline 一些简单的工具函数，或需要大量重复定义的相似代码。事实上，内置头文件中不少工具函数都是函数式宏定义： #define CCDecode(position) \\ position = vec4(a_position, 1.0) #define CCVertInput(position) \\ CCDecode(position); \\ #if CC_USE_SKINNING \\ CCSkin(position); \\ #endif \\ #pragma // empty pragma trick to get rid of trailing semicolons at effect compile time 但与 C/C++ 的宏定义系统相同，这套机制不会对宏定义的卫生情况做任何处理， 由不卫生的宏展开而带来的问题需要开发者自行处理，因此我们推荐，并也确保所有内置头文件中，谨慎定义含有局部变量的预处理宏： // please do be careful with unhygienic macros like this #define INCI(i) do { int a=0; ++i; } while(0) // when invoking int a = 4, b = 8; INCI(b); // correct, b would be 9 after this INCI(a); // wrong! a would still be 4 Vertex Input1 为对接骨骼动画与数据解压流程，我们提供了 CCVertInput 工具函数，对所有 3D 模型使用的 shader，可直接在 vs 开始时类似这样写： #include vec4 vert () { vec3 position; CCVertInput(position); // ... do your thing with `position` (models space, after skinning) } 如果还需需要法线等信息，可直接使用 standard 版本： #include vec4 vert () { StandardVertInput In; CCVertInput(In); // ... now use `In.position`, etc. } 这会返回模型空间的顶点位置（position）、法线（normal）和切空间（tangent）信息，并对骨骼动画模型做完蒙皮计算。 注意引用头文件后，不要在 shader 内重复声明这些 attributes（a_position 等）。 对于其他顶点数据（如 uv 等）还是正常声明 attributes 直接使用。 另外如果需要对接引擎动态合批和 instancing 流程，需要包含 cc-local-batch 头文件，通过 CCGetWorldMatrix 工具函数获取世界矩阵： // unlit version (when normal is not needed) mat4 matWorld; CCGetWorldMatrix(matWorld); // standard version mat4 matWorld, matWorldIT; CCGetWorldMatrixFull(matWorld, matWorldIT); 关于更多 shader 内置 uniform，可以参考 完整列表。 Fragment Ouput1 为对接引擎渲染管线，我们提供了 CCFragOutput 工具函数，对所有无光照 shader，可直接在 fs 返回时类似这样写： #include vec4 frag () { vec4 o = vec4(0.0); // ... do the computation return CCFragOutput(o); } 这样中间的颜色计算就不必区分当前渲染管线是否为 HDR 流程等。 如需要包含光照计算，可结合标准着色函数 CCStandardShading 一起构成 surface shader 流程： #include #include void surf (out StandardSurface s) { // fill in your data here } vec4 frag () { StandardSurface s; surf(s); vec4 color = CCStandardShading(s); return CCFragOutput(color); } 在此框架下可方便地实现自己的 surface 输入，或其他 shading 算法； 注意：CCFragOutput 函数一般还是不需要自己实现，它只起与渲染管线对接的作用，且对于这种含有光照计算的输出，因计算结果已经在 HDR 范围，应包含 output-standard 而非 output 头文件。 自定义 Instanced 属性 通过 instancing 动态合批的功能十分灵活，在默认的流程上，用户可以加入更多 instanced 属性，这里介绍如何在 shader 中引入新的属性： 所有相关处理代码都需要依赖统一的宏定义 USE_INSTANCING： #if USE_INSTANCING // when instancing is enabled #pragma format(RGBA8) // normalized unsigned byte in vec4 a_instanced_color; #endif 几点注意： 这里可以使用编译器提示 format 指定此属性的具体数据格式，参数为引擎 GFXFormat 的任意枚举名2，如未声明则默认为 32 位 float 类型； 所有 instanced 属性都是 VS 的输入 attribute，所以如果需要在 FS 中使用，需要在 VS 中自行传递； 记得确保代码在所有分支都能正常执行，无论 USE_INSTANCING 启用与否； 在运行时所有属性都会默认初始化为 0，脚本中设置接口为： const comp = node.getComponent(ModelComponent); comp.setInstancedAttribute('a_instanced_color', [100, 150, 200, 255]); // should match the specified format 注意：在每次重建 PSO 时（一般对应更换新材质时）所有属性值都会重置，需要重新设置。 WebGL 1 fallback 支持 由于 WebGL 1 仅支持 GLSL 100 标准语法, 在 effect 编译期会提供 300 es 转 100 的 fallback shader, 用户基本不需关心这层变化。 但注意目前的自动 fallback 只支持一些基本的格式转换，如果使用了 300 es 独有的 shader 函数（texelFetch、textureGrad 等）或 extension， 我们推荐根据 __VERSION__ 宏定义判断 shader 版本，自行实现更稳定精确的 fallback: #if __VERSION__ 在 effect 编译期我们会尝试解析所有已经为常量的宏控制流，将实际内容做剔除或拆分到不同版本的 shader 输出中。 关于 UBO 内存布局 首先结论是，我们规定在 shader 中所有非 sampler 的 uniform 都应以 block 形式声明，且对于所有 UBO： 不应出现 vec3 成员； 对数组类型成员，每个元素 size 不能小于 vec4； 不允许任何会引入 padding 的成员声明顺序。 这些规则都会在 effect 编译期做对应检查，以导入错误（implicit padding 相关）的形式提醒修改。 这可能听起来有些过分严格，但背后有非常务实的考量： 首先，UBO 是渲染管线内要做到高效数据复用的唯一基本单位，离散声明已不是一个选项； 其次，WebGL2 的 UBO 只支持 std140 布局，它遵守一套比较原始的 padding 规则：3 所有 vec3 成员都会补齐至 vec4：uniform ControversialType { vec3 v3_1; // offset 0, length 16 [IMPLICIT PADDING!] }; // total of 16 bytes 任意长度小于 vec4 类型的数组和结构体，都会逐元素补齐至 vec4：uniform ProblematicArrays { float f4_1[4]; // offset 0, stride 16, length 64 [IMPLICIT PADDING!] }; // total of 64 bytes 所有成员在 UBO 内的实际偏移都会按自身所占字节数对齐4：uniform IncorrectUBOOrder { float f1_1; // offset 0, length 4 (aligned to 4 bytes) vec2 v2; // offset 8, length 8 (aligned to 8 bytes) [IMPLICIT PADDING!] float f1_2; // offset 16, length 4 (aligned to 4 bytes) }; // total of 32 bytes* uniform CorrectUBOOrder { float f1_1; // offset 0, length 4 (aligned to 4 bytes) float f1_2; // offset 4, length 4 (aligned to 4 bytes) vec2 v2; // offset 8, length 8 (aligned to 8 bytes) }; // total of 16 bytes 这意味着大量的空间浪费，且某些设备的驱动实现也并不完全符合此标准5，因此我们目前选择限制这部分功能的使用，以帮助排除一部分非常隐晦的运行时问题。 注意：再次提醒，uniform 的类型与 inspector 的显示和运行时参数赋值时的程序接口可以不直接对应，通过 property target 机制，可以独立编辑任意 uniform 具体的分量。 [1] 不包含粒子、sprite、后效等不基于 mesh 执行渲染的 shader ↩ [2] 注意 WebGL 1.0 平台下不支持整型 attributes，如项目需要发布到此平台，应使用默认浮点类型 ↩ [3] OpenGL 4.5, Section 7.6.2.2, page 137 ↩ [4] 注意在示例代码中，UBO IncorrectUBOOrder 的总长度为 32 字节，实际上这个数据到今天也依然是平台相关的，看起来是由于 GLSL 标准的疏忽，更多相关讨论可以参考这里 ↩ [5] Interface Block - OpenGL Wiki#Memory_layout) ↩ "},"material-system/pass-parameter-list.html":{"url":"material-system/pass-parameter-list.html","title":"Pass Params","keywords":"","body":"Pass 可选配置参数 默认值为加粗项，所有参数不区分大小写。 Name Options switch *undefined, could be any valid macro name that's not defined in the shader priority default(128), could be any number between max(255) and min(0) stage default, could be the name of any registered stage in your runtime pipeline properties *see the following section migrations *see the following section primitive point_list, line_list, line_strip, line_loop,triangle_list, triangle_strip, triangle_fan,line_list_adjacency, line_strip_adjacency,triangle_list_adjacency, triangle_strip_adjacency,triangle_patch_adjacency, quad_patch_list, iso_line_list dynamics [], an array containing any of the following:viewport, scissor, line_width, depth_bias, blend_constants,depth_bounds, stencil_write_mask, stencil_compare_mask rasterizerState.cullMode front, back, none depthStencilState.depthTest true, false depthStencilState.depthWrite true, false depthStencilState.depthFunc never, less, equal, less_equal, greater, not_equal, greater_equal, always blendState.targets[i].blend true, false blendState.targets[i].blendEq add, sub, rev_sub blendState.targets[i].blendSrc one, zero, src_alpha_saturate,src_alpha, one_minus_src_alpha,dst_alpha, one_minus_dst_alpha,src_color, one_minus_src_color,dst_color, one_minus_dst_color,constant_color, one_minus_constant_color,constant_alpha, one_minus_constant_alpha blendState.targets[i].blendDst one, zero, src_alpha_saturate,src_alpha, one_minus_src_alpha,dst_alpha, one_minus_dst_alpha,src_color, one_minus_src_color,dst_color, one_minus_dst_color,constant_color, one_minus_constant_color,constant_alpha, one_minus_constant_alpha blendState.targets[i].blendSrcAlpha one, zero, src_alpha_saturate,src_alpha, one_minus_src_alpha,dst_alpha, one_minus_dst_alpha,src_color, one_minus_src_color,dst_color, one_minus_dst_color,constant_color, one_minus_constant_color,constant_alpha, one_minus_constant_alpha blendState.targets[i].blendDstAlpha one, zero, src_alpha_saturate,src_alpha, one_minus_src_alpha,dst_alpha, one_minus_dst_alpha,src_color, one_minus_src_color,dst_color, one_minus_dst_color,constant_color, one_minus_constant_color,constant_alpha, one_minus_constant_alpha blendState.targets[i].blendAlphaEq add, sub, rev_sub blendState.targets[i].blendColorMask all, none, r, g, b, a, rg, rb, ra, gb, ga, ba, rgb, rga, rba, gba blendState.blendColor 0 or [0, 0, 0, 0] depthStencilState.stencilTest true, false depthStencilState.stencilFunc never, less, equal, less_equal, greater, not_equal, greater_equal, always depthStencilState.stencilReadMask 0xffffffff or [1, 1, 1, 1] depthStencilState.stencilWriteMask 0xffffffff or [1, 1, 1, 1] depthStencilState.stencilFailOp keep, zero, replace, incr, incr_wrap, decr, decr_wrap, invert depthStencilState.stencilZFailOp keep, zero, replace, incr, incr_wrap, decr, decr_wrap, invert depthStencilState.stencilPassOp keep, zero, replace, incr, incr_wrap, decr, decr_wrap, invert depthStencilState.stencilRef 1 or [0, 0, 0, 1] depthStencilState.stencil*Front/Back \\set above stencil properties for specific side* Switch 指定这个 pass 的执行依赖于哪个 define，它不应与使用到的 shader 中定义的任何 define 重名。 这个字段默认是不存在的，意味着这个 pass 是无条件执行的。 Priority 指定这个 pass 的渲染优先级，数值越小越优先渲染；default 代表默认优先级 (128)，min 代表最小（0），max 代表最大（255），可结合四则运算符指定相对值。 Stage 指定这个 pass 归属于管线的哪个 stage，对 forward 管线，只有 default 一个 stage。 Properties properties 存储着这个 Pass 有哪些可定制的参数需要在 Inspector 上显示， 这些参数可以是 shader 中的某个 uniform 的完整映射，也可以是具体某个分量的映射 (使用 target 参数)： albedo: { value: [1, 1, 1, 1] } # uniform vec4 albedo roughness: { value: 0.8, target: pbrParams.g } # uniform vec4 pbrParams offset: { value: [0, 0], target: tilingOffset.zw } # uniform vec4 tilingOffset # say there is another uniform, vec4 emissive, that doesn't appear here # so it will be assigned a default value of [0, 0, 0, 0] and will not appear in the inspector 运行时可以这样使用： // as long as it is a real uniform // it doesn't matter whether it is specified in the property list or not mat.setProperty('emissive', cc.Color.GREY); // this works mat.setProperty('albedo', cc.Color.RED); // directly set uniform mat.setProperty('roughness', 0.2); // set certain component const h = mat.passes[0].getHandle('offset'); // or just take the handle, mat.passes[0].setUniform(h, new Vec2(0.5, 0.5)); // and use Pass.setUniform interface instead 未指定的 uniform 将由引擎在运行时根据自动分析出的数据类型给予默认初值。 为方便声明各 property 子属性，可以直接在 properties 内声明 __metadata__ 项，所有 property 都会继承它声明的内容，如： properties: __metadata__: { editor: { visible: false } } a: { value: [1, 1, 0, 0] } b: { editor: { type: color } } c: { editor: { visible: true } } 这样 uniform a 和 b 已声明的各项参数都不受影响，但全部不会显示在 inspector 上（visible 为 false），而 uniform c 还会正常显示。 Migrations 一般来说使用材质资源时希望底层的 effect 接口能始终向前兼容，但依然有时面对新的需求最好的解决方案是含有一定 breaking change 的， 这时为了保持项目中已有的材质资源数据不受影响，或至少能够更平滑的升级，可以使用 effect 的迁移系统， 在 effect 导入成功后会 立即更新工程内所有 依赖于此 effect 的材质资源， 对每个材质资源，尝试寻找所有指定旧参数数据（包括 property 和宏定义两类），复制或重组到新属性名下。 这个过程不会自动删除旧数据，但是会将旧属性的 editor.deprecated 标为 true（如果新数据在 inspector 上可见的话）。 如果一个材质资源内既有旧数据，又有新数据，则不会做任何迁移（强制更新模式除外）。 对于一个现有 effect，声明如下迁移字段： migrations: # macros: # macros follows the same rule as properties, without the component-wise features # USE_MIAN_TEXTURE: { formerlySerializedAs: USE_MAIN_TEXTURE } properties: newFloat: { formerlySerializedAs: oldVec4.w } 对于一个依赖于这个 effect，并在对应 pass 持有这样的属性的材质： { \"oldVec4\": { \"__type__\": \"cc.Vec4\", \"x\": 1, \"y\": 1, \"z\": 1, \"w\": 0.5 } } 在 effect 重新导入后，这些数据会被立即转换成： { \"oldVec4\": { \"__type__\": \"cc.Vec4\", \"x\": 1, \"y\": 1, \"z\": 1, \"w\": 0.5 }, \"newFloat\": 0.5 } 在编辑器内重新编辑并保存这个材质资源后会变成（假设 effect 和 property 数据本身并没有改变）： { \"newFloat\": 0.5 } 注意这里的通道指令只是简单的取 w 分量，事实上还可以做任意的 shuffle： newColor: { formerlySerializedAs: someOldColor.yxx } 甚至基于某个宏定义： occlusion: { formerlySerializedAs: pbrParams. } 这里声明了新的 occlusion 属性会从旧的 pbrParams 中获取，而具体的分量取决于 OCCLUSION_CHANNEL 宏定义，且如材质资源中未定义此宏，默认取 z 通道。 但如果某个材质在迁移升级前就已经存着 newFloat 字段的数据，则不会对其做任何修改，除非指定为强制更新模式： newFloat: { formerlySerializedAs: oldVec4.w! } 这会强制更新所有材质的属性，无论这个操作是否会覆盖数据。 注意强制更新操作会在编辑器的每次资源事件中都执行（几乎对应每一次鼠标点击，相对高频）， 因此只是一个快速测试和调试的手段，一定不要将处于强制更新模式的 effect 提交版本控制。 Property Param List 同样地，任何可配置字段如与默认值相同都可以省掉。 Param Options target undefined, (any valid uniform components, no random swizzle) value \\see the next section* sampler.minFilter none, point, linear, anisotropic sampler.magFilter none, point, linear, anisotropic sampler.mipFilter none, point, linear, anisotropic sampler.addressU wrap, mirror, clamp, border sampler.addressV wrap, mirror, clamp, border sampler.addressW wrap, mirror, clamp, border sampler.maxAnisotropy 16 sampler.cmpFunc never, less, equal, less_equal, greater, not_equal, greater_equal, always sampler.borderColor [0, 0, 0, 0] sampler.minLOD 0 sampler.maxLOD 0, \\remember to override this when enabling mip filter* sampler.mipLODBias 0 editor \\see the next section* editor.displayName (any string), *property name editor.type vector, color editor.visible true, false editor.tooltip (any string), *property name editor.range undefined, [ min, max, [step] ] editor.deprecated true, false, \\for any material using this effect, delete the existing data for this property after next saving* Default Values Type Default Value / Options int 0 ivec2 [0, 0] ivec3 [0, 0, 0] ivec4 [0, 0, 0, 0] float 0 vec2 [0, 0] vec3 [0, 0, 0] vec4 [0, 0, 0, 0] sampler2D black, grey, white, normal, default samplerCube black-cube, white-cube, default-cube 对于 defines： boolean 类型默认值为 false。 number 类型默认值为 0，默认取值范围 [0, 3]。 string 类型默认值为 options 数组第一个元素。 "},"material-system/builtin-shader-uniforms.html":{"url":"material-system/builtin-shader-uniforms.html","title":"Builtin Shader Uniforms","keywords":"","body":"常用 shader 内置 Uniform 要在 shader 中使用内置变量，需要包含对应头文件。 目前所有的内置变量，按所在头文件分组，依次有： cc-local.chunk Name Type Info cc_matWorld mat4 模型空间转世界空间矩阵 cc_matWorldIT mat4 模型空间转世界空间逆转置矩阵 cc-global.chunk Name Type Info cc_time vec4 x：游戏运行时间（秒） cc_screenSize vec4 xy：屏幕尺寸 zw：屏幕尺寸倒数 cc_screenScale vec4 xy：屏幕缩放 zw：屏幕缩放倒数 cc_nativeSize vec4 xy：实际着色缓冲的尺寸 zw：实际着色缓冲的尺寸倒数 cc_matView mat4 视图矩阵 cc_matViewInv mat4 视图逆矩阵 cc_matProj mat4 投影矩阵 cc_matProjInv mat4 投影逆矩阵 cc_matViewProj mat4 视图投影矩阵 cc_matViewProjInv mat4 视图投影逆矩阵 cc_cameraPos vec4 xyz：相机位置 cc_exposure vec4 x：相机曝光 y：相机曝光倒数 z：是否启用 HDR w：HDR 转 LDR 缩放参数 cc_mainLitDir vec4 xyz：主方向光源方向 cc_mainLitColor vec4 xyz：主方向光颜色 w：主方向光强度 cc_ambientSky vec4 xyz：天空颜色 w：亮度 cc_ambientGround vec4 xyz：地面反射光颜色 cc-environment.chunk Name Type Info cc_environment samplerCube IBL 环境贴图 cc-forward-light.chunk Name Type Info cc_sphereLitPos[MAX_LIGHTS] vec4 xyz：球面光位置 cc_sphereLitSizeRange[MAX_LIGHTS] vec4 x：球光尺寸 y：球光范围 cc_sphereLitColor[MAX_LIGHTS] vec4 xyz：球光颜色 w：球光强度 cc_spotLitPos[MAX_LIGHTS] vec4 xyz：聚光灯位置 cc_spotLitSizeRangeAngle[MAX_LIGHTS] vec4 x：聚光灯尺寸 y：聚光灯范围 z：聚光灯角度 cc_spotLitDir[MAX_LIGHTS] vec4 xyz：聚光灯方向 cc_spotLitColor[MAX_LIGHTS] vec4 xyz：聚光灯颜色 w：聚光灯强度 cc-shadow.chunk Name Type Info cc_matLightPlaneProj mat4 平面阴影的变换矩阵 cc_shadowColor vec4 阴影颜色 "},"audio-system/overview.html":{"url":"audio-system/overview.html","title":"声音","keywords":"","body":"声音系统总览 声音系统的接口主要面向两类需求，一类是长度较长，循环持续播放的 “音乐”，一类是长度较短，一次性播放的 “音效”。 所有音频资源都会在编辑器内导入成 AudioClip 资源，要播放声音，首先需要在场景里创建 AudioSourceComponent。 对于音乐，可以直接将 AudioClip 赋给 AudioSourceComponent 上的 clip 属性，勾选 playOnAwake 属性或脚本调用组件的 play 方法来控制播放； 对于音效，可以在脚本里调用 AudioSourceComponent 的 playOneShot 方法，在调用时传入要播放的音效片段和音量。 注意虽然 AudioClip 资源本身也直接有 play 等接口实现，但 AudioSourceComponent 才是常规的播放入口，请尽量使用组件完成工作流。 音频相关事件 所有的 AudioClip 资源对象都是一个 EventTarget： 在音频开始实际播放时，会发出 started 事件； 在音频播放自然结束时，会发出 ended 事件； 平台差异性 目前支持 Web Audio API、DOM 音频、微信小游戏音频三种接口，虽然运行时各个平台的音频接口实现并不完全统一， 我们已经尽力在引擎中最小化这部分差异，但还是会存在一部分不可协调的不一致性： iOS 平台 DOM 音频模式不支持调整音量大小，所有 volume 相关属性将不会有效； 只有 Web Audio 模式支持同一音频的多重播放，其他模式下为避免重复创建，多次调用 playOneShot 的默认行为是从头开始重新播放； 目前大部分平台都已遵守最新的 auto play police，即使设置了 playOnAwake 也会在第一次接收到用户输入时才开始播放； "},"particle-system/overview.html":{"url":"particle-system/overview.html","title":"粒子","keywords":"","body":"Particle System Overview 粒子系统是游戏引擎特效表现的基础，它可以用于模拟的火、烟、水、云、雪、落叶等自然现象，也可用于模拟发光轨迹、速度线等抽象视觉效果。 基本结构 粒子系统的基本单元是粒子，一个粒子一般具有位置、大小、颜色、速度、加速度、生命周期等属性。在每一帧中，粒子系统一般会执行如下步骤： 产生新的粒子，并初始化 删除超过生命周期的粒子 更新粒子的动态属性 渲染所有有效的粒子 一般粒子系统会有如下几个部分组成： 发射器，用于创建粒子，并初始化粒子的属性 影响器，用于更新粒子的属性 渲染器，渲染粒子 粒子类，存储粒子的属性 粒子系统类，管理上面的模块 Cocos Creator 3D粒子系统以模块来组织功能，包含了以下模块： 模块 描述 ParticleSystemComponent 用于存储在Inspector中显示的所有数据，管理粒子生成、更新、销毁相关模块，控制粒子播放 ShapeModule 用于控制粒子发射，包括发射方向与速度，支持预定义的发射方向包括方块、圆、锥体、球、半球 AnimatorModule 用于控制粒子发射后状态更新。已支持的功能有：大小、颜色、旋转、速度、加速度、限速、贴图动画 ParticleSystemRenderer 用于生成粒子渲染所需要的数据。包括vb、ib、渲染状态相关的控制 添加一个粒子系统模块有两种方式： 像其他组件一样为节点添加粒子系统组件（不推荐） 使用编辑器添加粒子系统组件（推荐） 开发者可以通过右侧 Inspector 面板上点击“添加组件”添加粒子，如下图： 也可以通过左侧的层级管理器“右键->创建->特效->粒子系统”来添加一个粒子系统组件，如下图： 前往 粒子系统模块 说明文档。 "},"particle-system/module.html":{"url":"particle-system/module.html","title":"粒子系统模块","keywords":"","body":"粒子系统功能介绍 ParticleSystemComponent 存储了粒子发射的初始状态以及粒子发射后状态更新子模块。 粒子系统模块 主模块(ParticleSystemComponent)发射器模块(ShapeModule)颜色模块(ColorOvertimeModule)大小模块(SizeOvertimeModule)旋转模块(RotationOvertimeModule)速度模块(VelocityOvertimeModule)限速模块(LimitVelocityOvertimeModule)加速模块(ForceOvertimeModule)贴图动画模块(TextureAnimationModule)渲染模块(Renderer)拖尾模块(TrailModule) 粒子系统资源剔除 各个粒子系统的模块都是作为独立对象存在，每个模块都会存储一些模块相关的数据，因此对于未勾选使用的模块，其记录的数据则是无用数据。当开发者不需要在运行时动态开启这些未编辑使用的模块，可以勾选 ParticleSystemComponent 的 Inspector 面板最下方的 EnableCulling 选项，对这些无用数据进行剔除，从而减小资源占用。 "},"particle-system/main-module.html":{"url":"particle-system/main-module.html","title":"主模块(ParticleSystemComponent)","keywords":"","body":"主模块(ParticleSystemComponent) 属性 功能 duration 粒子系统运行总时间 capacity 粒子系统能生成的最大粒子数量 loop 粒子系统是否循环播放 playOnAwake 粒子系统加载后是否自动开始播放 prewarm 选中之后，粒子系统会以已播放完一轮之后的状态开始播放（仅当循环播放启用时有效） simulationSpace 控制粒子坐标计算所在的坐标系 startDelay 粒子延迟发射的时间 startLifetime 粒子生命周期 startColor 粒子初始颜色 scaleSpace 粒子缩放的坐标空间，local基于本地空间的缩放，world基于世界空间的缩放 startSize 粒子初始大小 startSpeed 粒子初始速度 startRotation 粒子初始旋转角度 gravityModifier 重力系数 rateOverTime 每秒发射的粒子数 rateOverDistance 每移动单位距离发射的粒子数 bursts 在某个时间点发射给定数量的粒子 - time 粒子播放多长时候后开始发射burst - count 发射的粒子数量 - repeatCount burst触发次数 - repeatInterval 每次触发的时间间隔 "},"particle-system/emitter.html":{"url":"particle-system/emitter.html","title":"发射器模块(ShapeModule)","keywords":"","body":"发射器模块(ShapeModule) 公有属性： 属性 作用 position 相对于挂载节点的位置 rotation 相对于挂载节点的旋转 scale 相对于挂载节点的缩放 sphericalDirectionAmount 表示当前发射方向与当前位置到结点中心连线方向的插值 randomPositionAmount 表示与当前发射位置的偏移 方块(Box) 属性 作用 shapeType Box emitFrom 粒子从方块的哪个部位发射，edge:边框；shell:表面；volume:内部 球、半球(Shpere\\Hemisphere) 属性 作用 shapeType Shpere\\Hemisphere radius 球体半径 radiusThickness 0表示从球表面发射，1表示从球体内部发射，0~1之间表示从表面到球心之间发射 圆(Circle) 属性 作用 shapeType Circle radius 圆的半径 radiusThickness 0表示从圆周发射，1表示从圆内部发射，0~1之间表示从圆周到圆心之间发射 arc 表示在圆的一个扇形区域发射 mode 表示粒子在扇形区域的发射方式，random:随机位置，loop:沿某一方向循环发射，每次循环方向相同，pingPong:循环发射，每次循环方向相反 spread:表示粒子在某个间断发射，比如，0表示可以在任意位置发射，0.1表示每隔圆周的十分之一位置发射 speed 表示粒子沿圆周发射的速度 spread 表示粒子沿圆周发射时，在圆弧哪些位置发射。例如，arc为120°，spread为0.1，则从圆弧开始每隔12°发射一次粒子 圆锥(Cone) 属性 作用 shapeType Cone angle 圆锥的轴与母线的夹角 radius 圆锥顶部截面半径 length 圆锥顶部截面距离底部的轴长 radiusThickness 0表示从圆周发射，1表示从圆内部发射，0~1之间表示从圆周到圆心之间发射 arc 表示在圆的一个扇形区域发射 mode 表示粒子在扇形区域的发射方式，random:随机位置，loop:沿某一方向循环发射，每次循环方向相同，pingPong:循环发射，每次循环方向相反 spread:表示粒子在某个间断发射，比如，0表示可以在任意位置发射，0.1表示每隔圆周的十分之一位置发射 speed 表示粒子沿圆周发射的速度 spread 表示粒子沿圆周发射时，在圆弧哪些位置发射。例如，arc为120°，spread为0.1，则从圆弧开始每隔12°发射一次粒子 "},"particle-system/color-module.html":{"url":"particle-system/color-module.html","title":"颜色模块(ColorOvertimeModule)","keywords":"","body":"颜色模块(ColorOvertimeModule) 属性 作用 color 颜色随时间变化的参数，可采用不同的颜色变化模式 "},"particle-system/size-module.html":{"url":"particle-system/size-module.html","title":"大小模块(SizeOvertimeModule)","keywords":"","body":"大小模块(SizeOvertimeModule) 属性 作用 separateAxes 是否三个轴分开进行缩放。 size 大小随时间变化的曲线，可采用不同计算模式，当separateAxes为false时有效。 X Y Z 大小随时间变化的曲线，可对三个坐标轴设置不同缩放，可采用不同计算模式，当separateAxes为true时有效。 "},"particle-system/rotation-module.html":{"url":"particle-system/rotation-module.html","title":"旋转模块(RotationOvertimeModule)","keywords":"","body":"旋转模块(RotationOvertimeModule) 属性 作用 separateAxes 是否三个轴分开进行旋转。 X Y Z 旋转随时间变化的曲线，可对三个坐标轴设置不同旋转，可采用不同计算模式，X,Y仅当separateAxes为true时有效。 "},"particle-system/velocity-module.html":{"url":"particle-system/velocity-module.html","title":"速度模块(VelocityOvertimeModule)","keywords":"","body":"速度模块(VelocityOvertimeModule) 属性 作用 space 速度在哪个坐标系中计算。 x,y,z 三个方向上的速度分量，可使用不同的计算模式。 speedModifier 速度修正系数。 "},"particle-system/limit-velocity-module.html":{"url":"particle-system/limit-velocity-module.html","title":"限速模块(LimitVelocityOvertimeModule)","keywords":"","body":"限速模块(LimitVelocityOvertimeModule) 属性 作用 space 速度在哪个坐标系中计算。 limit 速度下限，当速度超出该值时，将当前速度与该速度做线性插值，当separateAxes为false时有效。 dampen 当前速度与速度下限的插值。 separateAxes 是否三个轴分开限制。 limit X,Y,Z 三个轴的速度下限，当separateAxes为true时有效。 "},"particle-system/force-module.html":{"url":"particle-system/force-module.html","title":"加速度模块(ForceOvertimeModule)","keywords":"","body":"加速度模块(ForceOvertimeModule) 属性 作用 space 加速度在哪个坐标系中计算。 x,y,z 三个方向上的加速度分量，可采用不同的计算模式。 "},"particle-system/texture-animation-module.html":{"url":"particle-system/texture-animation-module.html","title":"贴图动画模块(TextureAnimationModule)","keywords":"","body":"贴图动画模块(TextureAnimationModule) 属性 作用 mode grid一张贴图包含一个粒子播放的动画帧。 numTilesX x方向动画帧数。 numTilesY y方向动画帧数。 animation wholeSheet播放贴图中的所有帧，singleRow只播放其中一行。 frameOverTime 一个周期内动画播放的帧与时间变化曲线。 startFrame 从第几帧开始播放，时间为整个粒子系统的生命周期。 cycleCount 一个生命周期内播放几次循环。 "},"particle-system/renderer.html":{"url":"particle-system/renderer.html","title":"渲染模块(Renderer)","keywords":"","body":"Particle Renderer 粒子渲染部分由 ParticleSystemRenderer 控制，ParticleSystemRenderer 分为 CPU 渲染器和 GPU 渲染器，CPU 渲染器通过一个对象池来维护所有粒子，根据粒子当前状态来生成对应的 vb、ib 数据，持有粒子需要渲染的材质，并且保存相关渲染状态。GPU 渲染器目前版本是在 CPU 端生成粒子，只提交初始参数的 vb, ib 数据，但是模块相关的计算则是通过预采样数据的形式，初始化时提交一次数据，后续的模块系统则是在 GPU 端对数据进行提取模拟运算，减少 CPU 端的计算压力，目前版本不支持 TrailModule 和 LimitVelocityOvertimeModule, 后续版本仍将持续对粒子系统进行优化改进。 属性 作用 renderMode 设置一个粒子面片的生成方式，billboard 粒子始终面向摄像机，stretchedBillboard 粒子始终面向摄像机,但会根据相关参数进行拉伸，horizontalBillboard 粒子面片始终与 xz 平面平行,verticalBillboard 粒子面片始终与Y轴平行，但会朝向摄像机，mesh 粒子为一个模型。 velocityScale 在 stretchedBillboard 模式下,对粒子在运动方向上按速度大小进行拉伸。 lengthScale 在 stretchedBillboard 模式下,对粒子在运动方向上按粒子大小进行拉伸。 mesh 在 renderMode 为 mesh 时，指定要渲染的粒子的模型。 particleMaterial 用于粒子渲染的材质，当选用 CPU 渲染器时，也就是不勾选 useGPU 的情况下，材质使用的 effect 只能是 builtin-particle，不支持其它的 effect。当选用 GPU 渲染器时，也就是勾选 useGPU 的情况下，材质使用的 effect 只能是 builtin-particle-gpu, 不支持其它的 effect。 trailMaterial 用于拖尾渲染的材质，材质的 effect 只支持 builtin-particle-trail，不支持其它的 effect。 useGPU 是否使用 GPU 渲染器进行粒子的渲染，默认不勾选。当不勾选该选项的情况下，使用 CPU 渲染器 ParticleSystemRendererCPU 进行粒子的渲染。当勾选该选项的情况下，使用 GPU 渲染器 ParticleSystemRendererGPU 进行粒子的渲染。 "},"particle-system/trail-module.html":{"url":"particle-system/trail-module.html","title":"拖尾模块(TrailModule)","keywords":"","body":"拖尾模块（TrailModule） 属性 作用 mode Particle在每个粒子的运动轨迹上形成拖尾效果。 LifeTime 拖尾的生命周期。 MinParticleDistance 粒子每生成一个拖尾节点所运行的最短距离。 Space 拖尾所在的坐标系，World在世界坐标系中运行，Local在本地坐标系中运行。 ExistWithParticles 拖尾是否跟随粒子一起消失。 TextureMode 贴图在拖尾上的展开形式，Stretch贴图覆盖在整条拖尾上，Repeat贴图覆盖在一段拖尾上。 WidthFromParticle 拖尾宽度继承自粒子大小 WidthRatio 拖尾宽度，如果继承自粒子则是粒子大小的比例 ColorFromParticle 拖尾颜色是否继承自粒子 ColorOverTrail 拖尾颜色随拖尾自身长度的颜色渐变 ColorOvertime 拖尾颜色随时间的颜色渐变 "},"engine/animation/":{"url":"engine/animation/","title":"动画","keywords":"","body":"动画概述 Cocos Creator 3D 内置了通用的动画系统用以实现基于关键帧的动画。 动画剪辑是包含了动画信息的资源。 动画剪辑是可以复用的，其状态保存在称为动画状态的对象中， 通过动画状态的接口我们可以对动画进行播放、暂停、停止、变速等控制。 动画组件统一管理动画剪辑和其状态， 允许用户在组件层面上实现动画功能。 在编辑器中我们可以很方便地产出动画剪辑资源， 例如通过动画编辑器，又或者某些外部资源中已经包含了动画剪辑资源。 在这种情况下，我们仅需要对这些动画剪辑进行组织，按我们的意愿进行播放控制。 动画组件章节介绍了如何使用动画组件和动画剪辑控制动画的播放： 动画组件 若需要深入了解动画剪辑的构成或程序化地创建动画剪辑时，可以参考： 动画剪辑 骨骼动画是一种常见但类型特殊的动画，相关详细说明参考： 骨骼动画 "},"engine/animation/animation-component.html":{"url":"engine/animation/animation-component.html","title":"动画组件","keywords":"","body":"动画组件 动画组件控制动画的播放。 像其他组件一样为结点添加动画组件： import { AnimationComponent, Node } from \"cc\"; function (node: Node) { const animationComponent = node.addComponent(AnimationComponent); } 动画组件管理了一组动画剪辑。 动画组件开始运作前，它为每一个动画剪辑都创建了相应的 动画状态 对象。 动画状态控制某个动画剪辑在结点的播放过程，一个动画剪辑可以同时为多个动画状态所用。 在动画组件中，动画状态是通过名称来标识的。 每个动画状态的默认名称就是其动画剪辑的名称。 动画的播放与切换 play() 使得动画组件开始播放指定的动画： animationComponent.play('idle'); // 播放动画状态 'idle' 在播放时，旧的动画将立即被停止，这种切换是非常突兀的。 在某些情况下，我们希望这种切换是“淡入淡出”的， 此时应当使用 crossFade() 方法。 crossFade() 会在指定的周期内平滑地完成切换： animationComponent.play('walk'); /* ... */ // 当需要切换到跑的动画时 animationComponent.crossFade('run', 0.3); // 在 0.3 秒内平滑地从走的动画切换为跑的动画 crossFade() 的这种淡入淡出机制使得同一时刻可能有不止一个动画状态在播放。 因此，动画组件没有当前动画的概念。 即便如此，动画组件仍提供了 pause()、resume()、stop() 方法， 它们暂停、继续以及停止正在播放的所有动画状态的同时， 也暂停、继续以及停止动画的切换。 动画状态 有时候你可能需要对动画状态进行其他操作，例如，设置其速度。 可以通过 getState() 获取动画状态： const animationComponent = node.getComponent(AnimationComponent); animationComponent.clips = [ idleClip, runClip ]; // 获取 `idleClip` 的状态 const idleState = animationComponent.getState(idleClip.name); 你可以设置动画播放的速度： animationComponent.getState('idle').speed = 2.0; // 以两倍速播放待机动画 动画状态也提供了 play()、pause()、resume()、stop() 这些播放控制功能。 当动画组件本身的播放控制功能不能满足你的要求时， 你也可以按照自己的方式操纵动画状态的播放。 默认动画 当动画组件的 playOnLoad 为 true 时， 动画组件将在第一次运行时自动播放默认动画剪辑 defaultClip。 帧事件 你可以为动画的每一时间点添加事件。 AnimationClip 的 events 包含了此动画所有的事件描述，每个事件描述都具有以下属性： { frame: number; func: string; params: any[]; } 其中 frame 表示事件触发的时间点，单位为秒， 例如 0.618 就表示当动画到达第 0.618 秒时将触发事件。 func 表示事件触发时回调的方法名称，事件触发时， 会在当前结点的所有组件上搜索名为 func 的方法，一旦找到，将 params 传递给它并调用。 以下代码演示了这一过程。 import { AnimationComponent, Component } from \"cc\"; class MyScript extends Component { constructor() { } public start() { const animationComponent = this.node.getComponent(AnimationComponent); if (animationComponent && animationComponent.defaultClip) { const { defaultClip } = animationComponent; defaultClip.events.push({ frame: 0.5, // 第 0.5 秒时触发事件 func: 'onTriggered', // 事件触发时调用的函数名称 params: [ 0 ], // 向 `func` 传递的参数 }); defaultClip.updateEventDatas(); } } public onTriggered(arg: number) { console.log(`I'm triggered!`); } } 以上代码表示，MyScript 组件所在结点的动画组件的默认动画剪辑 在进行到第 0.5 秒将调用 MyScript 组件的 test() 方法并传递参数 0。 "},"engine/animation/animation-clip.html":{"url":"engine/animation/animation-clip.html","title":"动画剪辑","keywords":"","body":"动画剪辑 动画剪辑是一组动画曲线，包含了所有动画数据。 动画曲线 动画曲线描述了某一对象上某一属性值随着时间的变化。 在内部，动画曲线存储了一系列时间点，每个时间点都对应着一个（曲线）值，称为一帧，或关键帧。 当动画系统运作时，动画组件根据当前动画状态计算出指定时间点应有的（结果）值并赋值给对象，完成属性变化；这一计算过程称为采样。 以下代码片段演示了如何程序化地创建动画剪辑。 import { AnimationClip, animation, js } from \"cc\"; const animationClip = new AnimationClip(); animationClip.duration = 1.0; // 整个动画剪辑的周期。任何帧时间都不应该大于此属性。 animationClip.keys = [ [ 0.3, 0.6, 0.9 ] ]; // 该动画剪辑所有曲线共享的帧时间 animationClip.curves = [{ // 组件上的属性曲线 modifiers: [ // 目标是当前结点的 // \"Body\" 子结点的 new animation.HierarchyPath('Body'), // `MyComponent`的 new animation.ComponentPath(js.getClassName(MyComponent)), // `value` 属性 'value', ], data: { keys: 0, // 索引至 `AnimationClip.keys`, 即 [ 0.3, 0.6, 0.9] values: [ 0.0, 0.5, 1.0 ], }, }]; 上述动画剪辑包含了一条曲线以控制 \"Body\" 子结点的 MyComponent 组件的 value 属性，曲线有三帧，使得 value 属性在 0.3 秒时变为 0.5，在0.6 秒时变为 0.5，在 0.9 秒时变为 1.0。 注意，曲线的帧时间是以引用方式索引到 AnimationClip.keys 数组中的。 如此一来，多条曲线可以共享帧时间。这将带来额外的性能优化。 目标对象 动画曲线的目标可以是任意 JavaScript 对象。 modifiers 字段指定了在 运行时 如何从当前结点对象寻址到目标对象。 modifiers 是一个数组， 它的每一个元素表达了如何从上一级的对象寻址到另一个对象， 最后一个元素寻址到的对象就作为曲线的目标对象。 这种行为就好像文件系统的路径，因此每个元素都被称为“目标路径”。 当目标路径是string / number 时， 表示寻址到上一级对象的属性，其本身就指定了属性名。 否则，目标路径必须是实现接口 animation.TargetPath 的对象。 Cocos Creator 3D 内置了以下几个实现自接口 animation.TargetPath 的类： animation.HierarchyPath 将上一级的对象视为结点，并寻址到它的某个子结点； animation.ComponentPath 将上一级的对象视为结点，并寻址到它的某个组件。 目标路径可以任意组合，只要它们具有正确的含义： // 目标对象是 modifiers: [ // \"nested_1\" 子结点的 \"nested_2\" 子结点的 \"nested_3\" 子结点的 new animation.HierarchyPath('nested_1/nested_2/nested_3'), // `BlahBlahComponent` 组件的 new animation.ComponentPath(js.getClassName(BlahBlahComponent)), // `names` 属性的 'names', // 第一个元素 0, ] 当你的目标对象不是一个属性，而是必须从一个方法返回时，自定义目标路径就很有用： class BlahBlahComponent extends Component { public getName(index: number) { return _names[index]; } private _names: string[] = []; } // 目标对象是 modifiers: [ // \"nested_1\" 子结点的 \"nested_2\" 子结点的 \"nested_3\" 子结点的 new animation.HierarchyPath('nested_1/nested_2/nested_3'), // `BlahBlahComponent` 组件的 new animation.ComponentPath(js.getClassName(BlahBlahComponent)), // 第一个 \"name\" { get: (target: BlahBlahComponent) => target.getName(0), }, ] 如果希望你的自定义目标路径是可序列化的，将它们声明为类： @ccclass class MyPath implements animation.TargetPath { @property public index = 0; constructor(index: number) { this.index = index; } get (target: BlahBlahComponent) { return target.getName(this.index); } } // 目标对象是 modifiers: [ // \"nested_1\" 子结点的 \"nested_2\" 子结点的 \"nested_3\" 子结点的 new animation.HierarchyPath('nested_1/nested_2/nested_3'), // `BlahBlahComponent` 组件的 new animation.ComponentPath(js.getClassName(BlahBlahComponent)), // 第一个 \"name\" new MyPath(0), ] 目标对象的寻址是在运行时完成的，这种特性使得动画剪辑可以复用到多个对象上。 赋值 当采样出值后，默认情况下将使用赋值操作符 = 将值设置给目标对象。 然而有时候，你并不能用赋值操作符来完成设置。 例如，当你想设置材质对象的 Uniform 时，你就无法通过赋值操作符来完成。 因为材质对象仅提供了 setUniform(uniformName, value) 方法来改变 uniform。 对于这种情况，曲线字段 valueAdapter 提供了一种机制使你自定义如何 将值设置到目标对象。 示例如下： class BlahBlahComponent { public setUniform(index: number, value: number) { /* */ } } { // 曲线 valueAdapter: { // 在实例化曲线时调用 forTarget(target: BlahBlahComponent) { // 在这里做一些有用的事 return { // 在每一次设置目标对象的值时调用 set(value: number) { target.setUniform(0, value); } }; } }, }; 如果希望你的“自定义赋值”是可序列化的，将它们声明为类： @ccclass class MyValueProxy implements animation.ValueProxyFactory { @property public index: number = 0; constructor(index: number) { this.index = index; } // 在实例化曲线时调用 public forTarget(target: BlahBlahComponent) { // 在这里做一些有用的事 return { // 在每一次设置目标对象的值时调用 set(value: number) { target.setUniform(0, value); } }; } } animation.UniformProxyFactory 就是这样一种“自定义赋值”的类， 它实现了设置材质的 uniform 值： { // 目标对象是 modifiers: [ // `ModelComponent` 组件的 new animation.ComponentPath(js.getClassName(ModelComponent)), // `sharedMaterials` 属性的 'sharedMaterials', // 第一个材质 0, ], valueAdapter: new animation.UniformProxyFactory( 0, // Pass 索引 'albedo', // Uniform 名称 ), }; 采样 若采样时间点恰好就等于某一关键帧的时间点，则使用该关键帧上的动画数据。 否则——当采样时间点居于两帧之间时，结果值应同时受两帧数据的影响， 采样时间点在两处关键帧的时刻区间上的比例（[0,1]）反应了影响的程度。 Cocos Creator 3D 允许将该比例映射为另一个比例，以实现不同的“渐变”效果。 这些映射方式，在 Cocos Creator 3D中称为渐变方式。 在比例确定之后，根据指定的插值方式计算出最终的结果值。 渐变方式和插值方式都影响着动画的平滑度。 渐变方式 可以为每一帧指定渐变方式，也可以为所有帧指定统一的渐变方式。 渐变方式可以是内置渐变方式的名称或贝塞尔控制点。 以下列出了几种常用的渐变方式。 linear 保持原有比例，即线性渐变；当未指定渐变方式时默认使用这种方式； constant 始终使用比例 0，即不进行渐变；与插值方式 Step 类似； quadIn 渐变由慢到快。 quadOut 渐变由快到慢。 quadInOut 渐变由慢到快再到慢。 quadOutIn 渐变由快到慢再到快。 IBezierControlPoints 展开对比 曲线值与插值方式 有些插值算法需要每一帧的曲线值中存储额外的数据，因此， 曲线值与目标属性的值类型不一定相同。 对于数值类型或值类型，Cocos Creator 3D 提供了几种通用的插值方式； 同时，也可以定义自己的插值方式。 当曲线数据的 interpolate 属性为 true 时，曲线将尝试使用插值函数： 若曲线值的类型为 number、Number，将应用线性插值； 否则，若曲线值继承自 ValueType，将调用 ValueType 的 lerp 函数完成插值， Cocos Creator 3D 内置的大多数值类型都将其 lerp 实现为线性插值； 否则，若曲线值是可插值的，将调用曲线值的 lerp 函数完成插值2。 若曲线值不满足上述任何条件，或当曲线数据的 interpolate 属性为 false时， 将不会进行插值操作 --- 永远使用前一帧的曲线值作为结果。 import { AnimationClip, color, IPropertyCurveData, SpriteFrame, v3 } from \"cc\"; const animationClip = new AnimationClip(); const keys = [ 0, 0.5, 1.0, 2.0 ]; animationClip.duration = keys.length === 0 ? 0 : keys[keys.length - 1]; animationClip.keys = [ keys ]; // 所有曲线共享一列帧时间 // 使用数值的线性插值 const numberCurve: IPropertyCurveData = { keys: 0, values: [ 0, 1, 2, 3 ], /* interpolate: true, */ // interpolate 属性默认打开 }; // 使用值类型 Vec3 的 lerp() const vec3Curve: IPropertyCurveData = { keys: 0, values: [ v3(0), v3(2), v3(4), v4(6) ], interpolate: true, }; // 不插值（因为显式禁用了插值） const colorCuve: IPropertyCurveData = { keys: 0, values: [ color(255), color(128), color(61), color(0) ], interpolate: false, // 不进行插值 }; // 不插值（因为 SpriteFrame 无法进行插值） const spriteCurve: IPropertyCurveData = { keys: 0, values: [ new SpriteFrame(), new SpriteFrame(), new SpriteFrame(), new SpriteFrame() ], }; 下列代码展示了如何自定义插值算法： import { ILerpable, IPropertyCurveData, Quat, quat, Vec3, v3, vmath } from \"cc\"; class MyCurveValue implements ILerpable { public position: Vec3; public rotation: Quat; constructor(position: Vec3, rotation: Quat) { this.position = position; this.rotation = rotation; } /** 将调用此方法进行插值。 * @param this 起始曲线值 * @param to 目标曲线值 * @param t 插值比率，取值范围为 [0, 1] * @param dt 起始曲线值和目标曲线值之间的帧时间间隔 */ lerp (to: MyCurveValue, t: number, dt: number) { return new MyCurveValue( // 位置属性不插值 this.position.clone(), // 旋转属性使用 Quat 的 lerp() 方法 this.rotation.lerp(to.rotation, t), // ); } /** 此方法在不插值时调用。 * 它是可选的，若未定义此方法，则使用曲线值本身（即 `this`）作为结果值。 */ getNoLerp () { return this; } } /** * 创建了一条曲线，它实现了在整个周期内平滑地旋转但是骤然地变换位置。 */ function createMyCurve (): IPropertyCurveData { const rotation1 = quat(); const rotation2 = quat(); const rotation3 = quat(); vmath.quat.rotateY(rotation1, rotation1, 0); vmath.quat.rotateY(rotation2, rotation2, Math.PI); vmath.quat.rotateY(rotation3, rotation3, 0); return { keys: 0 /* 帧时间 */, values: [ new MyCurveValue(v3(0), rotation1), new MyCurveValue(v3(10), rotation2), new MyCurveValue(v3(0), rotation3), ], }; } 渐变方式和插值方式都影响着动画的平滑度。 循环模式 可以通过设置 AnimationClip.wrapMode 为动画剪辑设置不同的循环模式。 以下列出出了几种常用的循环模式： AnimationClip.wrapMode 效果 WrapMode.Normal 播放到结尾后停止。 WrapMode.Loop 循环播放。 WrapMode.PingPng 从动画开头播放到结尾后，从结尾开始反向播放到开头，如此循环 对于更多的循环模式，见 WrapMode。 1 动画剪辑的所在结点是指引用该动画剪辑的动画状态对象所在动画组件所附加的结点。 ↩ 2 对于数值、四元数以及各种向量，Cocos 提供了相应的可插值类以实现三次样条插值。 ↩ "},"engine/animation/skeletal-animation.html":{"url":"engine/animation/skeletal-animation.html","title":"骨骼动画","keywords":"","body":"骨骼动画 骨骼动画是一种常见但类型特殊的动画，我们提供两套系统，针对不同方向的需求，分别优化。 这两套系统的唯一开关就是 SkeletalAnimationComponent 上的 useBakedAnimation 开关， 启用对应预烘焙骨骼动画系统，禁用后对应实时计算骨骼动画系统，运行时也可以无缝切换。 预烘焙骨骼动画系统 这个系统的压倒性目的是性能，部分表现力的牺牲也被认为是可以接受的。 我们针对性地做了很多底层优化，目前的运行时流程大致如下： 所有动画数据都会按照指定帧率提前预采样、烘焙到全局复用的骨骼动画贴图合集上； 根据运行平台是否支持浮点纹理，会对应使用 RGBA32F 或 RGBA8 格式的 fallback；（这层用户不必关心，不对最终表现有影响，只是低端平台最后的保底策略） 每个骨骼动画组件（SkeletalAnimationComponent）负责维护当前的播放进度，以 UBO（一个 vec4）的形式存储； 各蒙皮模型组件（SkinningModelComponent）持有预烘焙蒙皮模型类（BakedSkinningModel）， 根据同样提前烘焙好的包围盒信息计算 culling，更新 UBO，在 GPU 上从贴图合集内取到当前数据完成蒙皮。 实时计算骨骼动画系统 这个系统的压倒性目的是表现力，确保所有细节的正确显示，和完整的程序控制能力。 目前的运行时流程大致如下： 所有动画数据根据当前全局时间动态插值计算； 动画数据会输出到场景的骨骼节点树中； 用户和其他任何系统都可以通过操纵这个骨骼节点树对蒙皮效果产生影响； 各蒙皮模型组件（SkinningModelComponent）持有普通蒙皮模型类（SkinningModel）， 每帧提取骨骼节点树信息计算 culling，将当前帧完整骨骼变换信息上传 UBO，在 GPU 内完成蒙皮。 这为以下所有功能提供了最基础的支撑： blendshape 支持； 任意数量动画片段的混合和 masking； IK、二级物理影响； 纯程序控制关节位置； 两套系统的选择与最佳实践 目前所有模型资源在导入后，prefab 中全部默认使用预烘焙系统，以达到最佳性能； 我们建议只在明显感到预烘焙系统的表现力无法达标的情况下，再使用实时计算系统； 虽然两套系统可以在运行时无缝切换，但尽量不要高频执行，因为每次切换都涉及底层渲染数据的重建； 蒙皮算法 我们内置提供两种常见标准蒙皮算法，它们性能相近，只对最终表现有影响： LBS（线性混合蒙皮）：骨骼信息以 3x4 矩阵形式存储，直接对矩阵线性插值实现蒙皮，有体积损失等典型已知问题； DQS（双四元数蒙皮）：骨骼信息以双四元数形式插值，对不含有缩放变换的骨骼动画效果更精确自然，但出于性能考虑，对所有缩放动画有近似简化处理。 引擎默认使用 LBS，可以通过修改引擎 skeletal-animation-utils.ts 的 updateJointData 函数引用与 cc-skinning.chunk 中的头文件引用来切换蒙皮算法； 推荐对蒙皮动画质量有较高追求的项目可以尝试启用 DQS，但因 GLSL 400 之前都没有 fma 指令，如 cross 等操作在某些 GPU 上无法绕过浮点抵消问题，误差较大，可能引入部分可见瑕疵。 挂点系统 如果需要将某些外部节点挂到指定的骨骼关节上，需要使用骨骼动画组件的挂点（Socket）系统： 在要对接的骨骼动画组件下新建一个子节点（直属 parent 应为动画组件所在节点）； 在骨骼动画组件的 sockets 属性中添加一个数组元素，path 从下拉列表中选择要挂接的那根骨骼的路径（注意骨骼动画组件的 defaultClip 一定要有值，下拉列表的选项依赖这个属性），target 指定为刚刚创建的子节点； 这个子节点就成为目标挂点了，可以把任何外部节点放到这个子节点下，都会跟随指定骨骼变换了。 FBX 或 glTF 资源内的挂点模型会自动对接挂点系统，无需任何手动操作。 关于动态 Instancing 基于预烘焙系统的框架设计，蒙皮模型的 instancing 也成为了触手可及的功能，但要保证正确性还需要收集一些比较底层的信息。 这里的根本问题是，同一个 drawcall 内的各个模型使用的骨骼贴图必须是同一张，如果不是同一张，显示效果会完全错乱。 所以如何将动画数据分配到每张骨骼贴图上，就成为了一个需要用户自定义的信息，对应在编辑器项目设置的 骨骼贴图布局面板 进行配置。 注意：只有预烘焙系统下支持 instancing，我们虽然没有严格禁止实时计算框架下启用 instancing（只有编辑器内的警告），但动画效果一定会有问题，取决于模型实际的材质分配情况，最好的情况是不同 instance 间显示完全一致的动画，最坏情况下会导致模型完全错乱。 注意：对材质中已经开启 instancing 的模型，平面阴影系统也会自动同步使用 instancing 绘制。特别地，蒙皮模型的阴影合批对骨骼贴图布局的要求更高一些，因为阴影的管线状态是统一的，所有开启阴影的蒙皮模型的动画都需要保证在同一张贴图上（相比与绘制模型本身时，只需要相同 drawcall 内的 instance 之间保持骨骼贴图一致）。 批量蒙皮模型组件 目前底层上传 GPU 的骨骼纹理已做到全局自动合批复用，上层数据目前可以通过使用 批量蒙皮模型组件（BatchedSkinningModelComponent）将同一个骨骼动画组件控制的所有子蒙皮模型合并： 合批版 effect 书写相对复杂一点，但基本可以基于子材质使用的普通 effect，加入一些相对直接的预处理和接口改动即可，编辑器内的内置资源里 (util/batched-unlit) 提供了一个合批版 builtin-unlit，可以参考。 注意：只有预烘焙系统下使用批量蒙皮模型组件可以保证正确性，实时计算框架下虽然也能使用，但合并后的骨骼数量超过 30 根（Uniform 数组最大数量限制）时会有渲染问题。 "},"tween/":{"url":"tween/","title":"缓动","keywords":"","body":"缓动系统 为了全面兼容和保持 Cocos Creator 2D 缓动系统的使用体验，在v1.1版本 Cocos Creator 3D 移植了所有的 Cocos Creator 2D 功能实现。 注：action已经被废弃了，请使用tween; 注：在v1.0.3版本开始将不再依赖tween.js，如果使用了tween.js的相关特性，请注意及时适配； 注：在v1.0.4版本开始，to和by的可选属性中增加了onStart，onUpdate，onComplete回调; 与此前tween.js不同的地方主要是可选属性，为以下内容： easing 的值定义变动了（这里做了兼容性处理） 除了 easing、onStart、onUpdate、onComplete，其它属性暂不支持（这里做了检查，控制台会有相应的警告） 简单示例 import { _decorator, Component, Vec3, tween } from \"cc\"; @ccclass(\"tween-test\") export class tweentest extends Component { private _pos: Vec3 = new Vec3(0, 0, 0); start () { /** 缓动 _pos */ tween(this._pos) .to(3, new Vec3(10, 10, 10), { easing: 'bounceInOut' }) .to(3, new Vec3(0, 0, 0), { easing: 'elasticOut' }) .union() .repeat(2) // 执行 2 次 .start(); /** 缓动 Node，这里将缓动 Node 的 position 属性 */ tween(this.node) .to(3, { position: new Vec3(10, 10, 10) }, { easing: 'bounceInOut' }) .to(3, { position: new Vec3(0, 0, 0) }, { easing: 'elasticOut' }) .union() .repeat(2) // 执行 2 次 .start(); } } 注意事项 repeat 语义 此前repeat的语义为重复几次，为了全面保持 Creator 2D 的设计，所以现在repeat为执行几次，即repeat(1)代表执行一次。 一些限制 为了降低更新Node Transform信息的频率，Node内部维护了一个dirty状态，只有在调用了可能会改变 Node Transform信息的接口，才会将dirty置为需要更新的状态。 但目前的接口存在一定的限制，例如：通过this.node.position获取到的position是一个通用的Vec3。 当执行this.node.position.x = 1这段代码的时候，只执行了position的getter，并没有执行position的setter。由于dirty并没有更新，便会导致渲染时使用的节点的Transform信息没有更新。 目前，我们也不支持这样的调用，而是鼓励使用setPosition或position的setter，即以下代码方式： let _pos = new Vec3(0, 1, 0); this.node.position = _pos; // 这里将通过 position 的 setter this.node.setPosition(_pos); // 这里将通过接口 setPosition 正确的缓动方式 在新的Tween模块中可以对具有getter和setter的属性进行缓动，例如简单示例中node的position属性，这样在缓动的过程中，会进行相应的接口进行设置，从而保证dirty正常更新。 注：切换场景时注意停止相应的缓动； Tween 接口介绍 接口 解释 to 添加一个对属性进行绝对值计算的间隔动作 by 添加一个对属性进行相对值计算的间隔动作 set 添加一个直接设置目标属性的瞬时动作 delay 添加一个延迟时间的瞬时动作 call 添加一个调用回调的瞬时动作 target 添加一个直接设置缓动目标的瞬时动作 union 将上下文的缓动动作打包成一个 then 插入一个 Tween 到缓动队列中 repeat 执行几次（此前为重复几次，请及时适配） repeatForever 一直重复执行 sequence 添加一个顺序执行的缓动 parallel 添加一个同时进行的缓动 start 启动缓动 stop 停止缓动 clone 克隆缓动 show 启用节点链上的渲染，缓动目标需要为 Node hide 禁用节点链上的渲染，缓动目标需要为 Node removeSelf 将节点移出场景树，缓动目标需要为 Node to 和 by 的可选属性 定义如下: interface ITweenOption { easing?: TweenEasing | ((k: number) => number); progress?: (start: number, end: number, current: number, ratio: number) => number; onStart?: (target: object) => {}; onUpdate?: (target: object, ratio: number) => {}; onComplete?: (target: object) => {}; } 与 Creator 2D 不同的是新增了onStart，onUpdate，onComplete等属性，这些属性是回调函数，调用时会传入缓动的目标。 另外, onUpdate调用时还会多传入一个目前缓动的进行值，范围为(0-1]。 回调的使用范例 以onUpdate为例，以下代码缓动一个位置，然后在onUpdate中将其设置到多个对象上，这样就像是缓动的合批。 import { Node, tween, Vec3 } from \"cc\"; const nodeArray: Node[] = []; // 此处替换成你的节点数组 const tweenTagertVec3 = new Vec3(); tween(tweenTagertVec3) .by(1, new Vec3(1, 1, 1), { 'onUpdate': (target: Vec3, ratio: number) => { for (let i = 0; i 自动销毁 从v1.0.4版本开始，当缓动目标为Node时，将会监听其销毁事件进行缓动的自动销毁，调用target方法也会自动更新监听。 相关测试例test-case-3d。 更多详细介绍，请参考 Creator 的使用缓动系统。 "},"physics/physics.html":{"url":"physics/physics.html","title":"物理","keywords":"","body":"物理简介 Cocos Creator 3D 目前支持轻量的碰撞检测系统builtin和具有物理模拟的物理引擎cannon.js，以及功能完善强大的bullet的asm.js/wasm版本ammo.js，并为用户提供了高效的组件化工作流程和便捷的使用方法。 物理世界和元素 物理世界中的元素可以分为一个个的刚体，在 Cocos Creator 3D 中加入物理元素可以通过为游戏对象添加碰撞器（Collider）或者刚体（RigidBody）组件，物理系统将为这些元素进行物理计算，使其表现出真实世界下的行为。 注：此处的“刚体”不是指刚体组件，刚体组件用于控制刚体物理行为相关的属性。 添加物理元素 在世界中添加一个物理元素可以分为以下步骤： 新建一个形状 Cube； 在右侧 Inspector 面板上点击 Add Component； 在 Physics 目录下选择 BoxColliderComponent, 并调整参数； 为了使它具有物理行为，接着添加一个 RigidBodyComponent 组件。 这样，便有了一个既有碰撞器又有物理行为的一个物理元素。 完善物理世界 接着，完善物理世界，可以为世界添加一个地面，仿照 1，2，3 步骤，可以再添加一个只有碰撞器的Plane； 然后，再调整摄像机的角度（选中摄像机，执行Ctrl + Shift + F可以对齐到屏幕）； 最后，点击运行按钮，便可以看到物理元素在场景世界上的变化， 最后的场景如下图所示： 注：通过调整组件的属性值，直接点击刷新按钮，即可在刚刚运行的浏览器上看到新的预览。 物理元素的组成 在 Cocos Creator 3D 中，一个物理元素可以由以下几种方式组成： 一个刚体组件 一个或多个碰撞器组件 一个刚体加一个或多个碰撞器组件 更详细的模块 Cocos Creator 3D 的物理系统的更多内容将通过以下模块来进行更详细的介绍： 模块 描述 物理选项 介绍了 Cocos Creator 3D 中可选的底层物理引擎选项 物理系统 介绍了物理系统，以及物理系统的一系列属性和接口 物理组件 介绍了一些物理组件以及面板上的一系列属性 物理使用 进一步介绍了物理相关的使用，事件、分组掩码等 继续前往 物理选项 说明文档。 "},"physics/physics-item.html":{"url":"physics/physics-item.html","title":"物理选项","keywords":"","body":"选择适合你项目的物理系统 在编辑器中选择 项目->项目设置->模块选项 中，您可以选择适合项目需求的物理引擎进行开发。 注：默认为cannon.js物理引擎。 注：开发过程中物理引擎可随意切换。 碰撞检测:builtin builtin 仅有碰撞检测的功能，相对于其它的物理引擎，它没有复杂的物理模拟计算。如果您的项目不需要这一部分的物理模拟，那么可以考虑使用builtin ，这将使得游戏的包体更小。 若使用builtin 进行开发，请注意以下几点： builtin只有trigger类型的事件。 RigidbodyComponent无效。 ColliderComponent中的isTrigger无论值真假，都为触发器。 物理引擎:cannon.js cannon.js 是一个开源的物理引擎，它使用 js 语言开发并实现了比较全面的物理功能，如果您的项目需要更多复杂的物理功能，那么您可以考虑使用 cannon.js。cannon.js模块大小为141KB。 物理引擎:ammo.js ammo.js 是 bullet 物理引擎的 asm.js / wasm 版本（目前仅提供了 asm.js 版本），由 emscripten 工具编译而来。Bullet 具有完善的物理功能，未来我们也将在此投入更多工作。 需要注意的是，目前ammo.js模块具有1MB左右的大小。 不使用物理 若不需要用到任何物理相关的组件和接口，可以取消黄色框的勾选，这样在发布时将有更小的包体。 注：若处于取消勾选的状态，项目将不可以使用物理相关的组件和接口，否则运行时将会报错。 继续前往 物理系统 说明文档。 "},"physics/physics-system.html":{"url":"physics/physics-system.html","title":"物理系统","keywords":"","body":"物理系统 物理系统（PhysicsSystem）用于管理所有物理相关的功能，目前它负责同步物理元素、触发物理事件和调度物理世界的迭代。 物理世界 物理世界迭代时会对物理元素进行物理计算，比如计算各物体是否产生碰撞，以及物体的受力情况。当计算完成后，物理系统会将物理世界更新到场景世界中，从而使游戏对象产生相应的物理行为。 目前 Cocos Creator 3D 的物理执行流程：触发物理事件 -> 场景同步到物理 -> 物理世界迭代 -> 物理同步到场景。 注：目前只有单一的物理世界，后续会探讨多物理世界的功能支持。 场景世界与物理世界： 物理系统的属性 目前物理系统的属性暂时只能通过代码进行设置，后续将会增加设置面板，请留意更新公告。 属性 解释 enable 是否开启物理系统，默认为true allowSleep 是否允许物理系统自动休眠，默认为true useFixedTime 物理模拟是否使用固定的时间进行模拟（步数将固定为1），默认为true maxSubStep 物理每帧模拟的最大子步数，默认为2 deltaTime 物理每步模拟消耗的时间，默认为1/60，注意不是每帧 gravity 物理世界的重力值，默认为 (0, -10, 0) defaultMaterial 获取默认物理材质（只读） 获取物理系统实例： PhysicsSystem.instance 继续前往 物理组件 说明文档。 "},"physics/physics-component.html":{"url":"physics/physics-component.html","title":"物理组件","keywords":"","body":"物理组件 Cocos Creator 3D 目前为用户提供了多种碰撞器组件和通用的刚体组件，以及工具类的恒力组件。 注：更多功能组件将会在后续版本持续发布，请留意版本更新公告。 碰撞器组件 碰撞器组件用于表示刚体的碰撞体形状，不同的几何形状拥有不同的属性。 注：以下属性名称的首字母在实际代码中都为小写。 盒碰撞器组件（BoxColliderComponent） 属性 解释 material 碰撞器引用的物理材质（为空时引用物理系统的默认物理材质） isTrigger 是否为触发器，触发器不会产生物理反馈 center 本地坐标系下形状的原点 size 盒的大小，即长、宽、高 球碰撞器组件（SphereColliderComponent） 属性 解释（其它参考盒碰撞器） radius 球的半径 圆柱体碰撞器组件（CylinderColliderComponent） 属性 解释（其它参考盒碰撞器） direction 圆柱体延申方向的参考轴 height 圆柱体的总高度 radius 圆柱体两端圆面的半径 注：builtin暂不支持圆柱体组件。 胶囊体碰撞器组件（CapsuleColliderComponent） 属性 解释（其它参考圆柱体和盒碰撞器） cylinderHeight 胶囊体中圆柱体的高度 radius 胶囊体中球体的半径 注：cannon.js不支持胶囊体组件，建议使用两个球和圆柱体拼凑。 网格碰撞器组件（MeshColliderComponent） 属性 解释（其它参考盒碰撞器） mesh 网格碰撞器引用的网格资源，用于初始化网格碰撞体 注：builtin暂不支持网格碰撞器组件。 注：cannon.js对网格碰撞器组件支持程度很差，只允许与球碰撞器产生检测。 注：ammo.js目前只支持静态网格碰撞体（mass为0或无RigidBody组件的）。 刚体组件（RigidBodyComponent） 为了更便捷的模拟物理行为，Cocos Creator 3D为用户提供了刚体组件，预览图如下： 属性 解释（上图的属性值都是默认值） mass 物体的质量（当质量为 0 时代表静态刚体，和不加刚体组件的效果一样） linearDamping 线性阻尼，用于减小物体的线性速率 angularDamping 角阻尼，用于减小物体的旋转速率 isKinematic 是否由用户来控制该刚体，而不受物理引擎的影响 useGravity 是否受重力影响 fixedRotation 碰撞时是否需要固定物体，而不产生旋转 linerFactor 线性因数，可影响每个轴向的线性速度的变化 angularFactor 旋转因数，可影响每个轴向的旋转速度的变化 注：builtin暂不支持刚体组件。 恒力组件（ConstantForce） 这是一个工具组件，它依赖刚体组件，将会在每帧对一个刚体施加给定的力和扭矩。 属性 解释 force 在世界坐标系中对刚体施加的力 localForce 在本地坐标系中对刚体施加的力 torque 在世界坐标系中对刚体施加的扭矩 localTorque 在本地坐标系中对刚体施加的扭矩 注：builtin暂不支持恒力组件。 继续前往 物理使用 说明文档。 "},"physics/physics-use.html":{"url":"physics/physics-use.html","title":"使用物理","keywords":"","body":"使用物理 为了更好的介绍如何使用物理，将通过以下模块进行介绍： 模块 描述 碰撞组件 介绍了Collider组件的设计，以及与RigidBody组件的关系 物理材质 介绍了 Cocos Creator 3D 中的物理材质资源 刚体组件 介绍了RigidBody组件的一些代码使用示例 物理事件 介绍了 Cocos Creator 3D 中的物理事件 分组掩码 介绍了物理过滤检测中分组掩码的使用 射线检测 介绍了对物理碰撞器的射线检测功能 继续前往 碰撞组件 说明文档。 或者回到 物理简介。 "},"physics/physics-collider.html":{"url":"physics/physics-collider.html","title":"使用碰撞器","keywords":"","body":"碰撞组件 获取碰撞器组件 Cocos Creator 3D 目前支持两种语言进行开发，分别为JavaScript和TypeScript。 注：TypeScript具有良好的语法分析和类型提示，推荐使用。 以获取BoxColliderComponent为例，在JavaScript中获取Collider组件： this.getComponent('cc.BoxColliderComponent') this.getComponent(cc.BoxColliderComponent) 在TypeScript中获取Collider组件： 上述JavaScript使用的方式 this.getComponent(BoxColliderComponent) (推荐使用，提示导入时，注意导入位置为cc) 注：若无智能导入提示，请检查工作目录是不是在工程的顶层，以及是否使用较新的VSCode编辑器。 碰撞器和触发器 Collider组件具有isTrigger属性，当isTrigger为true时，表示为触发器，反之为碰撞器。 注：关于碰撞器和触发器的区别将在 物理事件 中介绍。 Collider和RigidBody的关系 首先，Collider和RigidBody组件都是为了服务于物理元素，分别操控着物理元素上的一部分属性。这也意味着要了解它们之间的关系，需要先了解 Cocos Creator 3D 中的物理元素是如何构成的。 元素如何构成 在物理简介中，介绍了一个物理元素是由Collider和RigidBody组件相互组合而成的，其中指出了物理元素只能有一个或零个RigidBody组件，并且可以有多个Collider组件。 单个节点是很容易看出是否有物理元素的，但如果我们以节点链为单位，这样将会很难看出物理元素是由哪些节点以及哪些组件组成的。 对于节点链的情况，目前有两个思路： 每个节点只要有物理组件，就是一个元素，也就是说父子节点的组件无依赖关系，需要多个形状，往该节点上添加相应的Collider组件。 从自身节点开始往父链节点上搜索，如果找到了RigidBody组件，则将自身的Collider组件绑定到该节点上，否则整条链上的Collider组件将共享一个RigidBody组件，元素对应的节点是最顶层的Collider组件所对应的节点。 这两个思路各有利弊： 思路一不够直观，多个形状只能往一个节点上加，显示形状需要增加子节点模型。 思路一调整参数时，需要调整两个地方，分别为子节点的位置信息和父节点上对应Collider组件的数据信息。 思路二增加了节点耦合，节点更新时，需要更新相应的依赖节点。 思路二在节点链被破坏时，需要维护内容更多，节点链在反复被破坏时需要处理复杂的逻辑。 注：Cocos Creator 3D 的物理目前使用的是思路一，后续可能会进行调整，请留意版本更新公告。 Collider的attachedRigidbody属性 在Collider组件中具有attachedRigidbody属性，此属性可获得当前Collider组件所绑定的RigidBody组件，但是请注意以下几点： 在自身节点无RigidBody组件时，该属性返回为null。 attachedRigidbody是一个只读的属性。 自动缩放 每一个组件都会绑定一个节点，有些组件会根据绑定的节点动态更新数据，碰撞体组件会根据节点信息自动更新相应的形状数据，让碰撞体可以更方便的贴合渲染模型。 更新数据，以模型组件举例： 模型组件会根据绑定节点自动更新模型的世界矩阵，从而实现改变节点的位置、缩放、旋转等信息，可以使渲染的模型有相应仿射变换。 但碰撞体的有些性质导致缩放的处理不太一样： 碰撞体一般用几何结构来描述 碰撞体大部分都是凸包类型 这些性质限制了切变、非均一缩放等变换，以球举例： 假设绑定节点的缩放信息是(1,2,1)(非均一缩放)，由于模型和碰撞体描述的结构不一样，球模型使用多个基础图元（如三角面）来表示，缩放后会形变成类似于鹅卵石的形状；但球碰撞体的使用半径大小来描述，缩放时会取数值最大的维度来缩放半径（来保证碰撞体可以尽可能的包围住模型），但缩放后还是一个球。 物理材质 碰撞体拥有物理材质属性，相关内容在物理材质中有详细介绍，这里主要介绍共享和非共享的接口区别。 目前Collider组件提供了两个属性去访问和设置，分别为material和sharedMaterial，它们的区别主要如下： 设置sharedMaterial或者material是一样的效果，在没有调用这些接口之前是共享状态，当发现设置的与当前引用不是同一实例时，后面获取material将不会生成新的材质实例，此时是非共享状态。 在共享状态前提下，获取material将会生成新的材质实例，以确保只有当前碰撞体引用了该材质，这样修改时不会影响到其他的碰撞体，之后就是非共享状态了。 获取sharedMaterial不会生成新的，而是直接返回引用。 继续前往 物理材质 说明文档。 "},"physics/physics-material.html":{"url":"physics/physics-material.html","title":"物理材质","keywords":"","body":"物理材质 在 Cocos Creator 3D 中物理材质是一种资源，它记录了物体的表面信息，这些信息用来计算碰撞物体受到的摩擦力和弹力等。 属性 物理材质属性如下图所示： 属性 解释 friction 摩擦系数 restitution 回弹系数 当与其它表面接触时，这些系数用于计算相应的摩擦力和弹力。 创建 物理材质可以通过两种方式创建： 编辑器内创建 代码实例化 用编辑器创建的方式如下图所示： 代码中实例化： let newPmtl = new PhysicMaterial(); newPmtl.friction = 0.1; newPmtl.restitution = 0.1; 应用 目前物理材质以碰撞体为单位进行设置，每个Collider都具有一个material的属性（不设置时，Collider将会引用物理系统中的默认物理材质）。 应用到Collider同样也分编辑器操作和代码操作两种方式。 编辑器内操作，只需要将资源拖入到cc.PhysicMaterial属性框中即可，如下图所示： 代码中操作： const collider = this.node.getComponent(ColliderComponent); collider.material = newPmtl; 因为材质共享的设计，实际在代码中可以直接这样操作（因为在获取 material时会创建一个实例） collider.material.friction = 0.1; collider.material.restitution = 0.1; 继续前往 刚体组件 说明文档。 "},"physics/physics-rigidbody.html":{"url":"physics/physics-rigidbody.html","title":"使用刚体","keywords":"","body":"刚体组件 获取刚体组件 TypeScript的代码示例：const rigidBody = this.getComponent(RigidBodyComponent); 刚体类型 刚体一般分为三种类型，static,dynamic,kinematic. static，表示静态刚体，犹如质量巨大无比的石头，具体为质量为0的，或者只有碰撞组件的物理元素。 dynamic，表示动力学刚体，能够受到力的作用，具体为质量大于0并且isKinematic为false的。 kinematic，表示运动学刚体，由用户来控制该刚体的运动，具体为质量大于0并且isKinematic为true的。 刚体质心 目前质心固定在刚体组件绑定的节点上，质心和碰撞体是相对关系。通过调整形状的偏移center，可以使质心在形状上进行偏移。 注：为了使碰撞体更方便的贴合模型，未来可能会增加改变质心的方法，以及动态计算质心的机制。 休眠和唤醒 代码示例： if (rigidBody.isAwake) { rigidBody.sleep(); } if (rigidBody.isSleeping) { rigidBody.wakeUp(); } 让刚体运动起来 让刚体运动，需要改变刚体的速度，目前改变刚体的速度有以下几种方式： 通过重力 刚体组件提供了useGravity属性，设置为true将受到重力的作用。 通过施加力 刚体组件提供了applyForce接口，签名为：applyForce (force: Vec3, relativePoint?: Vec3)。 根据牛顿第二定律F = m * a，对刚体某点上施加力，这样就有了加速度，随着时间变化，速度会随加速度变化，就会使得刚体运动起来。 代码示例：rigidBody.applyForce(new Vec3(200, 0, 0)); 通过施加扭转力 刚体组件提供了applyTorque接口，签名为：applyTorque (torque: Vec3)。 通过此接口可以施加扭矩到刚体上，因为只影响旋转轴，所以不再需要指定作用点。 通过施加冲量 刚体组件提供了applyImpulse接口，签名为：applyImpulse (impulse: Vec3, relativePoint?: Vec3)。 根据动量守恒的方程式 F * Δt = m * Δv，对刚体某点施加冲量，由于物体的质量是恒定的，速度就会立马变化，刚体就会运动起来。 代码示例：rigidBody.applyImpulse(new Vec3(5, 0, 0)); 通过直接改变速度 线性速度 刚体组件提供了setLinearVelocity接口，可用于改变线性速度，签名为：setLinearVelocity (value: Vec3)。 旋转速度 刚体组件提供了setAngularVelocity接口，可用于改变旋转速度，签名为：setAngularVelocity (value: Vec3)。 代码示例： rigidBody.setLinearVelocity(new Vec3(5, 0, 0)); rigidBody.setAngularVelocity(new Vec3(5, 0, 0)); 限制刚体的运动 通过休眠 休眠刚体时，会将刚体所有的力和速度清空，这将使刚体停下来。 注：执行部分接口，例如施加力或冲量、改变速度、分组和掩码会唤醒刚体。 通过阻尼 刚体组件提供了linearDamping和angularDamping属性，分别用于设置线性和旋转的阻尼。 阻尼参数的范围可以在0到无穷之间，0意味着没有阻尼，无穷意味着满阻尼。 通过固定旋转 刚体组件提供了fixedRotation属性，默认为false，设置为true可以用于固定刚体，使其不会产生旋转。 通过因子 刚体组件提供了linearFactor和angularFactor属性，分别用于设置线性和旋转的因子。 因子是Vec3的类型，相应分量的数值用于缩放相应轴向的速度变化，默认值都为1，代表着缩放为1倍，即无影响。 注：将因子某分量值设置为0，可以固定某个轴向的移动或旋转，如果要完全固定旋转，请用 fixedRotation。 注：在cannon、ammo后端中，因子作用的物理量不同，cannon中作用于速度，ammo中作用于力。 继续前往 物理事件 说明文档。 "},"physics/physics-event.html":{"url":"physics/physics-event.html","title":"物理事件","keywords":"","body":"物理事件 Cocos Creator 3D 的物理事件有触发事件和碰撞事件。 触发器和碰撞器 当碰撞时，触发器不会产生物理行为，而碰撞器会产生物理行为。 因此触发器是只进行碰撞检测的Collider，犹如幽灵一般。而碰撞器是既进行碰撞检测，又进行物理模拟的Collider。 两者的区别 触发器不会与其它触发器或者碰撞器做更精细的检测。 碰撞器与碰撞器会做更精细的检测，并会产生碰撞数据，如碰撞点、法线等。 注：isTrigger属性决定Collider组件是否为触发器。 触发事件和碰撞事件 触发事件 触发事件由触发器生成，目前分为三种 onTriggerEnter、onTriggerStay、onTriggerExit，分别代表着触发开始，触发保持，触发结束。 监听触发事件，需要通过注册事件来添加相应的回调： 通过this.getComponent(ColliderComponent)获取到ColliderComponent 通过ColliderComponent的on或者once方法注册相应事件的回调 代码示例： public start () { let Collider = this.getComponent(ColliderComponent); Collider.on('onTriggerStay', this.onTrigger, this); } private onTrigger (event: ITriggerEvent) { console.log(event.type, event); } 碰撞事件 碰撞事件根据碰撞数据产生，碰撞数据只对动力学刚体产生作用，因此必须要有一个动力学刚体才能产生碰撞事件。 目前碰撞事件分为三种类型 onCollisionEnter、onCollisionStay、onCollisionExit，分别代表着碰撞开始，碰撞保持，碰撞结束。 监听碰撞事件，需要通过注册事件来添加相应的回调： 通过 this.getComponent(ColliderComponent) 获取到 ColliderComponent 通过 ColliderComponent 的 on 或者 once 方法注册相应事件的回调 代码示例： public start () { let Collider = this.getComponent(ColliderComponent); Collider.on('onCollisionStay', this.onCollision, this); } private onCollision (event: ICollisionEvent) { console.log(event.type, event); } 注：ColliderComponent 是所有碰撞组件的父类。 注：目前碰撞事件以物理元素为单位，所有该元素上的碰撞器组件都会接受到碰撞事件。 两者的区别 触发事件由触发器生成，碰撞事件根据碰撞数据生成。 触发事件可以由触发器和另一个触发器或者另一个碰撞器产生。 碰撞事件需要由两个碰撞器产生，并且至少有一个动力学刚体。 继续前往 分组和掩码 说明文档。 "},"physics/physics-group-mask.html":{"url":"physics/physics-group-mask.html","title":"分组和掩码","keywords":"","body":"分组掩码 在 Cocos Creator 3D 中，部分物理组件（目前有刚体组件和碰撞器组件）提供了设置分组和掩码的接口。 共享 在 Cocos Creator 3D 中，目前物理元素和节点是一对一的关系，分组和掩码是属于物理元素的，单个节点上的物理组件修改的都是节点对应物理元素的分组和掩码。 原理 只要以下条件为真就会进行检测 (GroupA & MaskB) && (GroupB & MaskA) 例如：两个物理元素A和B。 A的分组值为1，掩码值为3 B的分组值为2，掩码值为2 算式(1 & 2) && (2 & 3)为假，所以这里A不会和B进行检测。 这里通过B的掩码值为2，可以知道B可检测的组是1，而A在的组是0，所以不检测。 注：表达式依赖位运算，javascript中位运算的操作数是32位的，并且最后一位是符号位，为避免超出运算范围，建议组的范围为[0, 31)。 分组 设置分组值 以下分组值为3，二进制为11，表示在第0，1组（从0开始） const group = (1 获取分组值 Collider.getGroup(); 添加分组值 上述代码基础上，经过以下代码后，分组值为7，二进制为111，所以表示在0，1，2组。 const group = 1 减少分组值 上述代码基础上，经过以下代码后，分组值为3，所以在0，1组。 const group = 1 注：推荐固定在一个组中，可以把节点的layer属性当作组。 注：上述方法接收参数均为十进制数字，为方便理解，此处用二进制解释，开发者熟悉后也可直接传入十进制数字进行分组操作。 掩码 设置掩码值 以下 mask 的值3，二进制为11，表示可检测的组为0，1 。 const mask = (1 获取掩码值 console.log(Collider.getMask()); 添加掩码值 上述代码的基础上，经过以下代码后，增加了一个可检测组3。 const mask = 1 减少掩码值 以下代码去掉了一个可检测组3。 const mask = 1 注：加减符号的优先级高于位移符号。 注：灵活使用分组和掩码可以减少额外检测的消耗。 注：物理系统的分组和掩码可能会延用Node的Layer属性，并提供设置面板，请留意更新公告。 举例 以下列举了一个简单的使用示例： 定义分组 方式一：定义在一个object中 export const PHY_GROUP = { Group0: 1 方式二：定义在一个enum中 （typescript only） enum PHY_GROUP { Group0 = 1 注：这里可以考虑复用Layer中预设的层。 为了能够在面板上设置分组，需要通过cc模块导出的Enum函数，将定义好的分组注册到编辑器中Enum(PHY_GROUP)。 注：由于历史原因，Enum函数对-1有特殊处理，如果不熟悉，请勿定义值为-1的属性。 使用掩码 掩码可以根据分组进行定义，例如以下示例 定义一个只检测Group1的掩码const maskForGroup1 = PHY_GROUP.Group1; 定义一个可检测Group0和Group1的掩码const maskForGroup01 = PHY_GROUP.Group0 + PHY_GROUP.Group1; 定义一个所有组都不检测的掩码const maskForNone = 0; 定义一个所有组都检测的掩码const maskForAll = -1; 查看二进制 在 javascript 的运行环境中通过执行(value >>> 0).toString(2)， 可以看到二进制的字符串表示。 继续前往 射线检测 说明文档。 "},"physics/physics-raycast.html":{"url":"physics/physics-raycast.html","title":"射线检测","keywords":"","body":"射线检测 射线检测是非常重要的功能，常常用来判断各种情况。 其本质是对一条射线和另一个形状进行相交性判断，如下图所示。 构造射线 射线ray处于cc模块的geometry命名空间下，因此访问ray需要先导入geometry： import { geometry } from \"cc\"; 射线ray由起点和方向组成，构造一条射线有以下比较常见的方法： 通过起点+方向，如ray的构造函数或静态接口create： import { geometry } from \"cc\"; const { ray } = geometry; // 构造一条从（0，-1，0）出发，指向 Y 轴的射线 // 前三个参数是起点，后三个参数是方向 const outRay = new ray(0, -1, 0, 0, 1, 0); // 或者通过静态方法 create const outRay2 = ray.create(0, -1, 0, 0, 1, 0); 通过起点+射线上的另一点，如ray的静态接口fromPoints中: import { geometry, Vec3 } from \"cc\"; // 构造一条从原点出发，指向 Z 轴的射线 const outRay = new geometry.ray(); geometry.ray.fromPoints(outRay, Vec3.ZERO, Vec3.UNIT_Z); 用相机构造一条从相机原点到屏幕（或者说相机的近端面）某点发射出的射线： 注：首先需要获取一个相机组件或者相机实例的引用。 注：相机组件和相机实例两者暴露的接口参数顺序不一样。 import { geometry, CameraComponent } from \"cc\"; const { ray } = geometry; // 此处假设已经有 cameraCom 的引用了 const cameraCom: CameraComponent; // 获得一条途径屏幕坐标（0，0）发射出的一条射线 const outRay = new ray(); cameraCom.screenPointToRay(0, 0, outRay); 接口介绍 Cocos Creator 3D 在v1.0.1版本上提供了一套基于物理引擎的射线检测功能。 但需要注意的是，检测的对象是物理碰撞器，在场景面板上与之对应的是碰撞器组件，例如 BoxColliderComponent。 目前接口由PhysicsSystem提供，有以下两类： raycastAll : 检测所有的碰撞体，返回布尔值, 表示是否检测成功。 raycastClosest ：检测所有的碰撞体，同样返回布尔值。 参数解释： worldRay 世界空间下的射线 mask 用于过滤的掩码，可以传入需要检测的分组 maxDistance 最大检测距离，目前请勿传入 Infinity 或 Number.MAX_VALUE queryTrigger 是否检测触发器 获取结果 获取以上接口的检测结果，需分别通过以下方式： 获取 raycastAll 的检测结果：PhysicsSystem.instance.raycastResults 获取 raycastClosest 的检测结果：PhysicsSystem.instance.raycastClosestResult 注：返回对象是只读并且复用的，每次调用检测接口后会更新相应结果。 结果存储的信息 信息由 PhysicsRayResult 进行存储，主要有以下信息： collider 击中的碰撞器 distance 击中点与射线起点的距离 hitPoint 击中点（世界坐标系中） hitNormal 击中点所处面的法线（世界坐标系中)(v1.1版本开始支持，目前builtin暂无此信息） 相关测试例test-case-3d 回到 物理使用 说明文档。 "},"ui-system/components/engine/":{"url":"ui-system/components/engine/","title":"UI","keywords":"","body":"UI 结构说明 UI 采用的是基于树状的渲染结构，整个 UI 的渲染都是基于 Canvas 节点（带有 CanvasComponent 的节点）作为根节点来进行，也就是 UI 节点的最终根节点必须是 Canvas 节点才可以被该 Canvas 渲染。每一个 UI 节点必须带有 UITransformComponent 组件作为点击或者对齐策略等生效的必要条件。 在整体渲染方面，UI 采用了一套独立的渲染管线且优先级是最高的，整个渲染管线会先渲染 3D 部分再渲染 UI。然后 UI 又通过 Canvas 节点的 CanvasComponent 组件上的 priority 来决定渲染顺序。 UI 还支持对模型进行渲染，唯一的条件是带有模型组件（例如 ModelComponent / SkinningModelComponent）的节点必须添加 UI / Model 组件才可以和 UI 在相同的管线上进行渲染。 UI 渲染流程如下： UI 入门 UI 是游戏开发的必要交互部分，一般游戏上的按钮、文字、背景等都是通过 UI 来制作的。在开始制作一款 UI 时，首先需要确定当前设计的内容显示区域大小（设计分辨率），可以在菜单栏的 项目 -> 项目设置 -> 通用设置 面板中设置： 设计分辨率设置完成后，开始创建 UI 元素，所有的 UI 元素都包含在 Canvas 节点下。可以在 层级管理器 面板中点击左上方的 + 按钮，然后选择 UI -> Canvas 来创建 Canvas 节点。Canvas 节点上有一个 CanvasComponent 组件，该组件内部会自动创建一个 camera。开发者可以通过调整 CanvasComponent 上的 RenderMode 属性来实现真正意义上的 3D 相机与 2D 相机的穿插渲染。还可以通过 CanvasComponent 上的 priority 参数来调整多个 Canvas 之间的显示优先级。 注意： 在一个场景中可以存在多个 Canvas 节点，但是 Canvas 节点不应该嵌套在另一个 Canvas 节点或其子节点下。 priority 的修改是在运行时生效，而编辑器中还是按照 Canvas 节点的先后来显示渲染内容。 在介绍了 UI 的关键内容后，接下来就可以在 Canvas 节点下按照项目设计结构创建 UI 节点了。编辑器默认自带的 UI 节点有以下几种： 可以通过选中节点，在 属性检查器 面板中点击 添加组件 来查看 UI 组件。UI -> Render 中的组件属于 UI 渲染组件，其余都是 UI 功能组件。 UI 渲染组件的先后顺序采用的是广度排序方案，也就是 Canvas 节点下的子节点的排序就已经决定了之后的整个 渲染排序，不过可以通过渲染组件上的 priority 属性修改渲染排序。而对于没有渲染组件的节点，可以通过在 属性检查器 中选择 添加组件 -> UI -> Reorder 来添加一个只带有排序功能的组件来排序。 在一般的游戏开发中，必要的 UI 元素一般是 Sprite（精灵图）、Label（文字）、Mask（遮罩）、Layout（布局）、Widget（对齐）等。其中 Sprite 和 Label 用于渲染图片和文字。Mask 主要用于限制显示内容，比较常用的地方是一些聊天框和背包等。Layout 主要用于排版，一般用于按钮单一排列，背包内道具整齐排列等。最后一个比较重要的功能其实是 Widget，主要用于显示对齐。这里可能涉及到另外一个功能，那就是多分辨率适配，在我们设计完 UI 需要发布到不同平台时，势必会出现平台的实际设备分辨率和我们的设计分辨率不符的情况，这个时候为了适配不得不做一些取舍，比如头像框，是不能做缩放的，但是我们又希望它没有很大程度受设备影响，那么我们则需要为它添加上 Widget 组件，并且始终保证它对齐在我们的设计分辨率的左上方，具体参考：对齐策略 和 对齐。 当我们的界面制作完成之后，可能有人会发现，怎么发布 Iphone7 和 IphoneX 的显示效果不一样？这个其实也是我们上面提到的设备分辨率的问题。在你以设计分辨率设计，最终以设备分辨率发布的时候，因为不同型号的手机设计分辨率可能不一致，这中间存在像素偏差的问题，因此，还需要做的一道转换工序那就是屏幕适配。在菜单栏的 项目 -> 项目设置 -> 通用设置 -> 默认 Canvas 设置 页面中可以看到，还有两个选项是 适配屏幕宽度 / 适配屏幕高度，按照 Cocos Creator 3D 提供的屏幕适配规则再结合 Widget 组件，就可以实现不同设备的轻松适配。具体适配说明可参考 多分辨率适配方案。 UI 规则介绍 渲染排序规则 多分辨率适配方案 对齐策略 文字排版 自动布局容器 制作动态生成内容的列表 制作可任意拉伸的 UI 图像 UI 静态合批组件 "},"ui-system/components/engine/priority.html":{"url":"ui-system/components/engine/priority.html","title":"渲染排序规则","keywords":"","body":"渲染排序说明 1. UI 节点排序 UI 的渲染排序采用的是一个广度优先的排序方式，每一个渲染组件（例如：SpriteComponent）身上都有一个 priority 属性。排序从根节点下的子节点开始，根据子节点的优先级来确定整体的渲染结构，也就是根节点下的子节点的渲染排序已经决定了最终的渲染顺序。每一个节点下的所有子节点的 priority 则用来确定在当前节点下的渲染顺序。 举个例子： 从图中可以看出有一些节点虽然没有渲染组件，但是它的子节点能参与排序，因此该节点也需要参与到排序中。整体的渲染顺序则是：B -> b1 -> C -> A -> a1 -> a2，在屏幕上的呈现状态为：a2 -> a1 -> A -> C -> b1 -> B。由于我们最终会根据 priority 进行节点排序，所以最终呈现给用户的节点顺序就是最终的渲染排序。 针对没有渲染组件但是也想要进行排序的节点，提供了 UIReorderComponent 组件来帮助控制排序。 2. 相机混合排序 UI 相机在最初设计的时候优先级是最高的，也就是所有的 3D 内容绘制完之后 UI 相机内容才开始绘制。但是，这样就会导致一个问题，UI 相机一旦有了背景之类的，就会把 3D 的内容覆盖掉。因此，相机间的混排功能必不可少。 UI 相机与 3D 相机混排的关键因素是在 UI 相机这里。因此，我们在 UI 的根节点，也就是 Canvas 节点上的 CanvasComponent 组件提供了一个叫 RenderMode 属性用来区别排序方式。接下来说一下 RenderMode 选项的作用： 当选择模式是 OVERLAY，则代表 UI 相机始终会往 3D 相机后排，也就是始终会覆盖在 3D 相机的渲染内容之上。多个 UI 相机选择此模式，可以通过属性 Priority 来进行 UI 相机之间排序。 当选择模式是 INTERSPERSE，则代表此时他可以与 3D 相机进行混排，UI、3D 相机之间的排序方式也是分别通过设置 CanvasComponent 上的 Priority 和 CameraComponent 上的 Priority 进行。 注意事项 排序是一个很简单的功能，但是最终的呈现却是根据不同平台提供的渲染能力来的。因此，在这里说明一下，如果遇到了 UI 渲染出错，花屏，闪屏等现象，首先要检查的就是场景里所有相机（CameraComponent 和 CanvasComponent）的 ClearFlag，确保 场景里必须有一个相机要执行 Solid_Color 清屏操作。 具体如何设置 ClearFlag，可参考以下几种情况： 如果场景中只有一个 UI Canvas 或者 3D Camera，那么 ClearFlag 属性设置为 Solid_Color。 如果场景中包含 UI 背景层、3D 场景层、 UI 操作层，则： 2D 背景层：ClearFlag 属性设置为 Solid_Color。 3D 场景层：ClearFlag 属性设置为 Depth_Only。 2D UI 层：若有模型，ClearFlag 属性设置为 Depth_Only 以避免出现模型闪屏或者穿透的情况。若没有模型，ClearFlag 属性可设置为 Dont_Clear 或 Depth_Only。 UI 结构介绍 "},"ui-system/components/engine/ui-batch.html":{"url":"ui-system/components/engine/ui-batch.html","title":"UI 合批说明","keywords":"","body":"UI 合批规则说明 UI 合批采用的是同哈希材质同贴图原则进行合批。同哈希的意思是即使使用的是相同的材质，如果它们的哈希值不一样，还是会打断合批，就比如两个材质启用的宏涉及到 Uniform 的使用，导致不能合批。精灵和文本也是一样，因为贴图不一致。当然，在严格控制的情况下也是可以一个图集的，但这是后话。 UI 的渲染数据采集是一个基于节点树的渲染方式，因此，在你递归节点树的过程中如果遇到 UIModelComponent，MaskComponent，GraphaicsComponent 这三个组件，是一定会打断合批的，如果出现前后采用的贴图不一样，也会打断合批，所以我们建议分模块制作，独立模块的贴图进行合图，来减少 DrawCall，但要达到大量数据的合批，就需要严格进行节点布局。 "},"ui-system/components/engine/multi-resolution.html":{"url":"ui-system/components/engine/multi-resolution.html","title":"多分辨率适配方案","keywords":"","body":"多分辨率适配方案 Cocos Creator 3D 在整体设计上沿用了 Cocos Creator 一套资源适配多种分辨率屏幕的方案。简单概括来说，我们通过以下几个部分完成多分辨率适配解决方案： Canvas（画布） 组件随时获得设备屏幕的实际分辨率并对场景中所有渲染元素进行适当的缩放。 Widget（对齐挂件） 放置在渲染元素上，能够根据需要将元素对齐父节点的不同参考位置。 Label（文字） 组件内置了提供各种动态文字排版模式的功能，当文字的约束框由于 Widget 对齐要求发生变化时，文字会根据需要呈现完美的排版效果。 Sliced Sprite（九宫格精灵图） 则提供了可任意指定尺寸的图像，同样可以满足各式各样的对齐要求，在任何屏幕分辨率上都显示高精度的图像。 接下来我们首先了解设计分辨率、屏幕分辨率的概念，才能理解 Canvas（画布） 组件的缩放作用。 设计分辨率和屏幕分辨率 设计分辨率 是内容生产者在制作场景时使用的分辨率蓝本，而 屏幕分辨率 是游戏在设备上运行时的实际屏幕显示分辨率。 通常设计分辨率会采用市场目标群体中使用率最高的设备的屏幕分辨率，比如目前安卓设备中 800 x 480 和 1280 x 720 两种屏幕分辨率，或 iOS 设备中 1136 x 640 和 960 x 640 两种屏幕分辨率。这样当美术或策划使用设计分辨率设置好场景后，就可以自动适配最主要的目标人群设备。 那么当设计分辨率和屏幕分辨率出现差异时，会如何进行适配呢？ 假设我们的设计分辨率为 800 x 480， 美术制作了一个同样分辨率大小的背景图像。 设计分辨率和屏幕分辨率宽高比相同 在屏幕分辨率的宽高比和设计分辨率相同时，假如屏幕分辨率是 1600 x 960，正好将背景图像放大 1600/800 = 2 倍 就可以完美适配屏幕。这是最简单的情况，这里不再赘述。 设计分辨率宽高比大于屏幕分辨率，适配高度避免黑边 假设屏幕分辨率是 1024 x 768，在下图中以红色方框表示设备屏幕可见区域。我们使用 Canvas 组件提供的的 适配高度（Fit Height）模式，将设计分辨率的高度自动撑满屏幕高度，也就是将场景图像放大到 768/480 = 1.6 倍。 这是设计分辨率宽高比大于屏幕分辨率时比较理想的适配模式，如上图所示，虽然屏幕两边会裁剪掉一部分背景图，但能够保证屏幕可见区域内不出现任何穿帮或黑边。之后可以通过 Widget（对齐挂件）调整 UI 元素的位置，来保证 UI 元素出现在屏幕可见区域里，我们在下一节 对齐策略 中将会详细介绍。 设计分辨率宽高比小于屏幕分辨率，适配宽度避免黑边 假设屏幕分辨率是 1920 x 960，同样在下图中以红色方框表示设备屏幕可见区域。我们使用 Canvas 组件提供的 适配宽度（Fit Width）模式，将设计分辨率的宽度自动撑满屏幕宽度，也就是将场景放大 1920/800 = 2.4 倍。 在设计分辨率宽高比较小时，使用这种模式会裁剪掉屏幕上下一部分背景图。 不管屏幕宽高比如何，完整显示设计分辨率中的所有内容，允许出现黑边 最后一个例子，我们屏幕分辨率假设为 640 x 960 的竖屏，如果要确保背景图像完整的在屏幕中显示，需要同时开启 Canvas 组件中的 适配高度 和 适配宽度，这时场景图像的缩放比例是按照屏幕分辨率中较小的一维来计算的，在下图的例子中，由于屏幕宽高比小于 1，就会以宽度为准计算缩放倍率，即 640/800 = 0.8 倍。 在这种显示模式下，屏幕上可能会出现黑边，或超出设计分辨率的场景图像（穿帮）。尽管一般情况下开发者会尽量避免黑边，但如果需要确保设计分辨率范围的所有内容都显示在屏幕上，也可以采用这种模式。 根据屏幕宽高比，自动选择适配宽度或适配高度 如果对于屏幕周围可能被剪裁的内容没有严格要求，也可以不开启 Canvas 组件中任何适配模式，这时会根据屏幕宽高比自动选择 适配高度 或 适配宽度 来避免黑边。也就是说，设计分辨率宽高比大于屏幕分辨率时，会自动适配高度（上面第一张图）；设计分辨率宽高比小于屏幕分辨率时，会自动适配宽度（上面第二张图）。 Canvas 组件不提供分别缩放 x 和 y 轴缩放率，会使图像变形拉伸的适配模式 在 Cocos 引擎中，也存在称为 ExactFit 的适配模式，这种模式没有黑边，也不会裁剪设计分辨率范围内的图像。但是代价是场景图像的 x 和 y 方向的缩放倍率不同，图像会产生形变拉伸。 设计分辨率只能在项目设置中统一配置 当前的设计模式并没有加入多分辨率适配方式，所以在同一个项目里的多个 Canvas 的设计分辨率仍然采用同一套设计分辨率以及适配方案，开发者可以通过 项目 -> 项目设置 -> 通用设置 页面配置。 "},"ui-system/components/engine/widget-align.html":{"url":"ui-system/components/engine/widget-align.html","title":"对齐策略","keywords":"","body":"对齐策略 要实现完美的多分辨率适配效果，UI 元素按照设计分辨率中规定的位置呈现是不够的，当屏幕宽度和高度发生变化时，UI 元素要能够智能感知屏幕边界的位置，才能保证出现在屏幕可见范围内，并且分布在合适的位置。我们通过 Widget（对齐挂件） 来实现这种效果。 下面我们根据要对齐元素的类别来划分不同的对齐工作流： 需要贴边对齐的按钮和小元素 对于暂停菜单、游戏金币这一类面积较小的元素，通常只需要贴着屏幕边对齐就可以了。这时只要几个简单的步骤： 把这些元素在 层级管理器 中设为 Canvas 节点的子节点 在元素节点上添加 Widget 组件 以对齐左下角为例，开启 Left 和 Bottom 的对齐。 然后设置好节点和屏幕边缘的距离，下图中左边距设为 40px，下边距设为 30px。 这样设置好 Widget 组件后，不管实际屏幕分辨率是多少，这个节点元素都会保持在屏幕左下角，而且节点约束框左边和屏幕左边距离保持 40px，节点约束框下边和屏幕下边距离保持 30px。 注意 Widget 组件提供的对齐距离是参照子节点和父节点相同方向的约束框边界的。比如上面例子里勾选了 Left 对齐左边，那么子节点约束框左边和父节点（也就是 Canvas 节点，约束框永远等于屏幕大小）约束框左边的距离就是我们设置的 40px。 嵌套对齐元素 上面介绍了对齐屏幕边缘的做法，由于 Widget 默认的对齐参照物是父节点，所以我们也可以添加不同的节点层级，并且让每一级节点都使用自动对齐的功能。 我们下面用一个简单的例子来说明，假设我们有这样的节点层级关系： 其中 parent 是一个面板，button 是一个按钮。我们可以分别为这两个节点添加 Widget 组件，并且分别设置对齐距离。 对于 parent 节点来说，对齐 Canvas 节点的左上角，距离都是 80px： 对于 button 节点来说，对齐 parent 节点的左上角，距离都是 50px： 依照这样的工作流程，就可以将 UI 元素按照显示区域或功能进行分组，并且不同级别的元素都可以按照设计进行对齐。 根据对齐需要自动缩放节点尺寸 以上我们展示的例子里，并没有同时对齐在同一轴向相反方向的两个边，如果我们要做一个占满整个屏幕宽度的面板，就可以同时勾选 Left 和 Right 对齐开关： 当同时勾选相反的两个方向的对齐开关时，Widget 就获得了根据对齐需要修改节点尺寸（Size） 的能力，上图中我们勾选了左右两个方向并设置了边距，Widget 就会根据父节点的宽度来动态设置节点的 Width 属性，表现出来就是不管在多宽的屏幕上，我们的面板距离屏幕左右两边的距离永远保持 100px。 制作和屏幕大小保持一致的节点 利用自动缩放节点的特性，我们可以通过设置节点的 Widget 组件，使节点的尺寸和屏幕大小保持一致，这样我们就不需要把所有需要对齐屏幕边缘的 UI 元素都放在 Canvas 节点下，而是可以根据功能和逻辑的需要结组。 要制作这样的节点，首先要保证该节点的父节点尺寸能够保持和屏幕大小一致，Canvas 节点就是一个最好的选择。接下来按照下图的方式设置该节点的 Widget 组件： 就可以在运行时时刻保持该节点和 Canvas 节点的尺寸完全一致，也就是和屏幕大小一致。经过这样设置的节点，其子节点也可以使用同样的设置来传递屏幕实际尺寸。 注意，由于 Canvas 节点本身就有保持和屏幕大小一致的功能，因此不需要在 Canvas 上添加 Widget 组件。 设置百分比对齐距离 Widget 组件上开启某个方向的对齐之后，除了指定以像素为单位的边距以外，我们还可以输入百分比数值（例如：通过单击 方框内圈出的符号），这样 Widget 会以父节点相应轴向的宽度或高度乘以输入的百分比，计算出实际的边距值。 还是看看实际的例子，我们还是以一个直接放在 Canvas 下的子节点为例，我们希望这个节点面板保持在屏幕右侧，并且总是占据 60% 的屏幕总高度。那么按照下图所示设置 Widget 组件就可以实现这个效果： Widget 在对齐方向开启时输入边距值时，可以按照需要混合像素单位和百分比单位的使用。比如在需要对齐屏幕中心线的 Left 方向输入 50%，在需要对齐屏幕边缘的 Right 方向输入 20px，最后计算子节点位置和尺寸时，所有的边距都会先根据父节点的尺寸换算成像素距离，然后再进行摆放。 利用百分比对齐距离，我们可以制作出根据屏幕大小无限缩放的 UI 元素，发挥你的想象力，一套资源适配数千种安卓机型不是问题！ 运行时每帧更新对齐和优化策略 Widget 组件一般用于场景在目标设备上初始化时定位每个元素的位置，但一旦场景初始化完毕，很多时候我们就不需要 Widget 组件再进行对齐了。这里有个重要的属性 alignOnce 用于确保 Widget 组件只在初始化时执行对齐定位的逻辑，在运行时不再消耗时间来进行对齐。 如果选中了 alignOnce，且在组件初始化时执行过一次对齐定位，引擎就会自动将 Widget 组件的 enabled 属性设为 false 来关闭之后每帧自动更新来避免重复定位。如果需要在运行时实时定位，你需要手动将 alignOnce 属性关闭（设为 false），或者在运行时需要进行每帧更新对齐时手动遍历需要对齐的 Widget， 并将他们的 enabled 属性设为 true。 对于有很多 UI 元素的场景，确保 Widget 组件的 alignOnce 选项打开，可以大幅提高场景运行性能。 对齐组件对节点位置、尺寸的限制 通过 Widget 组件开启一个或多个对齐设置后，节点的位置（position）和尺寸（width、height）属性可能会被限制，不能通过 API 或动画系统自由修改。如果需要在运行时修改对齐节点的位置或尺寸，请参考 Widget 组件参考：对节点位置、尺寸的限制 相关内容。 UI 结构介绍 "},"ui-system/components/engine/label-layout.html":{"url":"ui-system/components/engine/label-layout.html","title":"文字排版","keywords":"","body":"文字排版 文字组件（Label） 是核心渲染组件之一，您需要了解如何设置文字的排版，才能在 UI 系统进行多分辨率适配和对齐设置时显示完美的效果。 文字在约束框中对齐 和其他渲染组件一样，Label 组件的排版也是基于 UITransform 组件所拥有的尺寸信息（contentSize），也就是约束框（Bounding Box）所规定的范围。 上图所示就是 Label 渲染的文字在蓝色约束框内显示的效果。Label 中以下的属性决定了文字在约束框中显示的位置： Horizontal Align（水平对齐）：文字在约束框中水平方向的对齐准线，可以从 Left、Right、Center 三种位置中选择。 Vertical Align（垂直对齐）：文字在约束框中垂直方向的对齐准线，可以从 Top、Bottom、Center 三种位置中选择。 上图中水平方向对齐位置设置为 Right，垂直方向的对齐位置设为了 Bottom，可以看到文字出现在约束框的底部且靠右对齐。开发者可以将以上两个属性修改为其他组合，文字会根据设置出现在蓝色约束框内相应的位置。 文字尺寸和行高 Font Size（文字尺寸）决定了文字的显示大小，单位是 Point（也称作“磅”），是大多数图像制作和文字处理软件中通用的字体大小单位。对于动态字体来说，Font Size 可以无损放大，但位图字体在将 Font Size 设置为超过字体标定的字号大小时，显示会变得越来越模糊。 Line Height（行高）决定了文字在多行显示时每行文字占据的空间高度，单位同样是 Point。多行文字显示可以通过两种方式实现： 在 String 属性中输入文字时，手动输入回车或换行符 开启 Enable Wrap Text（换行）属性，下文会详细介绍 文字尺寸和行高的关系： 如果 Font Size 和 Line Height 设为相同数值，文字正好占据一行大部分的空间高度。 如果 Font Size 小于 Line Height，多行文字之间间隔会加大 如果 Font Size 大于 Line Height，多行文字之间间隔会缩小，甚至出现文字相互重叠的情况。 排版模式（Overflow） Overflow（排版模式） 属性，决定了文字内容增加时，如何在约束框的范围内排布。共有 NONE、CLAMP、SHRINK、RESIZE_HEIGHT 四种模式，而只有在 后三种模式 下才能通过编辑器左上角的 矩形变换工具（也可以是按键盘按键 T）或者修改 属性检查器 中的 Size 大小或者添加 Widget 组件 来调整约束框的大小。 NONE 模式会自动根据文字尺寸、行高等固定约束框尺寸。 截断（Clamp） 截断模式下，文字首先按照对齐模式和尺寸的要求进行渲染，而超出约束框的部分会被隐藏（截断）。 自动缩小（Shrink） 自动缩小模式下，如果文字按照原定尺寸渲染会超出约束框时，会自动缩小文字尺寸以显示全部文字。 注意：自动缩小模式不会放大文字来适应约束框。 自动适应高度（Resize Height） 自动适应高度模式会保证文字的约束框贴合文字的高度，不管文字有多少行。这个模式非常适合显示内容量不固定的大段文字，配合 ScrollView 组件 可以在任意 UI 区域中显示无限量的文字内容。 自动换行（Enable Wrap Text） Label 组件中的 Enable Wrap Text（自动换行）属性，可以切换文字的自动换行开关。在自动换行开启的状态下，不需要在输入文字时手动输入回车或换行符，文字也会根据约束框的宽度自动换行。 注意：自动换行属性只有在文字排版模式的 截断（Clamp） 和 自动缩小（Shrink） 这两种模式下才有。自动适应高度（Resize Height） 模式下，自动换行属性是强制开启的。 截断（Clamp）模式自动换行 截断模式开启自动换行后，会优先在约束框允许的范围内换行排列文字，如果换行之后仍无法显示全部文字时才发生截断。 以下两幅图都是在 Clamp + Enable Wrap Text 开启情况下的，区别在于文字约束框的宽度不同： 在约束框宽度从左图变化到右图的过程中，文字将不断调整换行，最后由于约束框高度不足而产生了截断显示。 自动缩小（Shrink）模式自动换行 和截断模式类似，自动缩小模式下文字超出约束框宽度时也会优先试图换行，在约束框宽度和长度都已经完全排满的情况下才会自动缩小文字以适应约束框。 中文自动换行 中文自动换行的行为和英文不同，英文是以单词为单位进行换行的，必须有空格才能作为换行调整的最小单位。中文是以字为单位进行换行，每个字都可以单独调整换行。 文字节点的锚点 文字节点的锚点和文字在约束框中的对齐模式是需要区分的两个概念。在需要靠文字内容将约束框撑大的排版模式中（如 Resize Height），要正确设置锚点位置，才能让约束框向我们期望的方向调整。 例如，如果希望文字约束框向下扩展，需要将锚点（Anchor）的 y 属性设为 1。如下图所示： 文字配合对齐挂件（Widget） 在 Label 组件所在节点上添加一个 Widget（对齐挂件） 组件，就可以让文字节点相对于父节点进行各式各样的排版。 上图中我们在背景节点上添加了两个 Label 子节点，分别为他们添加 Widget 组件后，设置左边文字 Widget 的 Right 属性为 50%，右边文字 Widget 的 Left 属性为 60%，就可以实现图中所示的多列布局式文字。 而且通过 Widget 上设置边距，加上文字本身的排版模式，可以让我们在不需要具体微调文字约束框大小的情况下轻松实现灵活美观的文字排版。 查看组件参考 关于 Label 组件的属性，也可以查阅 Label 组件参考 文档。 UI 结构介绍 "},"ui-system/components/engine/auto-layout.html":{"url":"ui-system/components/engine/auto-layout.html","title":"自动布局容器","keywords":"","body":"自动布局容器 Layout（自动布局）组件可以挂载在任何节点上，将节点变成一个有自动布局功能的容器。所谓自动布局容器，就是能够自动将子节点按照一定规律排列，并可以根据节点内容的约束框总和调整自身尺寸的容器型节点。 布局模式（Layout Type） 自动布局组件有几种基本的布局模式，可以通过 Layout Type 属性进行设置，包括以下几种。 水平布局（Horizontal) Layout Type 设为 Horizontal 时，所有子节点都会自动横向排列，并根据子节点的宽度（Width）总和设置 Layout 节点的宽度。上图中 Layout 包括的两个 Label 节点就自动被横向排列。 水平布局模式下，Layout 组件不会干涉节点在 y 轴上的位置或高度属性，子节点甚至可以放置在 Layout 节点的约束框高度范围之外。如果需要子节点在 y 轴向上对齐，可以在子节点上添加 Widget 组件，并开启 Top 或 Bottom 的对齐模式。 垂直布局（Vertical） Layout Type 设为 Vertical 时，所有子节点都会自动纵向排列，并根据子节点的高度（Height）总和设置 Layout 节点的高度。 垂直布局模式下，Layout 组件也不会修改节点在 x 轴的位置或宽度属性，子节点需要添加 Widget 并开启 Left 或 Right 对齐模式才能规整的排列。 节点排列方向 Layout 排列子节点时，是以子节点在 层级管理器 中显示顺序为基准，加上 Vertical Direction 或 Horizontal Direction 属性设置的排列方向来排列的。 水平排列方向（Horizontal Direction） 可以设置 Left to Right 或 Right to Left 两种方向，前者会按照节点在 层级管理器 中显示顺序从左到右排列；后者会按照节点显示从右到左排列。 垂直排列方向（Vertical Direction） 可以设置 Top to Bottom 或 Bottom to Top 两种方向。前者会按照节点在 层级管理器 中显示顺序从上到下排列；后者会按照节点显示从下到上排列。 其他布局模式还在持续拓展中 我们会在之后版本的文档中更新这部分内容。 其他 Layout 组件的属性请查阅 Layout 组件参考 文档。 UI 结构介绍 "},"ui-system/components/engine/list-with-data.html":{"url":"ui-system/components/engine/list-with-data.html","title":"制作动态生成内容的列表","keywords":"","body":"制作动态生成内容的列表 UI 界面只有静态页面内容是不够的，我们会遇到很多需要由一组数据动态生成多个元素组成的 UI 面板，比如选人界面、物品栏、选择关卡等等。 准备数据 以物品栏为例，我们要动态生成一个物品，大概需要这样的一组数据： 物品 id 图标 id，我们可以在另一张资源表中建立图标 id 到对应 spriteFrame 的索引 物品名称 出售价格 ... 下面我们将会结合脚本介绍如何定义和使用数据，如果您对 Cocos Creator 3D 的脚本系统还不熟悉，可以先从 脚本开发指南 一章开始学习。 自定义数据类 对于大多数游戏来说，这些数据通常都来自于服务器或本地的数据库，现在我们为了展示流程，暂时把数据存在列表组件里就可以了。您可以新建一个脚本 ItemList.js，并添加如下的属性： @ccclass('Item') export class Item { @property id = 0; @property itemName = ''; @property itemPrice = 0; @property(SpriteFrame) iconSF: SpriteFrame | null = null; } @ccclass export class ItemList extends Component { @property([Item]) items: Item[] = []; @property(Prefab) itemPrefab: Prefab | null = null; onLoad() { for (var i = 0; i 上面脚本的前半部分我们声明了一个叫做 Item 的数据类，用来存放我们展示物品需要的各种数据。注意这个类并没有继承 Component，因此他不是一个组件，但可以被组件使用。关于声明自定义类的更多内容，请查阅 自定义 Class文档。 下半部分是正常的组件声明方式，这个组件中只有一个 items 属性，上面的声明方式将会给我们一个由 Item 类组成的数组，我们可以在 属性检查器 中为每个 Item 元素设置数据。 新建一个节点并将 ItemList.js 添加上去，我们可以在 属性检查器 里找到 Items 属性，要开始创建数据，需要先将数组的容量设为大于 0 的值。让我们将容量设为 3，并将每个元素的数据如下图设置。 这样我们最基本的数据就准备好了，如果您在制作有很多内容的游戏，请务必使用 excel、数据库等更专业的系统来管理您的数据，将外部数据格式转化为 Cocos Creator 可以使用的 JavaScript 和 JSON 格式都非常容易。 制作表现：Prefab 模板 接下来我们还需要一个可以在运行时用来实例化每个物品的模板资源 —— Prefab 预制。这个 Prefab 的结构如下图所示： icon、name、price 子节点之后就会用来展示图标、物品名称和价格的数据。 模板组件绑定 您在拼装 Prefab 时可以根据自己的需要自由发挥，上图中展示的仅仅是一个结构的例子。有了物品的模板结构，接下来我们需要一个组件脚本来完成节点结构的绑定。新建一个 ItemTemplate.js 的脚本，并将其添加到刚才制作的模板节点上。该脚本内容如下： @ccclass export class ItemTemplate extends Component { @property public id = 0; @property(SpriteComponent) public icon: SpriteComponent | null = null; @property(LabelComponent) public itemName: LabelComponent | null = null; @property(LabelComponent) public itemPrice: LabelComponent | null = null; } 接下来将对应的节点拖拽到该组件的各个属性上： 注意 id 这个属性我们会直接通过数据赋值，不需要绑定节点。 通过数据更新模板表现 接下来我们需要继续修改 ItemTemplate.js，为其添加接受数据后进行处理的逻辑。在上述脚本后面加入以下内容： // data: { id, iconSF, itemName, itemPrice } init(data: Item) { this.id = data.id; this.icon.spriteFrame = data.iconSF; this.itemName.string = data.itemName; this.itemPrice.string = data.itemPrice; } init 方法接受一个数据对象，并使用这个对象里的数据更新各个负责表现组件的相应属性。现在我们可以将 Item 节点保存成一个 Prefab 了，这就是我们物品的模板。 根据数据生成列表内容 现在让我们回到 ItemList.js 脚本，接下来要添加的是物品模板 Prefab 的引用，以及动态生成列表的逻辑。 //... @property(Prefab) itemPrefab: Prefab | null = null; onLoad () { for (var i = 0; i 在 onLoad 回调方法里，我们依次遍历 items 里存储的每个数据，以 itemPrefab 为模板生成新节点并添加到 ItemList.js 所在节点上。之后调用 ItemTemplate.js 里的 init 方法，更新每个节点的表现。 现在我们可以为 ItemList.js 所在的节点添加一个 Layout 组件，通过 属性检查器 下方的 添加组件 -> 添加 UI 组件 -> Layout，然后设置 Layout 组件的以下属性： Type：HORIZONTAL Resize Mode：CONTAINER 别忘了把 item Prefab 拖拽到 ItemList 组件的 itemPrefab 属性里。您还可以为这个节点添加一个 Sprite 组件，作为列表的背景。 完成后的 itemList 节点属性如下： 预览效果 最后运行预览，可以看到类似这样的效果（具体效果和您制作的物品模板，以及输入的数据有关）： 注意前面步骤中添加 Layout 组件并不是必须的，Layout 能够帮助您自动排列列表中的节点元素，但您也可以用脚本程序来控制节点的排列。我们通常还会配合 ScrollView 滚动视图组件一起使用，以便在有限的空间内展示大量内容。可以配合 自动布局 和 滚动视图 一起学习。 UI 结构介绍 "},"ui-system/components/engine/sliced-sprite.html":{"url":"ui-system/components/engine/sliced-sprite.html","title":"制作可任意拉伸的 UI 图像","keywords":"","body":"制作可任意拉伸的 UI 图像 UI 系统核心的设计原则是能够自动适应各种不同的设备屏幕尺寸，因此我们在制作 UI 时需要正确设置每个控件元素的尺寸（size），并且让每个控件元素的尺寸能够根据设备屏幕的尺寸进行自动的拉伸适配。为了实现这一点，就需要使用九宫格格式的图像来渲染这些元素。这样即使使用很小的原始图片也能生成覆盖整个屏幕的背景图像，一方面节约游戏包体空间，另一方面能够灵活适配不同的排版需要。 上图右边为原始贴图大小的显示，左边是选择 Sliced 模式并放大 size 属性后的显示效果。 编辑图像资源的九宫格切分 要使用可以无限放大的九宫格图像效果，我们需要先对图像资源进行九宫格切分。首先打开 Sprite 编辑器，在 资源管理器 中选中图像资源，然后点击 属性检查器 最下面的 编辑 按钮。如果您的窗口高度不够，可能需要向下滚动 属性检查器 才能看到下面的按钮。 打开 Sprite 编辑器 以后，可以看到图像周围有一圈绿色的线条，表示当前九宫格分割线的位置。将鼠标移动到分割线上，可以看到光标形状改变了，这时候就可以按下并拖拽鼠标来更改分割线的位置。 我们分别拖动上下左右四条分割线，将图像切分成九宫格，九个区域在 Sprite 尺寸（size）变化时会应用不同的缩放策略，见下图： 而下图中描述了不同区域缩放时的示意（图片来自 Yannick Loriot 的博客）： 完成切分后别忘记点击 Sprite 编辑器 右上角的绿色对勾来保存对资源的修改。 设置 Sprite 组件使用 Sliced 模式 准备好九宫格切分的资源后，就可以修改 Sprite 的显示模式并通过修改 size 来制作可任意指定尺寸的 UI 元素了。 首先选中场景中的 Sprite 节点，将 Sprite 的 Type 属性设为 Sliced。 然后通过 矩形变换工具 拖拽控制点使节点的 size 属性变大。您也可以直接在 属性检查器 中输入数值来修改 size 属性。如果图像资源是用九宫格的形式生产的，那么不管 Sprite 如何放大，都不会产生模糊或变形。 注意事项 在使用 矩形变换工具 或直接修改 Sliced Sprite 的 size 属性时，注意 size 的属性值不能为负数，否则不能以 Sliced 模式正常显示。 UI 结构介绍 "},"editor/components/":{"url":"editor/components/","title":"组件","keywords":"","body":"组件 Cocos Creator 3D 中包括以下功能组件： AudioSourceComponent ModelComponent SkinningModelComponent CameraComponent DirectionalLightComponent SphereLightComponent SpotLightComponent AnimationComponent BillboardComponent LineComponent ParticleSystemComponent 物理组件 UI组件 继续前往 AudioSourceComponent 说明文档。 "},"engine/renderable/model-component.html":{"url":"engine/renderable/model-component.html","title":"ModelComponent","keywords":"","body":"模型组件 模型组件用于显示一个静态的3D模型。通过mesh设置模型网格，通过material改变模型外观。 属性 功能 mesh 用于渲染的3D模型资源。 materials 用于渲染模型的材质，一个材质对应mesh中的一个submesh。 shadowCastingMode 指定当前模型是否会投射阴影，需要先在场景中启用平面阴影系统。 visibility 用于模型会被哪个摄像机渲染，只有visibility与模型相同的摄像机才会渲染该模型。 模型分组渲染 分组渲染功能是通过相机组件(CameraComponent) 的 Visibility 属性配合节点的 Layer 属性共同决定。用户可通过代码设置 Visibility 的值来完成分组渲染。所有节点默认都属于 DEFAULT 层，在所有相机都可见。 静态合批 目前静态合批方案为运行时静态合批，通过调用 BatchingUtility.batchStaticModel 可进行静态合批。 该函数接收一个节点，然后将该节点下的所有 ModelComponent 里的 Mesh 合并成一个，并将其挂到另一个节点下。 在合批后，将无法改变原有的 ModelComponent 的 transform，但可以改变合批后的根节点的 transform。只有满足以下条件的结点才能进行静态合批： 子节点中只能包含 ModelComponent； 子节点下的 ModelComponent 的 Mesh 的顶点数据结构必须一致； 子节点下的 ModelComponent 的材质必须相同； 关于动态合批 引擎目前提供两套动态合批系统，instancing 合批和合并 VB 方式的合批，两种方式不能共存，instancing 优先级大于合并 VB。 要开启合批，只需在模型所使用的材质中对应勾选 USE_INSTANCING 或 USE_BATCHING 开关即可。 注意：合批能够正常参与 frustum culling 流程，但对透明模型无法执行排序，会导致混合效果不正确。引擎没有明确禁止对透明物体的合批，开发者可以自行掌握其中权衡。 Instancing 合批 通过 Instancing 的合批适用于绘制大量顶点数据完全相同的动态模型，启用后绘制时会根据材质和顶点数据分组，每组内组织 instanced attributes 信息，然后一次性完成绘制。 关于蒙皮模型的支持及相关设定，参考 骨骼动画组件。 另外 instancing 还支持自定义额外的 instanced attributes，可以传递更多不同 instance 之间的差异性数据（比如不同人物间给一个漫反射颜色的外观差异，或大片草地中的风力影响）。 这需要自定义 effect 的支持，更详细的说明可以参考 语法指南。 合并 VB 合批 合并 VB 合批适用于绘制大量低面数且顶点数据各不相同的非蒙皮动态模型，启用后绘制时会根据材质分组，然后每组内每帧合并顶点和世界变换信息，然后分批完成绘制1。 每帧合并顶点等操作会引入一部分 CPU 开销，在 JS 中尤其昂贵；另外需要提醒 drawcall 数量并不是越少越好2，最佳性能往往是 CPU 与 GPU 负载均衡的结果，所以在尝试使用合批功能时，请一定多做测试，明确性能瓶颈，做有针对性的优化。 合批的最佳实践 通常来说合批系统的使用优先级为：静态合批 > instancing 合批 > 合并 VB 合批。 首先要确保材质统一，在这个前提下： 如果确定某些模型在游戏周期内完全静止不会变化，就可以使用静态合批。 如果存在大量相同的模型重复绘制，相互间只有相对可控的小差异，就可以使用 instancing 合批。 如果存在大量面数很低但顶点数据又各不相同的模型，可以考虑尝试合并 VB 合批。 [1] 注意目前使用 uniform 上传合批后的世界变换矩阵，考虑到 WebGL 标准的 uniform 数量限制，目前一批最多绘制 10 个模型，所以对大量同材质的模型，开启合批后 drawcall 数量预期最多会减少 10 倍。 ↩ [2] 关于合批与性能的话题业界一直有不少探讨，可以参考比如 这里 的 slide ↩ "},"editor/components/camera-component.html":{"url":"editor/components/camera-component.html","title":"CameraComponent","keywords":"","body":"相机 游戏中的相机是用来捕捉场景画面的主要工具。我们通过调节相机相关参数来控制可视范围的大小，在 Cocos Creator 3D 编辑器中相机呈如下表示： 相机的可视范围是通过 6 个平面组成一个 视锥体（Frustum） 构成， 近裁剪面（Near Plane） 和 远裁剪面（Far Plane） 用于控制近处和远处的可视距离与范围，同时它们也构成了视口的大小。 相机组件 相机组件是我们用来呈现场景画面的重要功能组件。 属性名称 说明 priority 相机的渲染优先级，值越小越优先渲染 visibility 可见性掩码，声明在当前相机中可见的节点层级集合。 clearFlags 相机的缓冲清除标志位，指定帧缓冲的哪部分要每帧清除。包含：DONT_CLEAR：不清空；DEPTH_ONLY：只清空深度； SOLID_COLOR：清空颜色、深度与模板缓冲； SKYBOX：启用天空盒，只清空深度 clearColor 指定清空颜色 clearDepth 指定深度缓冲清空值 clearStencil 指定模板缓冲清空值 projection 相机投影模式。分为 透视投影（PERSPECTIVE） 和 正交投影（ORTHO） fovAxis 指定视角的固定轴向，在此轴上不会跟随屏幕长宽比例变化 fov 相机的视角大小 orthoHeight 正交模式下的视角 near 相机的近裁剪距离，应在可接受范围内尽量取最大 far 相机的远裁剪距离，应在可接受范围内尽量取最小 aperture 相机光圈，影响相机的曝光参数 shutter 相机快门，影响相机的曝光参数 iso 相机感光度，影响相机的曝光参数 rect 此相机最终渲染到屏幕上的视口位置和大小 targetTexture 指定此相机的渲染输出目标贴图，默认为空，直接渲染到屏幕 相机分组渲染 分组渲染功能是通过相机组件(CameraComponent) 的 Visibility 属性配合节点的 Layer 属性共同决定。用户可通过代码设置 Visibility 的值来完成分组渲染。所有节点默认都属于 DEFAULT 层，在所有相机都可见。 "},"particle-system/billboard-component.html":{"url":"particle-system/billboard-component.html","title":"BillboardComponent","keywords":"","body":"Billboard组件 billboard 组件用于渲染一个始终面向摄像机的方块。 属性 功能 height billboard 的高度。 width billboard 的宽度。 rotation billboard 绕中心点旋转的角度。 texture billboard 显示的贴图。 "},"particle-system/line-component.html":{"url":"particle-system/line-component.html","title":"LineComponent","keywords":"","body":"Line组件 Line组件用于渲染3D场景中给定的点连成的线段。Line组件渲染的线段是有宽度的，并且总是面向摄像机，这与billboard组件相似。 属性 功能 texture 线段中显示的贴图。 worldSpace 线段中各个点的坐标采用哪个坐标系，勾选使用世界坐标系，不选使用本地坐标系。 positions 每个线段端点的坐标。 wdith 线段宽度，如果采用曲线，则表示沿着线段方向上的曲线变化。 tile 贴图平铺次数。 offset 贴图坐标的偏移。 color 线段颜色，如果采用渐变色，则表示沿着线段方向上的颜色渐变。 "},"ui-system/components/editor/":{"url":"ui-system/components/editor/","title":"UI 组件","keywords":"","body":"常用 UI 控件 本篇文档将介绍 UI 系统中常用的控件，使用核心渲染组件和对齐策略，这些控件将构成我们游戏中 UI 的大部分交互部分。 一些常用的 UI 控件可通过添加节点的方式来创建。在 层级管理器 左上角的 + 创建节点菜单中选择 UI 来创建 UI 节点，相应的 UI 组件便会自动挂载到节点上： 其它的 UI 组件，可以手动在 层级管理器 中选中节点，然后在 属性检查器 中点击 添加组件 -> UI 的方式来添加： 组件目录 UI 组件主要分成以下两种类型： UI 渲染组件 UI 基础组件 "},"ui-system/components/editor/render-component.html":{"url":"ui-system/components/editor/render-component.html","title":"UI 渲染组件","keywords":"","body":"UI 渲染组件介绍 Sprite 组件参考 Label 组件参考 Mask 组件参考 Graphics 组件参考 RichText 组件参考 UIStaticBatch 组件参考 "},"ui-system/components/editor/sprite.html":{"url":"ui-system/components/editor/sprite.html","title":"Sprite 组件参考","keywords":"","body":"Sprite 组件参考 Sprite（精灵）是 2D/3D 游戏最常见的显示图像的方式，在节点上添加 Sprite 组件，就可以在场景中显示项目资源中的图片。 点击 属性检查器 下面的 添加组件 按钮，然后选择 UI/Render/Sprite 即可添加 Sprite 组件到节点上。 Sprite 属性 属性 功能说明 Type 渲染模式，包括普通（Simple）、九宫格（Sliced）、平铺（Tiled）和填充（Filled）四种模式 Color 图片颜色 Grayscale 灰度模式，开启后 Sprite 会使用灰度模式渲染。 Sprite Atlas Sprite 显示图片资源所属的图集（参考 Atlas）。 Sprite Frame 渲染 Sprite 使用的 SpriteFrame 图片资源。（Sprite Frame 后面的 编辑 按钮用于编辑图像资源的九宫格切分，详情请参考 使用 Sprite 编辑器制作九宫格图像） Size Mode 指定 Sprite 的尺寸Trimmed 表示会使用原始图片资源裁剪透明像素后的尺寸Raw 表示会使用原始图片未经裁剪的尺寸 Custom 表示会使用自定义尺寸。当用户手动修改过 Size 属性后，Size Mode 会被自动设置为 Custom，除非再次指定为前两种尺寸。 Trim 是否渲染原始图像周围的透明像素区域，详情请参考 图像资源的自动剪裁 Src Blend Factor 当前图像混合模式 Dst Blend Factor 背景图像混合模式，和上面的属性共同作用，可以将前景和背景 Sprite 用不同的方式混合渲染，效果预览可以参考 glBlendFunc Tool 添加 Sprite 组件之后，通过从 资源管理器 中拖拽 SpriteFrame 类型的资源到 SpriteFrame 属性引用中，就可以通过 Sprite 组件显示资源图像。 如果拖拽的 SpriteFrame 资源是包含在一个 Atlas 图集资源中的，那么 Sprite 的 Atlas 属性也会被一起设置。 若要动态更换 SpriteFrame 则需要先动态加载图片资源，然后再进行替换，详情请参考 获取和加载资源：动态加载。 渲染模式 Sprite 组件支持以下几种渲染模式： 普通模式（Simple）：根据原始图片资源渲染 Sprite，一般在这个模式下我们不会手动修改节点的尺寸，来保证场景中显示的图像和美术人员生产的图片比例一致。 九宫格模式（Sliced）：图像将被分割成九宫格，并按照一定规则进行缩放以适应可随意设置的尺寸(size)。通常用于 UI 元素，或将可以无限放大而不影响图像质量的图片制作成九宫格图来节省游戏资源空间。详细信息请阅读 使用 Sprite 编辑器制作九宫格图像 一节。 平铺模式（Tiled）：当 Sprite 的尺寸增大时，图像不会被拉伸，而是会按照原始图片的大小不断重复，就像平铺瓦片一样将原始图片铺满整个 Sprite 规定的大小。 填充模式（Filled）：根据原点和填充模式的设置，按照一定的方向和比例绘制原始图片的一部分。经常用于进度条的动态展示。 填充模式（Filled） Type 属性选择填充模式后，会出现一组新的属性可供配置，让我们依次介绍他们的作用。 属性 功能说明 Fill Type 填充类型选择，有 HORIZONTAL（横向填充）、VERTICAL（纵向填充）和 RADIAL （扇形填充）三种。 Fill Start 填充起始位置的标准化数值（从 0 ~ 1，表示填充总量的百分比），选择横向填充时，Fill Start 设为 0，就会从图像最左边开始填充 Fill Range 填充范围的标准化数值（同样从 0 ~ 1），设为 1，就会填充最多整个原始图像的范围。 Fill Center 填充中心点，该属性只有选择了 RADIAL 填充类型才能修改。决定了扇形填充时会环绕 Sprite 上的哪个点。 Fill Range 填充范围补充说明 在 HORIZONTAL 和 VERTICAL 这两种填充类型下，Fill Start 设置的数值将影响填充总量，如果 Fill Start 设为 0.5，那么即使 Fill Range 设为 1.0，实际填充的范围也仍然只有 Sprite 总大小的一半。 而 RADIAL 类型中 Fill Start 只决定开始填充的方向，Fill Start 为 0 时，从 x 轴正方向开始填充。Fill Range 决定填充总量，值为 1 时将填充整个圆形。Fill Range 为正值时逆时针填充，为负值时顺时针填充。 其他渲染模块参考 基础模块参考 "},"ui-system/components/editor/label.html":{"url":"ui-system/components/editor/label.html","title":"Label 组件参考","keywords":"","body":"Label 组件参考 Label 组件用来显示一段文字，文字可以是系统字体，TrueType 字体或者 BMFont 字体。另外，Label 还具有排版功能。 点击 属性检查器 下面的 添加组件 按钮，然后从 UI/Render 中选择 Label，即可添加 Label 组件到节点上。 Label 属性 属性 功能说明 Color 文字颜色。 String 文本内容字符串。 Horizontal Align 文本的水平对齐方式。可选值有 LEFT，CENTER 和 RIGHT。 Vertical Align 文本的垂直对齐方式。可选值有 TOP，CENTER 和 BOTTOM。 Font Size 文本字体大小。 Line Height 文本的行高。 Overflow 文本的排版方式，目前支持 CLAMP，SHRINK 和 RESIZE_HEIGHT。详情见下方的 Label 排版 或者 文字排版。 Enable Wrap Text 是否开启文本换行。（在排版方式设为 CLAMP、SHRINK 时生效） Font 指定文本渲染需要的字体文件，如果使用系统字体，则此属性可以为空。 Font Family 文字字体名字。在使用系统字体时生效。 Cache Mode 文本缓存类型（v2.0.9 中新增），仅对 系统字体 或 ttf 字体有效，BMFont 字体无需进行这个优化。包括 NONE、BITMAP、CHAR 三种模式。详情见下方的 文本缓存类型。 Use System Font 布尔值，是否使用系统字体。 IsBold 文字是否加粗，支持系统字以及部分 ttf。 IsItalic 文字是否倾斜，支持系统字以及 ttf。 IsUnderline 文字是否加下划线，支持系统字以及 ttf。 Src Blend Factor 当前渲染混合模式 Dst Blend Factor 背景混合模式，和上面的属性共同作用，可以将前景和背景渲染的文本用不同的方式混合，效果预览可以参考 glBlendFunc Tool Label 排版 属性 功能说明 CLAMP 文字尺寸不会根据 Content Size 的大小进行缩放，Wrap Text 关闭的情况下，按照正常文字排列，超出 Content Size 的部分将不会显示。Wrap Text 开启的情况下，会试图将本行超出范围的文字换行到下一行。如果纵向空间也不够时，也会隐藏无法完整显示的文字。 SHRINK 文字尺寸会根据 Content Size 大小进行自动缩放（不会自动放大，最大显示 Font Size 规定的尺寸），Wrap Text 开启时，当宽度不足时会优先将文字换到下一行，如果换行后还无法完整显示，则会将文字进行自动适配 Content Size 的大小。如果 Wrap Text 关闭时，则直接按照当前文字进行排版，如果超出边界则会进行自动缩放。 RESIZE_HEIGHT 文本的 Content Size 会根据文字排版进行适配，这个状态下用户无法手动修改文本的高度，文本的高度由内部算法自动计算出来。 文本缓存类型（Cache Mode） 属性 功能说明 NONE 默认值，Label 中的整段文本将生成一张位图。 BITMAP 目前等同于 NONE。 CHAR 原理类似 BMFont，Label 将以“字”为单位将文本缓存到全局共享的位图中，相同字体样式和字号的每个字符将在全局共享一份缓存。能支持文本的频繁修改，对性能和内存最友好。不过目前该模式还存在如下限制，我们将在后续的版本中进行优化：1、该模式只能用于字体样式和字号（通过记录字体的 fontSize、fontFamily、color、outline 为关键信息，以此进行字符的重复使用，其他有使用特殊自定义文本格式的需要注意）固定，并且不会频繁出现巨量未使用过的字符的 Label。这是为了节约缓存，因为全局共享的位图尺寸为 2048*2048，只有场景切换时才会清除，一旦位图被占满后新出现的字符将无法渲染。2、Overflow 不支持 SHRINK。3、不能参与动态合图（同样启用 CHAR 模式的多个 Label 在渲染顺序不被打断的情况下仍然能合并 Draw Call） 注意：Cache Mode 对所有平台都有优化效果。 使用字体资源 Label 组件可以通过往 属性检查器 里的 Font 属性拖拽 TTF 字体文件和 BMFont 字体文件来修改渲染的字体类型。如果不想继续使用字体文件，可以通过勾选 Use System Font 来重新启用系统字体。 其他渲染模块参考 基础模块参考 "},"ui-system/components/editor/mask.html":{"url":"ui-system/components/editor/mask.html","title":"Mask 组件参考","keywords":"","body":"Mask（遮罩）组件参考 Mask 用于规定子节点可渲染的范围，带有 Mask 组件的节点会使用该节点的约束框（也就是 属性检查器 中 Node 组件的 ContentSize 规定的范围）创建一个矩形渲染遮罩，该节点的所有子节点都会依据这个遮罩进行裁剪，遮罩范围外的将不会渲染。 点击 属性检查器 下面的 添加组件 按钮，然后从 UI 中选择 Mask，即可添加 Mask 组件到节点上。注意该组件不能添加到有其他渲染组件（如 Sprite、Label 等）的节点上。 Mask 属性 属性 功能说明 Type 遮罩类型。包括 RECT、ELLIPSE、GRAPHICS_STENCIL 类型。 Segments 椭圆遮罩的曲线细分数，只在遮罩类型设为 ELLIPSE 时生效 Inverted 反向遮罩 注意： 节点添加了 Mask 组件之后，所有在该节点下的子节点，在渲染的时候都会受 Mask 影响。 GRAPHICS_STENCIL 类型在这里没有做任何引擎需要的事，只是放开了对 graphics 操控，用户可以使用这个 graphics 来绘制自定义图形，但是节点的点击事件还是根据节点的尺寸来计算。 在当前版本以及之前版本上，由于底层渲染架构原因，Mask 在编辑器下的所有子节点的渲染内容都看不见，解决方法是，在编辑器下调整 Mask 节点的 layer 为 default 即可，不会影响运行时数据。 其他渲染模块参考 基础模块参考 "},"ui-system/components/editor/graphics.html":{"url":"ui-system/components/editor/graphics.html","title":"Graphics 组件参考","keywords":"","body":"Graphics 组件参考 Graphics 组件提供了一系列绘画接口，这些接口参考了 Canvas 的绘画接口来进行实现。 新建一个空节点，然后点击 属性检查器 下方的 添加组件 按钮，从 UI/Render 中选择 Graphics，即可添加 Graphics 组件到节点上。 绘图属性 属性 功能说明 FillColor 设置或返回填充绘画的颜色 LineCap 设置或返回线条的结束端点样式 LineJoin 设置或返回两条线相交时，所创建的拐角类型 MiterLimit 设置或返回最大斜接长度 StrokeColor 设置或返回笔触的颜色 绘图接口 路径 方法 功能说明 moveTo (x, y) 把路径移动到画布中的指定点，不创建线条 lineTo (x, y) 添加一个新点，然后在画布中创建从该点到最后指定点的线条 bezierCurveTo (c1x, c1y, c2x, c2y, x, y) 创建三次方贝塞尔曲线 quadraticCurveTo (cx, cy, x, y) 创建二次贝塞尔曲线 arc (cx, cy, r, a0, a1, counterclockwise) 创建弧/曲线（用于创建圆形或部分圆） ellipse (cx, cy, rx, ry) 创建椭圆 circle (cx, cy, r) 创建圆形 rect (x, y, w, h) 创建矩形 close () 创建从当前点回到起始点的路径 stroke () 绘制已定义的路径 fill () 填充当前绘图（路径） clear () 清除所有路径 其他渲染模块参考 基础模块参考 "},"ui-system/components/editor/richtext.html":{"url":"ui-system/components/editor/richtext.html","title":"RichText 组件参考","keywords":"","body":"RichText 组件参考 RichText 组件用来显示一段带有不同样式效果的文字，你可以通过一些简单的 BBCode 标签来设置文字的样式。目前支持的样式有：颜色（color）、字体大小（size）、字体描边（outline）、加粗（b）、斜体（i）、下划线（u）、换行（br）、图片（img）和点击事件（on），并且不同的 BBCode 标签是可以支持相互嵌套的。 更多关于 BBCode 标签的内容，请参考本文档的 BBCode 标签格式说明 小节。 点击 属性检查器 下面的 添加组件 按钮，然后选择 UI/Render/RichText 即可添加 RichText 组件到节点上。 RichText 属性 属性 功能说明 String 富文本的内容字符串, 你可以在里面使用 BBCode 来指定特定文本的样式 Horizontal Align 水平对齐方式 Font Size 字体大小, 单位是 point （注意，该字段不会影响 BBCode 里面设置的字体大小） Font 富文本定制字体，所有的 label 片断都会使用这个定制的 TTF 字体 Line Height 字体行高, 单位是 point Max Width 富文本的最大宽度, 传 0 的话意味着必须手动换行. Image Atlas 对于 img 标签里面的 src 属性名称，都需要在 imageAtlas 里面找到一个有效的 spriteFrame，否则 img tag 会判定为无效。 Handle Touch Event 选中此选项后，RichText 将阻止节点边界框中的所有输入事件（鼠标和触摸），从而防止输入事件穿透到底层节点。 BBCode 标签格式 基本格式 目前支持的标签类型有：size，color, b, i, u, img 和 on，分别用来定制字体大小，字体颜色, 加粗，斜体，下划线，图片和点击事件。每一个标签都有一个起始标签和一个结束标签，起始标签的名字和属性格式必要符合要求，且全部为小写。结束标签的名字不做任何检查，只需要满足结束标签的定义即可。 下面分别是应用 size 和 color 标签的一个例子： 你好，Creator3D 支持标签 注意：所有的 tag 名称必须是小写，且属性值是用 = 号赋值。 名称 描述 示例 注意事项 color 指定字体渲染颜色，颜色值可以是内置颜色，比如 white，black 等，也可以使用 16 进制颜色值，比如 #ff0000 表示红色 Red Text size 指定字体渲染大小，大小值必须是一个整数 enlarge me Size 值必须使用等号赋值 outline 设置文本的描边颜色和描边宽度 A label with outline 如果你没有指定描边的颜色或者宽度的话，那么默认的颜色是白色(#ffffff),默认的宽度是 1 b 指定使用粗体来渲染 This text will be rendered as bold 名字必须是小写，且不能写成 bold i 指定使用斜体来渲染 This text will be rendered as italic 名字必须是小写，且不能写成 italic u 给文本添加下划线 This text will have a underline 名字必须是小写，且不能写成 underline on 指定一个点击事件处理函数，当点击该 Tag 所在文本内容时，会调用该事件响应函数 click me! 除了 on 标签可以添加 click 属性，color 和 size 标签也可以添加，比如 click me param 当点击事件触发时，可以在回调函数的第二个参数获取该数值 click me! 依赖 click 事件 br 插入一个空行 注意： 和 都是不支持的。 img 给富文本添加图文混排功能，img 的 src 属性必须是 ImageAtlas 图集里面的一个有效的 spriteframe 名称 注意: 只有 这种写法是有效的。如果你指定一张很大的图片，那么该图片创建出来的精灵会被等比缩放，缩放的值等于富文本的行高除以精灵的高度。 标签与标签是支持嵌套的，且嵌套规则跟 HTML 是一样的。比如下面的嵌套标签设置一个文本的渲染大小为 30，且颜色为绿色。 I'm green 也可以实现为: I'm green Color** 中设置 RichText 的整体颜色 2. 使用 bbcode 对 RichText 内部分别设置颜色 注意：两者不可混用，如果混用了，运行时将以第二种方式设置的颜色为准。 --> 详细说明 富文本组件全部由 JS 层实现，采用底层的 Label 节点拼装而成，并且在上层做排版逻辑。 这意味着，你新建一个复杂的富文本，底层可能有十几个 label 节点，而这些 label 节点都是采用系统字体渲染的。所以，一般情况下，你不应该在游戏的主循环里面频繁地修改富文本的文本内容, 这可能会导致性能比较低。另外，如果能不使用富文本组件，就尽量使用普通的文本组件，并且 BMFont 的效率是最高的。 其他渲染模块参考 基础模块参考 "},"ui-system/components/editor/ui-static.html":{"url":"ui-system/components/editor/ui-static.html","title":"UIStaticBatch 组件参考","keywords":"","body":"UIStaticBatch 组件参考 UI 静态合批组件是一个提升 UI 渲染性能的组件，脚本在初始化当前帧渲染的过程中会收集该 UI 节点树下的所有渲染数据（除了模型、Mask 和 Graphices），存储为一个静态的 IA 渲染数据。并在后续的渲染流程中使用固定数据进行渲染，不再遍历其节点树，此后的坐标变换将不再生效。当你需要修改静态数据的时候，可以调用 markAsDirty 接口来重新触发渲染数据收集标记。 注意事项 使用该组件有以下几点需要注意： 不要频繁触发静态合批，因为会清空原先存储的 IA 数据重新采集，会有一定性能和内存损耗。 不适用于子节点树中包含 Mask、Graphics 和 Model 的情况。 对于节点树不会有任何改变的节点（例如 2D 地图），在收集完数据之后即可将所有子节点删除，以得到最好的性能和内存表现。 "},"ui-system/components/editor/base-component.html":{"url":"ui-system/components/editor/base-component.html","title":"UI 基础组件","keywords":"","body":"UI 基础组件 Canvas 组件参考 UITransform 组件参考 Widget 组件参考 Button 组件参考 Layout 组件参考 EditBox 组件参考 ScrollView 组件参考 ScrollBar 组件参考 ProgressBar 组件参考 LabelOutline 组件参考 Toggle 组件参考 UIModel 组件参考 ToggleGroup 组件参考 Slider 组件参考 PageView 组件参考 PageViewIndicator 组件参考 UIOpacity 组件参考 BlockInputEvents 组件参考 "},"ui-system/components/editor/canvas.html":{"url":"ui-system/components/editor/canvas.html","title":"Canvas 组件参考","keywords":"","body":"Canvas（画布）组件参考 Canvas（画布） 组件所在的节点是 UI 的根节点。场景中 Canvas 节点可以有多个。所有 UI 元素都必须作为 Canvas 的子节点才能被渲染，当前处于哪一个 Canvas 节点下，就被哪个 Canvas 渲染。多个 Canvas 之间可以通过 Priority 属性排序. 除了它所在节点是 UI 根节点外，它自身还具有屏幕适配的功能，在游戏制作上面对多分辨率适配也起到关键作用，具体请参考多分辨率适配方案。Canvas 的设计分辨率和适配方案统一通过 项目设置 配置。在 Canvas 内部会自带一个相机，默认照射 z 轴方向是从 -1000 - 998，所以针对 UI 上元素的 z 轴设计必须限制在这个范围内才能正常显示（不取临界值）。 在过去的设计里 Canvas 是最后渲染的，意味着它可以遮盖 3D 的所有内容渲染，但这远远不能满足项目开发需求（例如：一个 2D 地图配合 3D 角色的功能）。因此，我们加入了 RenderMode 属性，用户可以在原有基础上决定是否切换 UI 的相机的行为为 3D 相机和 UI 相机的排序渲染。当然，这个功能是要配合 ClearFlag 来调控。具体可以参考相机混合排序。 Canvas 属性 属性 功能说明 RenderMode Canvas 渲染模式，Intersperse 下可以指定 Canvas 与场景中的相机的渲染顺序，Overlay 下 Canvas 会在所有场景相机渲染完成后渲染。注意：启用 Intersperse 模式，如果 3D 场景的相机内容显示上要在 Canvas 前面，相机的 ClearFlags 也要为 Dont_Clear。 Priority 当 RenderMode 为 Intersperse 时，指定与其它相机的渲染顺序，当 RenderMode 为 Overlay 时，指定跟其余 Canvas 做排序使用。 ClearFlag Canvas 清理屏幕缓冲区的标记。Dont_Clear 不清理。Depth_Only 清理深度缓冲。Solid_Color 清理颜色深度缓冲。 Color 清理颜色缓冲区后的颜色。 TargetTexture 目标渲染纹理 注意事项 如果遇到 UI 渲染出错，花屏，闪屏等现象，可以看此处的注意事项。 其他基础模块参考 渲染模块参考 "},"ui-system/components/editor/ui-transform.html":{"url":"ui-system/components/editor/ui-transform.html","title":"UITransform 组件参考","keywords":"","body":"UI 变换组件 定义了 UI 上的矩形信息，包括矩形的尺寸和锚点位置。开发者可以通过该组件任意地操作矩形的大小、位置。一般用于渲染、点击事件的计算、界面布局以及屏幕适配等。 点击 属性检查器 下面的 添加组件 按钮，然后选择 UI/UITransform 即可添加 UITransform 组件到节点上。 UITransform 属性介绍 属性 功能说明 ContentSize UI 矩形内容尺寸 AnchorPoint UI 矩形锚点位置 Priority UI 节点优先级，在当前父节点下排序，Canvas 节点顺序不受此属性影响。 其他基础模块参考 渲染模块参考 "},"ui-system/components/editor/widget.html":{"url":"ui-system/components/editor/widget.html","title":"Widget 组件参考","keywords":"","body":"Widget 组件参考 Widget (对齐挂件) 是一个很常用的 UI 布局组件。它能使当前节点自动对齐到父物体的任意位置，或者约束尺寸，让你的游戏可以方便地适配不同的分辨率。对齐方案详细说明请参考对齐方案 点击 属性检查器 下面的 添加组件 按钮，然后选择 UI/Widget 即可添加 Widget 组件到节点上。 选项 选项 说明 备注 Top 对齐上边界 选中后，将在旁边显示一个输入框，用于设定当前节点的上边界和父物体的上边界之间的距离。 Bottom 对齐下边界 选中后，将在旁边显示一个输入框，用于设定当前节点的下边界和父物体的下边界之间的距离。 Left 对齐左边界 选中后，将在旁边显示一个输入框，用于设定当前节点的左边界和父物体的左边界之间的距离。 Right 对齐右边界 选中后，将在旁边显示一个输入框，用于设定当前节点的右边界和父物体的右边界之间的距离。 HorizontalCenter 水平方向居中 VerticalCenter 竖直方向居中 Target 对齐目标 指定对齐参照的节点，当这里未指定目标时会使用直接父级节点作为对齐目标 Align Mode 指定 widget 的对齐方式，用于决定运行时 widget 应何时更新 通常设置为 ALWAYS，每次节点产生变动时重新对齐。设置为 ONCE 时，仅在组件初始化时进行一次对齐。ON_WINDOW_RESIZE 时会在每次窗口变动时候更新一次 对齐边界 我们可以在 Canvas 下新建一个 sprite，在 sprite 节点上添加一个 Widget 组件，然后做如下一些测试： 左对齐，左边界距离 100 px： 下对齐，下边界距离 50%： 百分比将以父节点的宽或高作为基准。 右下对齐，边界距离 0 px： 居中对齐 水平方向居中： 竖直方向居中，并且右边界距离 50%： 约束尺寸 如果左右同时对齐，或者上下同时对齐，那么在相应方向上的尺寸就会被拉伸。 下面演示一下，在场景中放置两个矩形 Sprite，大的作为对话框背景，小的作为对话框上的按钮。按钮节点作为对话框的子节点，并且按钮设置成 Sliced 模式以便展示拉伸效果。 宽度拉伸，左右边距 10%： 高度拉伸，上下边距 0，同时水平居中： 水平和竖直同时拉伸，边距 50 px： 对节点位置、尺寸的限制 如果 Align Mode 属性设为 ALWAYS 时，会在运行时每帧都按照设置的对齐策略进行对齐，组件所在节点的位置（position）和尺寸（width，height）属性可能会被限制，不能通过 API 或动画系统自由修改。这是因为通过 Widget 对齐是在每帧的最后阶段进行处理的，因此对 Widget 组件中已经设置了对齐的相关属性进行设置，最后都会被 Widget 组件本身的更新所重置。 如果需要同时满足对齐策略和可以在运行时改变位置和尺寸的需要，可以通过以下两种方式实现： 确保 Widget 组件的 Align Mode 属性设置为 ONCE，该属性只会负责在组件初始化（onEnable）时进行一次对齐，而不会每帧再进行一次对齐。可以在初始化时自动完成对齐，然后就可以通过 API 或动画系统对 UI 进行移动变换了。 通过调用 Widget 组件的对齐边距 API，包括 top、 bottom、 left、 right，直接修改 Widget 所在节点的位置或某一轴向的拉伸。这些属性也可以在动画编辑器中添加相应关键帧，保证对齐的同时实现各种丰富的 UI 动画。 其他基础模块参考 渲染模块参考 "},"ui-system/components/editor/button.html":{"url":"ui-system/components/editor/button.html","title":"Button 组件参考","keywords":"","body":"Button（按钮）组件参考 Button 组件可以响应用户的点击操作，当用户点击 Button 时，Button 自身会有状态变化。另外，Button 还可以让用户在完成点击操作后响应一个自定义的行为。 点击 属性检查器 下面的 添加组件 按钮，然后从 添加 UI 组件 中选择 Button，即可添加 Button 组件到节点上。 Button 属性 属性 功能说明 Target Node 类型，当 Button 发生 Transition 的时候，会相应地修改 Target 节点的 SpriteFrame，颜色或者 Scale。 interactable 布尔类型，设为 false 时，则 Button 组件进入禁用状态。 Transition 枚举类型，包括 NONE, COLOR，SPRITE 和 SCALE。每种类型对应不同的 Transition 设置。详情见下方的 Button Transition 部分。 Click Event 列表类型，默认为空，用户添加的每一个事件由节点引用，组件名称和一个响应函数组成。详情见下方的 Button 点击事件 部分。 Button Transition Button 的 Transition 用来指定当用户点击 Button 时的状态表现。目前主要有 NONE，COLOR，SPRITE 和 SCALE。 Color Transition 属性 功能说明 Normal Button 在 Normal 状态下的颜色。 Pressed Button 在 Pressed 状态下的颜色。 Hover Button 在 Hover 状态下的颜色。 Disabled Button 在 Disabled 状态下的颜色。 Duration Button 状态切换需要的时间间隔。 Sprite Transition 属性 功能说明 Normal Button 在 Normal 状态下的 SpriteFrame。 Pressed Button 在 Pressed 状态下的 SpriteFrame。 Hover Button 在 Hover 状态下的 SpriteFrame。 Disabled Button 在 Disabled 状态下的 SpriteFrame。 Scale Transition 属性 功能 Duration Button 状态切换需要的时间间隔。 ZoomScale 当用户点击按钮后，按钮会缩放到一个值，这个值等于 Button 原始 scale * zoomScale, zoomScale 可以为负数 Button 点击事件 Button 目前只支持 Click 事件，即当用户点击并释放 Button 时才会触发相应的回调函数。 组件事件结构 属性 功能说明 Target 带有脚本组件的节点。 Component 脚本组件名称。 Handler 指定一个回调函数，当用户点击 Button 并释放时会触发此函数。 CustomEventData 用户指定任意的字符串作为事件回调的最后一个参数传入。 通过脚本代码添加回调 方法一 这种方法添加的事件回调和使用编辑器添加的事件回调是一样的，都是通过代码添加。首先需要构造一个 EventHandler 对象，然后设置好对应的 target、component、handler 和 customEventData 参数。 import { _decorator, Component, Event, Node, ButtonComponent, EventHandler } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { onLoad(){ const clickEventHandler = new EventHandler(); clickEventHandler.target = this.node; // 这个 node 节点是你的事件处理代码组件所属的节点 clickEventHandler.component = 'example';// 这个是代码文件名 clickEventHandler.handler = 'callback'; clickEventHandler.customEventData = 'foobar'; const button = this.node.getComponent(ButtonComponent); button.clickEvents.push(clickEventHandler); } callback(event: Event, customEventData: string){ // 这里 event 是一个 Touch Event 对象，你可以通过 event.target 取到事件的发送节点 const node = event.target as Node; const button = node.getComponent(ButtonComponent); console.log(customEventData); // foobar } } 方法二 通过 button.node.on('click', ...) 的方式来添加，这是一种非常简便的方式，但是该方式有一定的局限性，在事件回调里面无法 获得当前点击按钮的屏幕坐标点。 // 假设我们在一个组件的 onLoad 方法里面添加事件处理回调，在 callback 函数中进行事件处理 import { _decorator, Component, ButtonComponent } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { @property(ButtonComponent) button: ButtonComponent | null = null; onLoad(){ this.button.node.on('click', this.callback, this); } callback(button: ButtonComponent){ // 注意这种方式注册的事件，无法传递 customEventData } } 其他基础模块参考 渲染模块参考 "},"ui-system/components/editor/layout.html":{"url":"ui-system/components/editor/layout.html","title":"Layout 组件参考","keywords":"","body":"Layout 组件参考 Layout 是一种容器组件，容器能够开启自动布局功能，自动按照规范排列所有子物体，方便用户制作列表、翻页等功能。 水平布局容器 垂直布局容器 网格布局容器 点击 属性检查器 下面的 添加组件 按钮，然后选择 UI/Layout 即可添加 Layout 组件到节点上。 Layout 属性 属性 功能说明 Type 布局类型，支持 NONE, HORIZONTAL，VERTICAL 和 GRID。详情请参考 自动布局。 ResizeMode 缩放模式，支持 NONE，CHILDREN 和 CONTAINER。 PaddingLeft 排版时，子物体相对于容器左边框的距离。 PaddingRight 排版时，子物体相对于容器右边框的距离。 PaddingTop 排版时，子物体相对于容器上边框的距离。 PaddingBottom 排版时，子物体相对于容器下边框的距离。 SpacingX 水平排版时，子物体与子物体在水平方向上的间距。NONE 模式无此属性。 SpacingY 垂直排版时，子物体与子物体在垂直方向上的间距。NONE 模式无此属性。 Horizontal Direction 指定水平排版时，第一个子节点从容器的左边还是右边开始布局。当容器为 Grid 类型时，此属性和 Start Axis 属性一起决定 Grid 布局元素的起始水平排列方向。 Vertical Direction 指定垂直排版时，第一个子节点从容器的上面还是下面开始布局。当容器为 Grid 类型时，此属性和 Start Axis 属性一起决定 Grid 布局元素的起始垂直排列方向。 Cell Size 此属性只在 Grid 布局、Children 缩放模式时存在，指定网格容器里面排版元素的大小。 Start Axis 此属性只在 Grid 布局时存在，指定网格容器里面元素排版指定的起始方向轴。 Affected By Scale 子节点的缩放是否影响布局。 详细说明 添加 Layout 组件之后，默认的布局类型是 NONE，它表示容器不会修改子物体的大小和位置，当用户手动摆放子物体时，容器会以能够容纳所有子物体的最小矩形区域作为自身的大小。 通过修改 属性检查器 里面的 Type 可以切换布局容器的类型，可以切换成水平，垂直或者网格布局。 另外，所有的容器均支持 ResizeMode（NONE 容器只支持 NONE 和 CONTAINER）。 当 ResizeMode 设置为 NONE 时，子物体和容器的大小变化互不影响。 设置为 CHILDREN 则子物体大小会随着容器的大小而变化。 设置为 CONTAINER 则容器的大小会随着子物体的大小变化。 在使用网格布局时，当 Start Axis 设置为 HORIZONTAL 时, 将在新行开始之前填充整行。设置为 VERTICAL 时, 它将在新列开始之前填充整个列。 注意：Layout 设置后的结果需要到下一帧才会更新，除非你设置完以后手动调用 updateLayout API。 其他基础模块参考 渲染模块参考 "},"ui-system/components/editor/editbox.html":{"url":"ui-system/components/editor/editbox.html","title":"EditBox 组件参考","keywords":"","body":"EditBox 组件参考 EditBox 是一种文本输入组件，该组件让你可以轻松获取用户输入的文本。 点击 属性检查器 下面的 添加组件 按钮，然后从 UI/EditBox 即可添加 EditBox 组件到节点上。 EditBox 属性 属性 功能说明 BackgroundImage 输入框背景节点上挂载的 Sprite 组件对象 FontColor 输入框文本的颜色 FontSize 输入框文本的字体大小 InputFlag 指定输入标识：可以指定输入方式为密码或者单词首字母大写（仅支持 Android 平台） InputMode 指定输入模式: ANY 表示多行输入，其它都是单行输入，移动平台上还可以指定键盘样式。 LineHeight 输入框文本的行高 MaxLength 输入框最大允许输入的字符个数 Placeholder 输入框占位符的文本内容 PlaceholderFontColor 输入框占位符的文本字体颜色 PlaceholderFontSize 输入框占位符的文本字体大小 PlaceholderLabel 输入框占位符节点上挂载的 Label 组件对象 ReturnType 指定移动设备上面回车按钮的样式 String 输入框的初始输入内容，如果为空则会显示占位符的文本 TabIndex 修改 DOM 输入元素的 tabIndex，这个属性只有在 Web 上面修改有意义。 TextLabel 输入框输入文本节点上挂载的 Label 组件对象 EditBox 事件 事件结构参考：组件事件结构 Editing Did Began：该事件在用户点击输入框获取焦点的时候被触发。 Editing Did Ended：在单行模式下面，一般是在用户按下回车或者点击屏幕输入框以外的地方调用该函数。 如果是多行输入，一般是在用户点击屏幕输入框以外的地方调用该函数。 Text Changed：该事件在用户每一次输入文字变化的时候被触发。 详细说明 如果需要输入密码，则需要把 Input Flag 设置为 password，同时 Input Mode 必须是 Any 之外的选择，一般选择 Single Line。 如果要输入多行，可以把 Input Mode 设置为 Any。 背景图片支持九宫格缩放 通过脚本代码添加回调 方法一 这种方法添加的事件回调和使用编辑器添加的事件回调是一样的，都是通过代码添加。首先需要构造一个 EventHandler 对象，然后设置好对应的 target、component、handler 和 customEventData 参数。 import { _decorator, Component, EditBoxComponent, EventHandler } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { onLoad() { const editboxEventHandler = new EventHandler(); editboxEventHandler.target = this.node; // 这个 node 节点是你的事件处理代码组件所属的节点 editboxEventHandler.component = 'example'; editboxEventHandler.handler = 'onEditDidBegan'; editboxEventHandler.customEventData = 'foobar'; const editbox = this.node.getComponent(EditBoxComponent); editbox.editingDidBegan.push(editboxEventHandler); // 你也可以通过类似的方式来注册其它回调函数 // editbox.editingDidEnded.push(editboxEventHandler); // editbox.textChanged.push(editboxEventHandler); // editbox.editingReturn.push(editboxEventHandler); } onEditDidBegan(editbox, customEventData) { // 这里 editbox 是一个 cc.EditBox 对象 // 这里的 customEventData 参数就等于你之前设置的 \"foobar\" } // 假设这个回调是给 editingDidEnded 事件的 onEditDidEnded(editbox, customEventData) { // 这里 editbox 是一个 cc.EditBox 对象 // 这里的 customEventData 参数就等于你之前设置的 \"foobar\" } // 假设这个回调是给 textChanged 事件的 onTextChanged(text, editbox, customEventData) { // 这里的 text 表示修改完后的 EditBox 的文本内容 // 这里 editbox 是一个 cc.EditBox 对象 // 这里的 customEventData 参数就等于你之前设置的 \"foobar\" } // 假设这个回调是给 editingReturn 事件的 onEditingReturn(editbox, customEventData) { // 这里 editbox 是一个 cc.EditBox 对象 // 这里的 customEventData 参数就等于你之前设置的 \"foobar\" } } 方法二 通过 editbox.node.on('editing-did-began', ...) 的方式来添加 // 假设我们在一个组件的 onLoad 方法里面添加事件处理回调，在 callback 函数中进行事件处理: import { _decorator, Component, EditBoxComponent } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { @property(EditBoxComponent) editbox: EditBoxComponent | null = null; onLoad(){ this.editbox.node.on('editing-did-began', this.callback, this); } callback(editbox: EditBoxComponent){ // 回调的参数是 editbox 组件，注意这种方式注册的事件，无法传递 customEventData } } 同样的，你也可以注册 editing-did-ended, text-changed 和 editing-return 事件，这些事件的回调函数的参数与 editing-did-began 的参数一致。 其他基础模块参考 渲染模块参考 "},"ui-system/components/editor/scrollview.html":{"url":"ui-system/components/editor/scrollview.html","title":"ScrollView 组件参考","keywords":"","body":"ScrollView 组件参考 ScrollView 是一种带滚动功能的容器，它提供一种方式可以在有限的显示区域内浏览更多的内容。通常 ScrollView 会与 Mask 组件配合使用，同时也可以添加 ScrollBar 组件来显示浏览内容的位置。 点击 属性检查器 下面的 添加组件 按钮，然后选择 UI/ScrollView 即可添加 ScrollView 组件到节点上。 ScrollView 属性 属性 功能说明 content 它是一个节点引用，用来创建 ScrollView 的可滚动内容，通常这可能是一个包含一张巨大图片的节点。 Horizontal 布尔值，是否允许横向滚动。 Vertical 布尔值，是否允许纵向滚动。 Inertia 滚动的时候是否有加速度。 Brake 浮点数，滚动之后的减速系数。取值范围是 0-1，如果是 1 则立马停止滚动，如果是 0，则会一直滚动到 content 的边界。 Elastic 布尔值，是否回弹。 BounceDuration 浮点数，回弹所需要的时间。取值范围是 0-10。 HorizontalScrollBar 它是一个节点引用，用来创建一个滚动条来显示 content 在水平方向上的位置。 VerticalScrollBar 它是一个节点引用，用来创建一个滚动条来显示 content 在垂直方向上的位置 ScrollEvents 列表类型，默认为空，用户添加的每一个事件由节点引用，组件名称和一个响应函数组成。详情见下方的 ScrollView 事件 CancelInnerEvents 如果这个属性被设置为 true，那么滚动行为会取消子节点上注册的触摸事件，默认被设置为 true。 ScrollView 事件 事件结构参考：组件事件结构 ScrollView 的事件回调有两个参数，第一个参数是 ScrollView 本身，第二个参数是 ScrollView 的事件类型。 ScrollBar 设置 ScrollBar 是可选的，你可以选择只设置 Horizontal ScrollBar 或者 Vertical ScrollBar，当然也可以两者都设置。建立关联可以通过在 层级管理器 里面拖拽一个带有 ScrollBar 组件的节点到 ScrollView 的相应字段完成。 详细说明 ScrollView 组件必须有指定的 content 节点才能起作用，通过指定滚动方向和 content 节点在此方向上的长度来计算滚动时的位置信息，Content 节点也可以通过添加 WidgetComponent 设置自动 resize，也可以通过添加 LayoutComponent 来完成子节点布局，但是这两个组件不应该同时添加到一个节点上以避免产生不可预料的后果。 通常一个 ScrollView 的节点树如下图： 这里的 view 用来定义一个可以显示的滚动区域，所以通常 MaskComponent 组件会被添加到 view 上。可以滚动的内容可以直接放到 content 节点或者添加节 content 的子节点上。 通过脚本代码添加回调 方法一 这种方法添加的事件回调和使用编辑器添加的事件回调是一样的，都是通过代码添加。首先需要构造一个 EventHandler 对象，然后设置好对应的 target、component、handler 和 customEventData 参数。 import { _decorator, Component, ScrollViewComponent, EventHandler } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { onLoad() { const scrollViewEventHandler = new EventHandler(); scrollViewEventHandler.target = this.node; // 这个 node 节点是你的事件处理代码组件所属的节点 scrollViewEventHandler.component = 'example';// 这个是代码文件名 scrollViewEventHandler.handler = 'callback'; scrollViewEventHandler.customEventData = 'foobar'; const scrollview = this.node.getComponent(ScrollViewComponent); scrollview.scrollEvents.push(scrollViewEventHandler); } callback(scrollview, eventType, customEventData){ // 这里 scrollview 是一个 Scrollview 组件对象实例 // 这里的 eventType === ScrollViewComponent.EventType enum 里面的值 // 这里的 customEventData 参数就等于你之前设置的 'foobar' } } 方法二 通过 scrollview.node.on('scroll-to-top', ...) 的方式来添加 // 假设我们在一个组件的 onLoad 方法里面添加事件处理回调，在 callback 函数中进行事件处理: import { _decorator, Component, ScrollViewComponent } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { @property(ScrollViewComponent) scrollview: ScrollViewComponent | null = null; onLoad(){ this.scrollview.node.on('scroll-to-top', this.callback, this); } callback(scrollView: ScrollViewComponent){ // 回调的参数是 ScrollView 组件，注意这种方式注册的事件，无法传递 customEventData } } 同样的，你也可以注册 scrolling, touch-up, scroll-began 等事件，这些事件的回调函数的参数与 scroll-to-top 的参数一致。 其他基础模块参考 渲染模块参考 "},"ui-system/components/editor/scrollbar.html":{"url":"ui-system/components/editor/scrollbar.html","title":"ScrollBar 组件参考","keywords":"","body":"ScrollBar 组件参考 ScrollBar 允许用户通过拖动滑块来滚动一张图片（公测版本暂不支持），它与 Slider 组件有点类似，但是它主要是用于滚动而 Slider 则用来设置数值。 点击 属性检查器 下面的 添加组件 按钮，然后选择 UI/ScrollBar 即可添加 ScrollBar 组件到节点上。 ScrollBar 属性 属性 功能说明 Handle ScrollBar 前景图片，它的长度/宽度会根据 ScrollView 的 content 的大小和实际显示区域的大小来计算。 Direction 滚动方向，目前包含水平和垂直两个方向。 Enable Auto Hide 是否开启自动隐藏，如果开启了，那么在 ScrollBar 显示后的 Auto Hide Time 时间内会自动消失。 Auto Hide Time 自动隐藏时间，需要配合设置 Enable Auto Hide 详细说明 ScrollBar 一般不会单独使用，它需要与 ScrollView 配合使用，另外 ScrollBar 需要指定一个 Sprite 组件，即属性面板里面的 Handle。 通常我们还会给 ScrollBar 指定一张背景图片，用来指示整个 ScrollBar 的长度或者宽度。 其他基础模块参考 渲染模块参考 "},"ui-system/components/editor/progress.html":{"url":"ui-system/components/editor/progress.html","title":"ProgressBar 组件参考","keywords":"","body":"ProgressBar 组件参考 ProgressBar（进度条）经常被用于在游戏中显示某个操作的进度，在节点上添加 ProgressBar 组件，然后给该组件关联一个 Bar Sprite 就可以在场景中控制 Bar Sprite 来显示进度了。 点击 属性检查器 下面的 添加组件 按钮，然后选择 UI/ProgressBar 即可添加 ProgressBar 组件到节点上。 ProgressBar 属性 属性 功能说明 Bar Sprite 进度条渲染所需要的 Sprite 组件，可以通过拖拽一个带有 Sprite 组件的节点到该属性上来建立关联。 Mode 支持 HORIZONTAL（水平）、VERTICAL（垂直）和 FILLED（填充）三种模式，可以通过配合 reverse 属性来改变起始方向。 Total Length 当进度条为 100% 时 Bar Sprite 的总长度/总宽度。在 FILLED 模式下 Total Length 表示取 Bar Sprite 总显示范围的百分比，取值范围从 0 ~ 1。 Progress 浮点，取值范围是 0~1，不允许输入之外的数值。 Reverse 布尔值，默认的填充方向是从左至右/从下到上，开启后变成从右到左/从上到下。 详细说明 添加 ProgressBar 组件之后，通过从 层级管理器 中拖拽一个带有 Sprite 组件的节点到 Bar Sprite 属性上，此时便可以通过拖动 progress 滑块来控制进度条的显示了。 Bar Sprite 可以是自身节点，子节点，或者任何一个带有 Sprite 组件的节点。另外，Bar Sprite 可以自由选择 Simple、Sliced 和 Filled 渲染模式。 进度条的模式选择 FILLED 的情况下，Bar Sprite 的 Type 也需要设置为 FILLED，否则会报警告。 其他基础模块参考 渲染模块参考 "},"ui-system/components/editor/label-outline.html":{"url":"ui-system/components/editor/label-outline.html","title":"LabelOutline 组件参考","keywords":"","body":"LabelOutline 组件参考 LabelOutline 组件会为所在节点的 Label 添加描边效果，不支持 BMFont 字体。 点击 属性检查器 下方的 添加组件 按钮，然后从 UI 中选择 LabelOutline，即可添加 LabelOutline 组件到节点上。 LabelOutline 属性 属性 功能说明 Color 字体发光边缘颜色 Width 字体发光边缘宽度 其他渲染模块参考 基础模块参考 "},"ui-system/components/editor/toggle.html":{"url":"ui-system/components/editor/toggle.html","title":"Toggle 组件参考","keywords":"","body":"Toggle 组件参考 Toggle 是一个 CheckBox，当它和 ToggleGroup 一起使用的时候，可以变成 RadioButton。 点击 属性检查器 下面的 添加组件 按钮，然后选择 UI/Toggle 即可添加 Toggle 组件到节点上。 Toggle 属性 属性 功能说明 isChecked 布尔类型，如果这个设置为 true，则 check mark 组件会处于 enabled 状态，否则处于 disabled 状态。 checkMark SpriteComponent 类型，Toggle 处于选中状态时显示的图片 toggleGroup ToggleContainerComponent 类型， Toggle 所属的 ToggleGroup，这个属性是可选的。如果这个属性为 null，则 Toggle 是一个 CheckBox，否则，Toggle 是一个 RadioButton。 Check Events 列表类型，默认为空，用户添加的每一个事件由节点引用，组件名称和一个响应函数组成。详情见下方的 Toggle 事件 部分 注意：因为 Toggle 继承自 Button，所以关于 Toggle 的 Button 相关属性的详细说明和用法请参考 Button 组件。 Toggle 事件 事件结构参考：组件事件结构。 Toggle 的事件回调有二个参数，第一个参数是 Toggle 本身, 第二个参数是 customEventData。 详细说明 Toggle 组件的节点树一般为： 这里需要注意的是，checkMark 组件所在的节点需要放在 background 节点的上面。 通过脚本代码添加回调 方法一 这种方法添加的事件回调和使用编辑器添加的事件回调是一样的，都是通过代码添加。首先需要构造一个 EventHandler 对象，然后设置好对应的 target、component、handler 和 customEventData 参数。 import { _decorator, Component, Event, Node, ToggleComponent, EventHandler } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { onLoad(){ const checkEventHandler = new EventHandler(); checkEventHandler.target = this.node; //这个 node 节点是你的事件处理代码组件所属的节点 checkEventHandler.component = 'example';//这个是代码文件名 checkEventHandler.handler = 'callback'; checkEventHandler.customEventData = 'foobar'; const toggle = this.node.getComponent(ToggleComponent); toggle.checkEvents.push(checkEventHandler); } callback(event: Event, customEventData: string){ //这里 event 是一个 Touch Event 对象，你可以通过 event.target 取到事件的发送节点 // 这里的 customEventData 参数就等于之前设置的 'foobar' } } 方法二 通过 toggle.node.on('toggle', ...) 的方式来添加 // 假设我们在一个组件的 onLoad 方法里面添加事件处理回调，在 callback 函数中进行事件处理: import { _decorator, Component, ToggleComponent } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { @property(ToggleComponent) toggle: ToggleComponent | null = null; onLoad(){ this.toggle.node.on('toggle', this.callback, this); } callback(toggle: ToggleComponnet){ // 回调的参数是 toggle 组件，注意这种方式注册的事件，无法传递 customEventData } } 其他基础模块参考 渲染模块参考 "},"ui-system/components/editor/toggleContainer.html":{"url":"ui-system/components/editor/toggleContainer.html","title":"ToggleContainer 组件参考","keywords":"","body":"ToggleContainer 组件参考 ToggleContainer 不是一个可见的 UI 组件，它可以用来修改一组 Toggle 组件的行为。当一组 Toggle 属于同一个 ToggleContainer 的时候，任何时候只能有一个 Toggle 处于选中状态。 注意：所有包含 Toggle 组件的一级子节点都会自动被添加到该容器中 点击 属性检查器 下面的 添加组件 按钮，然后选择 UI/ToggleContainer 即可添加 ToggleContainer 组件到节点上。 ToggleContainer 属性 属性 功能说明 AllowSwitchOff 如果这个设置为 true， 那么 toggle 按钮在被点击的时候可以反复地被选中和未选中。 CheckEvents 选中事件。列表类型，默认为空，用户添加的每一个事件由节点引用，组件名称和一个响应函数组成。 ToggleContainer 事件 事件结构参考：组件事件结构 | ToggleContainer 的事件回调有二个参数，第一个参数是 Toggle 本身, 第二个参数是 customEventData。 详细说明 ToggleContainer 一般不会单独使用，它需要与 Toggle 配合使用来实现 RadioButton 的单选效果。 通过脚本代码添加回调 这种方法添加的事件回调和使用编辑器添加的事件回调是一样的，都是通过代码添加。首先需要构造一个 EventHandler 对象，然后设置好对应的 target、component、handler 和 customEventData 参数。 import { _decorator, Component, Event, Node, ToggleContainerComponent, EventHandler } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { onLoad(){ const containerEventHandler = new EventHandler(); containerEventHandler.target = this.node; // 这个 node 节点是你的事件处理代码组件所属的节点 containerEventHandler.component = 'example';// 这个是代码文件名 containerEventHandler.handler = 'callback'; containerEventHandler.customEventData = 'foobar'; const container = this.node.getComponent(ToggleContainerComponent); container.checkEvents.push(containerEventHandler); } callback(event: Event, customEventData: string){ //这里 event 是一个 Touch Event 对象，你可以通过 event.target 取到事件的发送节点 // 这里的 customEventData 参数就等于之前设置的 'foobar' } } 其他基础模块参考 渲染模块参考 "},"ui-system/components/editor/slider.html":{"url":"ui-system/components/editor/slider.html","title":"Slider 组件参考","keywords":"","body":"Slider 组件参考 Slider 是一个滑动器组件。 点击 属性检查器 下面的 添加组件 按钮，然后选择 UI/Slider 即可添加 Slider 组件到节点上。 Slider 属性 属性 功能说明 handle 滑块按钮部件，可以通过该按钮进行滑动调节 Slider 数值大小 direction 滑动器的方向，分为横向和竖向 progress 当前进度值，该数值的区间是 0-1 之间 slideEvents 滑动器组件事件回调函数 Slider 事件 事件结构参考：组件事件结构 | Slider 的事件回调有两个参数，第一个参数是 Slider 本身，第二个参数是 CustomEventData 详细说明 Slider 通常用于调节 UI 的数值（例如音量调节），它主要的部件是一个滑块按钮，该部件用于用户交互，通过该部件可进行调节 Slider 的数值大小。 通常一个 Slider 的节点树如下图： 通过脚本代码添加回调 方法一 这种方法添加的事件回调和使用编辑器添加的事件回调是一样的，都是通过代码添加。首先需要构造一个 EventHandler 对象，然后设置好对应的 target、component、handler 和 customEventData 参数。 import { _decorator, Component, Event, Node, SliderComponent, EventHandler } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { onLoad(){ const sliderEventHandler = new EventHandler(); sliderEventHandler.target = this.node; //这个 node 节点是你的事件处理代码组件所属的节点 sliderEventHandler.component = 'example';//这个是代码文件名 sliderEventHandler.handler = 'callback'; sliderEventHandler.customEventData = 'foobar'; const slider = this.node.getComponent(SliderComponent); slider.slideEvents.push(sliderEventHandler); } callback(event: Event, customEventData: string){ //这里 event 是一个 Touch Event 对象，你可以通过 event.target 取到事件的发送节点 // 这里的 customEventData 参数就等于之前设置的 'foobar' } } 方法二 通过 slider.node.on('slide', ...) 的方式来添加 // 假设我们在一个组件的 onLoad 方法里面添加事件处理回调，在 callback 函数中进行事件处理: import { _decorator, Component, SliderComponent } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { @property(SliderComponent) slider: SliderComponent | null = null; onLoad(){ this.toggle.node.on('toggle', this.callback, this); } callback(slider: SliderComponent){ // 回调的参数是 slider 组件，注意这种方式注册的事件，无法传递 customEventData } } 其他基础模块参考 渲染模块参考 "},"ui-system/components/editor/pageview.html":{"url":"ui-system/components/editor/pageview.html","title":"PageView 组件参考","keywords":"","body":"PageView 组件参考 PageView 是一种页面视图容器. 点击 属性检查器 下面的 添加组件 按钮，然后选择 UI/PageView 即可添加 PageView 组件到节点上。 PageView 属性 属性 功能说明 SizeMode 页面视图中每个页面大小类型，目前有 Unified 和 Free 类型。 Content 它是一个节点引用，用来创建 PageView 的可滚动内容 Direction 页面视图滚动方向 ScrollThreshold 滚动临界值，默认单位百分比，当拖拽超出该数值时，松开会自动滚动下一页，小于时则还原 AutoPageTurningThreshold 快速滑动翻页临界值，当用户快速滑动时，会根据滑动开始和结束的距离与时间计算出一个速度值，该值与此临界值相比较，如果大于临界值，则进行自动翻页 Inertia 否开启滚动惯性 Brake 开启惯性后，在用户停止触摸后滚动多快停止，0 表示永不停止，1 表示立刻停止 Elastic 布尔值，是否回弹 Bounce Duration 浮点数，回弹所需要的时间。取值范围是 0-10 Indicator 页面视图指示器组件 PageTurningEventTiming 设置 PageView、PageTurning 事件的发送时机 PageEvents 数组，滚动视图的事件回调函数 CancelInnerEvents 布尔值，是否在滚动行为时取消子节点上注册的触摸事件 PageViewIndicator 设置 PageViewIndicator 是可选的，该组件是用来显示页面的个数和标记当前显示在哪一页。 建立关联可以通过在 层级管理器 里面拖拽一个带有 PageViewIndicator 组件的节点到 PageView 的相应字段完成。 PageView 事件 属性 功能说明 Target 带有脚本组件的节点 Component 脚本组件名称 Handler 指定一个回调函数，当 PageView 的事件发生的时候会调用此函数 CustomEventData 用户指定任意的字符串作为事件回调的最后一个参数传入 PageView 的事件回调有两个参数，第一个参数是 PageView 本身，第二个参数是 PageView 的事件类型。 详细说明 PageView 组件必须有指定的 content 节点才能起作用，content 中的每个子节点为一个单独页面，且每个页面的大小为 PageView 节点的大小，如果节点大小大于内容大小的话，可能会导致出现滚动不完整的现象。在 PageView 组件下有一个 view 节点对象，该对象结合 ScrollThreshold 决定了当前滑动的距离是否达到可以翻页的条件，操作效果分为以下两种： 缓慢滑动：通过拖拽视图中的页面到达指定的 ScrollThreshold 数值（该数值是页面大小的百分比）以后松开会自动滑动到下一页。 快速滑动：快速的向一个方向进行拖动，自动滑倒下一页，每次滑动最多只能一页。 通过脚本代码添加回调 方法一 这种方法添加的事件回调和使用编辑器添加的事件回调是一样的，都是通过代码添加。首先需要构造一个 EventHandler 对象，然后设置好对应的 target、component、handler 和 customEventData 参数。 import { _decorator, Component, Event, Node, PageViewComponent, EventHandler } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { onLoad(){ const pageChangedEventHandler = new EventHandler(); pageChangedEventHandler.target = this.node; //这个 node 节点是你的事件处理代码组件所属的节点 pageChangedEventHandler.component = 'example';//这个是代码文件名 pageChangedEventHandler.handler = 'callback'; pageChangedEventHandler.customEventData = 'foobar'; const page = this.node.getComponent(PageViewComponent); page.clickEvents.push(pageChangedEventHandler); } callback(event: Event, customEventData: string){ //这里 event 是一个 Touch Event 对象，你可以通过 event.target 取到事件的发送节点 const node = event.target as Node; const pageview = node.getComponent(PageViewComponent); console.log(customEventData); // foobar } } 方法二 通过 pageView.node.on('page-turning', ...) 的方式来添加 // 假设我们在一个组件的 onLoad 方法里面添加事件处理回调，在 callback 函数中进行事件处理: import { _decorator, Component, Event, Node, PageViewComponent } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { onLoad(){ this.pageView.node.on('page-turning', this.callback, this); } callback(pageView: PageViewComponent){ // 回调的参数是 pageView 组件 // 另外，注意这种方式注册的事件，也无法传递 customEventData } } 其他基础模块参考 渲染模块参考 "},"ui-system/components/editor/pageviewindicator.html":{"url":"ui-system/components/editor/pageviewindicator.html","title":"PageViewIndicator 组件参考","keywords":"","body":"PageviewIndicator 组件参考 PageviewIndicator 用于显示 PageView 当前的页面数量和标记当前所在的页面。 点击 属性检查器 下面的 添加组件 按钮，然后选择 UI/PageViewIndicator 即可添加 PageViewIndicator 组件到节点上。 PageviewIndicator 属性 属性 功能说明 spriteFrame 每个页面标记显示的图片 direction 页面标记摆放方向，分别为 水平方向 和 垂直方向 cellSize 每个页面标记的大小 spacing 每个页面标记之间的边距 详细说明 PageViewIndicator 一般不会单独使用，它需要与 PageView 配合使用，可以通过相关属性，来进行创建相对应页面的数量的标记，当你滑动到某个页面的时，PageViewIndicator 就会高亮它对应的标记。 其他基础模块参考 渲染模块参考 "},"ui-system/components/editor/ui-model.html":{"url":"ui-system/components/editor/ui-model.html","title":"UIModel 组件参考","keywords":"","body":"UIModel 组件参考 UIModel 是一个将 3D 模型从 3D 渲染管线转换到 2D 渲染管线的带有转换功能的渲染组件。该组件支持 3D 模型和粒子在 UI 上的显示，没有这个组件，即使模型和粒子节点在 UI 里也不会被渲染。 该组件的添加方式是在层级管理器中选中带有或继承自 ModelComponent 组件的节点，然后点击 属性检查器 下方的 添加组件 按钮，选择 UI/Model 即可。而粒子则是添加到粒子节点上。通常结构如下所示： 其他基础模块参考 渲染模块参考 "},"ui-system/components/editor/ui-opacity.html":{"url":"ui-system/components/editor/ui-opacity.html","title":"UIOpacity 组件参考","keywords":"","body":"UIOpacity（透明度设置）组件参考 该组件会为节点记录一个透明度修改标识用来影响到后续的渲染节点。一般用于非渲染节点，如果作用在渲染节点上会形成透明度叠加现象。渲染节点可以通过设置 color 的 alpha 通道来设置透明度。 UIOpacity 属性 属性 功能说明 Opacity 透明度。 其他基础模块参考 渲染模块参考 "},"ui-system/components/editor/block-input-enents.html":{"url":"ui-system/components/editor/block-input-enents.html","title":"BlockInputEvents 组件参考","keywords":"","body":"BlockInputEvents 组件参考 BlockInputEvents 组件将拦截所属节点 bounding box 内的所有输入事件（鼠标和触摸），防止输入穿透到下层节点，一般用于上层 UI 的背景。 当我们制作一个弹出式的 UI 对话框时，对话框的背景默认不会截获事件。也就是说虽然它的背景挡住了游戏场景，但是在背景上点击或触摸时，下面被遮住的游戏元素仍然会响应点击事件。这时我们只要在背景所在的节点上添加这个组件，就能避免这种情况。 该组件没有任何 API 接口，直接添加到场景即可生效。 "},"scripting/":{"url":"scripting/","title":"脚本指南及事件机制","keywords":"","body":"脚本 Cocos Creator 3D 脚本用于实现用户定义的（游戏）行为。 脚本创建 脚本基础 语言支持 脚本执行顺序 cc 类 访问节点和其他组件 常用节点和组件接口 生命周期回调 创建和销毁节点 加载和切换场景 获取和加载资源 使用计时器 组件 组件顺序 属性参数参考 插件脚本 CCClass 进阶参考 添加 Log 废弃API 事件机制 作为引擎中极为常用的系统，我们提供了完整高效的事件系统给开发者使用，详情介绍请见： 事件机制 "},"scripting/setup.html":{"url":"scripting/setup.html","title":"脚本创建","keywords":"","body":"创建脚本 创建组件脚本 在 Cocos Creator 3D 中，脚本也是资源的一部分。你可以在资源编辑器中通过点击\"创建\"按钮来添加并选择 TypeScript 来创建一份组件脚本。此时你会在你的资源编辑器中得到一份新的脚本： 一份简单的组件脚本如下： import { _decorator, Component, Node } from 'cc'; const { ccclass, property } = _decorator; @ccclass('NewScript') export class NewScript extends Component { /* class member could be defined like this */ // dummy = ''; /* use `property` decorator if your want the member to be serializable */ // @property // serializableDummy = 0; start () { // Your initialization goes here. } // update (deltaTime: number) { // // Your update function goes here. // } } 请注意，我们更推荐用户使用 TypeScript 来编写脚本，但如果用户想要使用 JavaScript 来编写脚本的话，可以直接在操作系统的文件夹中创建 js 文件，也可以在代码编辑器中创建 js 文件。 编辑脚本 用户可根据自己的需求，选择自己喜爱的文本工具（如：Vim, Sublime Text, Web Storm, VSCode...）进行脚本编辑，请先到 设置 中进行设置。 通过双击脚本资源，可以直接打开脚本编辑器进行编辑。当编辑完脚本并保存，Cocos Creator 3D 会自动检测到脚本的改动，并迅速编译。 在代码编写之前，请先阅读 脚本基础 了解更多关于脚本的内容。 添加脚本到场景节点中 将脚本添加到场景节点中，实际上就是为这个节点添加一份组件。我们先将刚刚创建出来的 NewScript.js 重命名为 say-hello.js。然后选中我们希望添加的场景节点，此时该节点的属性会显示在 属性检查器 中。在 属性检查器 的最下方有一个 添加组件 的按钮，点击按钮并选择 添加用户脚本 -> say-hello 来添加我们刚刚编写的脚本组件。 如果一切顺利，你将会看到你的脚本显示在 属性检查器 中： 注意：用户也可以通过直接拖拽脚本资源到 属性检查器 的方式来添加脚本。 默认脚本编辑工具配置 继续前往 脚本基础。 "},"scripting/basic.html":{"url":"scripting/basic.html","title":"脚本基础","keywords":"","body":"运行环境 Cocos Creator 3D 引擎的 API 都存在于模块 cc中， 使用标准的 ES6 模块导入语法将其导入： import { Component, // 导入类 Component _decorator, // 导入命名空间 _decorator } from \"cc\"; import * as cc from \"cc\"; // 将整个 Cocos Creator 3D 模块导入为命名空间 Cocos Creator 3D @_decorator.ccclass(\"MyComponent\") export class MyComponent extends Component { public v = new cc.Vec3(); } 保留标识符 cc 注意，由于历史原因，cc 是 Cocos Creator 3D 保留使用的标识符， 其行为相当于在任何模块顶部已经定义了名为 cc 的对象。 因此，你不应该将 cc 用作任何全局对象的名称： /* const cc = {}; // 每个 Cocos Creator 3D 脚本都等价于在此处含有隐式定义 */ import * as cc from \"cc\"; // 错误：命名空间导入名称 cc 由 Cocos Creator 3D 保留使用 const cc = { x: 0 }; console.log(cc.x); // 错误：全局对象名称 cc 由 Cocos Creator 3D 保留使用 function f () { const cc = { x: 0 }; console.log(cc.x); // 正确：cc 可以用作局部对象的名称 const o = { cc: 0 }; console.log(o.cc); // 正确：cc 可以用作属性名 } console.log(cc, typeof cc); // 错误：行为是未定义的 "},"scripting/language-support.html":{"url":"scripting/language-support.html","title":"语言支持","keywords":"","body":"语言支持 JavaScript 语言特性 Creator 3D 支持的 JavaScript 语言规范为 ES6。 此外，以下几项更新于 ES6 规范的语言特性或提案仍旧在支持之列： 类字段 Promise 对象 可选链操作符 空值合并操作符 全局对象 globalThis 以下语言特性同样支持，但需要开启相关的编译选项： 异步函数 特别地，Creator 3D 目前支持 “Legacy” 装饰器提案，其用法和含义见 babel-plugin-proposal-decorators。 由于该 提案 仍处于 阶段2， 引擎暴露的所有装饰器相关功能接口都在以下划线开头的 _decorator 命名空间下。 运行环境 从用户的角度来说，Creator 3D 未绑定任何 JavaScript 实现。因此，Creator 3D 建议开发者严格依照 JavaScript 规范编写脚本，以获取更好的跨平台支持。 举例来说，当希望使用全局对象时，应当使用标准特性 globalThis： globalThis.blahBlah // 任何环境下 globalThis 一定存在 而非 window、global、self 或 this： typeof window // 可能是 'undefined' typeof global // 在浏览器环境下可能是 'undefined' 再如，Creator 3D 未提供 CommonJS 的模块系统，因此以下代码片段将带来问题： const blah = require('./blah-blah'); // 错误：`require` 是未定义的 module.exports = blah; // 错误：`module` 是未定义的 反之，应使用标准模块语法： import blah from './blah-blah'; export default blah; TypeScript Creator 3D 使用 babel 而非 tsc 编译 TypeScript 脚本。 特别地，使用了 @babel/plugin-transform-typescript 插件。基于此原因，TypeScript 的支持存在某些限制，以下列举出了一些重要的注意事项， 关于完整的说明，见 @babel/plugin-transform-typescript。 tsconfig.json 不会被读取； 隐含着 isolatedModules 选项，这意味着： 不支持 const enums； 导出声明中不应该导出 TypeScript 类型和接口。 不支持 export = 和 import =； 命名空间导出的变量必须声明为 const 而非 var 或 let； 同一命名空间的不同声明不会共享作用域，需要显式使用限定符。 编译时不会读取 tsconfig.json 意味着 tsconfig.json 的编译选项并不影响编译， 但存在例外，见 模块解析。 你仍然可以在项目中使用 tsconfig.json 以配合 IDE 实现类型检查等功能。 为了使得 IDE 的 TypeScript 检查功能 和 Creator 3D 行为兼容， 你需要额外注意一些事项，见 tsconfig。 模块解析 Creator 3D 使用 NodeJS 模块解析算法。 等价于如下的 tsconfig.json： {\"compilerOptions\": { \"moduleResolution\": \"node\" }} Typescript 的路径映射功能也受支持。 以下 tsconfig.json 选项将被读取并保持和 tsc 相同的语义： compilerOptions.baseUrl compilerOptions.paths "},"scripting/ccclass.html":{"url":"scripting/ccclass.html","title":"ccclass","keywords":"","body":"cc 类 将装饰器 ccclass 应用在类上时，此类称为 cc 类。 cc 类注入了额外的信息以控制 Cocos Creator 3D 对该类对象的序列化、编辑器对该类对象的展示等。 ccclass cc 类的各种特性是通过 ccclass(name) 的 cc 类选项参数来指定的。 cc 类名 选项 name 指定了 cc 类的名称。cc 类名应该是独一无二的。 当需要相应的 cc 类时，可以通过其 cc 类名来查找，例如： 序列化。 若对象是 cc 类对象， 则在序列化时将记录该对象的 cc 类名， 反序列化时将根据此名称找到相应的 cc 类进行序列化。 当 cc 类是组件类时，Node 通过可以组件类的 cc 类名查找该组件； cc 属性 当装饰器 property 应用在 cc 类的属性或访问器上时，此属性称为 cc 属性。 与 cc 类类似，cc 属性注入了额外的信息以控制 Cocos Creator 3D 对该属性的序列化、编辑器对该属性的展示等。 property cc 属性的各种特性是通过 property() 的 cc 属性选项参数来指定的。 cc 类型 选项 type 指定了属性的 cc 类型。 可以通过以下几种形式的参数指定类型： 构造函数。 构造函数所指定的类型就直接作为属性的 cc 类型。 注意，当 Javascript 内置构造函数 Number、String、Boolean 用作 cc 类型时将给出警告，并且将 分别视为 cc 类型 CCFloat、CCString、CCBoolean。 Cocos Creator 3D 内置属性类型标识。 CCInteger、CCFloat、CCBoolean、CCString 是内置属性类型标识。 CCInteger 声明类型为 Cocos Creator 3D 整数； CCFloat 声明类型为 Cocos Creator 3D 浮点数； CCString 声明类型为 Cocos Creator 3D 字符串； CCBoolean 声明类型为 Cocos Creator 3D 布尔值。 数组。 通过将构造函数、Cocos Creator 3D 内置属性类型标识或数组作为数组元素时， 属性被指定为 Cocos Creator 3D 数组。 例如 [CCInteger] 就将类型声明为元素为Cocos Creator 3D 整数的 Cocos Creator 3D 数组。 若属性未指定 cc 类型，Cocos Creator 3D 将从属性的默认值或初始化式的求值结果推导其 cc 类型： 若值的类型是 Javascript 原始类型 number、string、boolean， 则其 cc 类型分别为 Cocos Creator 3D 浮点数、Cocos Creator 3D 字符串、Cocos Creator 3D 布尔值。 否则，若值是对象类型，则相当于使用对象的构造函数指定了 cc 类型； 否则，属性的 cc 类型是未定义的。 一般地，仅需要在以下情况中需要显式地声明 cc 类型： 当需要将属性显示为整数时； 当属性的实际值可能是多个类型时。 关于 cc 类型如何影响 cc 属性以及对未定义 cc 类型的属性的处理，见： 属性类型 序列化参数 为了方便，额外提供了以下装饰器以快速声明 cc 类型： 等价于 @type(t) @property(t) @integer @property(CCInteger) @float @property(CCFloat) @string @property(CCString) @boolean @property(CCBoolean) 下列代码演示了不同 cc 类型 的 cc 属性的声明： import { _decorator, CCInteger, Node } from \"cc\"; const { ccclass, property, integer, float, boolean, string, type } = _decorator; @ccclass class MyClass { @integer // 声明属性 _id 的 cc 类型为 Cocos 整数 private _id = 0; @type(Node) // 声明属性 _targetNode 的 cc 类型为 Node private _targetNode: Node | null = null; @type([Node]) // 声明属性 _children 的 cc 类型为 Node 数组 private _children: Node[] = []; @property private _count = 0; // 未声明 cc 类型，从初始化式的求值结果推断为 Cocos 浮点数 @type(String) // 警告：不应该使用构造函数 String // 等价于 CCString private _name: string = ''; @property private _children2 = []; // 未声明 cc 类型，从初始化式的求值结果推断为：元素为未定义的 Cocos 数组 } 默认值 选项 default 指定了 cc 属性的默认值。 构造函数 通过 constructor 定义 CCClass 的构造函数使用 constructor 定义，为了保证反序列化能始终正确运行，constructor 不允许定义构造参数。 开发者如果确实需要使用构造参数，可以通过 arguments 获取，但要记得如果这个类会被序列化，必须保证构造参数都缺省的情况下仍然能 new 出对象。 判断类型 判断实例 需要做类型判断时，可以用 TypeScript 原生的 instanceof： class Sub extends Base { } let sub = new Sub(); console.log(sub instanceof Sub); //true console.log(sub instanceof Base); //true let base = new Base(); console.log(base instanceof Sub); // false 成员 实例变量 在构造函数中定义的实例变量不能被序列化，也不能在 属性检查器 中查看。 class Sprite{ //声明变量 url: string; id: number; constructor() { //赋值 this.url = \"\"; this.id = 0; } } 如果是私有的变量，建议在变量名前面添加下划线 _ 以示区分。 实例方法 实例方法请在原型对象中声明： class Sprite{ text: string; constructor() { this.text = \"this is sprite\" } // 声明一个名叫 \"print\" 的实例方法 print(){ console.log(this.text); } } let obj = new Sprite(); // 调用实例方法 obj.print(); 静态变量和静态方法 静态变量或静态方法可以用 statics 声明： class Sprite{ static count=0; static getBounds(){ } } 静态成员会被子类继承，继承时会将父类的静态变量浅拷贝给子类，因此： class Object{ static count= 11; static range: { w: 100, h: 100 } } class Sprite extends Object{ } console.log(Sprite.count); // 结果是 11，因为 count 继承自 Object 类 Sprite.range.w = 200; console.log(Object.range.w); // 结果是 200，因为 Sprite.range 和 Object.range 指向同一个对象 如果你不需要考虑继承，私有的静态成员也可以直接定义在类的外面： // 局部方法 doLoad(sprite){ // ... }; // 局部变量 let url = \"foo.png\"; class Sprite{ load() { this.url = url; doLoad(this); }; }; 继承 父构造函数 请注意，不论子类是否有定义构造函数，子类实例化前父类的构造函数都会被自动调用。 class Node { name: string; constructor(){ this.name = \"node\"; } } class Sprite extends Node{ constructor() { super(); // 子构造函数被调用前，父构造函数已经被调用过，所以 this.name 已经被初始化过了 console.log(this.name); // \"node\" // 重新设置 this.name this.name = \"sprite\"; } } let obj = new Sprite(); console.log(obj.name); // \"sprite\" 重写 所有成员方法都是虚方法，子类方法可以直接重写父类方法： class Shape{ getName() { return \"shape\"; } }; class Rect extends Shape{ getName () { return \"rect\"; } }; let obj = new Rect(); console.log(obj.getName()); // \"rect\" 属性 属性是特殊的实例变量，能够显示在 属性检查器 中，也能被序列化。 属性和构造函数 属性不用在构造函数里定义，在构造函数被调用前，属性已经被赋为默认值了，可以在构造函数内访问到。如果属性的默认值无法在定义 CCClass 时提供，需要在运行时才能获得，你也可以在构造函数中重新给属性赋默认值。 class Sprite { constructor() { this.num = 1; } @property({type:CCInteger}) private num = 0; } 不过要注意的是，属性被反序列化的过程紧接着发生在构造函数执行之后，因此构造函数中只能获得和修改属性的默认值，还无法获得和修改之前保存（序列化）的值。 属性参数 default参数 default 用于声明属性的默认值，声明了默认值的属性会被 CCClass 实现为成员变量。默认值只有在第一次创建对象的时候才会用到，也就是说修改默认值时，并不会改变已添加到场景里的组件的当前值。 当你在编辑器中添加了一个组件以后，再回到脚本中修改一个默认值的话，属性检查器 里面是看不到变化的。因为属性的当前值已经序列化到了场景中，不再是第一次创建时用到的默认值了。如果要强制把所有属性设回默认值，可以在 属性检查器 的组件菜单中选择 Reset。 default 允许设置为以下几种值类型： 任意 number, string 或 boolean 类型的值 null 或 undefined 继承自 ValueType 的子类，如 Vec3, Color 或 Rect 的实例化对象： @property({type:Vec3}) private pos = null; 空数组 [] 或空对象 {} visible参数 默认情况下，是否显示在 属性检查器 取决于属性名是否以下划线 _ 开头。如果以下划线开头，则默认不显示在 属性检查器，否则默认显示。 如果要强制显示在 属性检查器，可以设置 visible 参数为 true: @property({visible:true}) private _num = 0; 如果要强制隐藏，可以设置 visible 参数为 false: @property({visible:false}) private num = 0; serializable参数 指定了 default 默认值的属性默认情况下都会被序列化，序列化后就会将编辑器中设置好的值保存到场景等资源文件中，并且在加载场景时自动还原之前设置好的值。如果不想序列化，可以设置serializable: false。 @property({serializable:false}) private num = 0; type参数 当 default 不能提供足够详细的类型信息时，为了能在 属性检查器 显示正确的输入控件，就要用 type 显式声明具体的类型： 当默认值为 null 时，将 type 设置为指定类型的构造函数，这样 属性检查器 才知道应该显示一个 Node 控件。 @property({type:Node}) private enemy = null; 当默认值为数值（number）类型时，将 type 设置为 cc.Integer，用来表示这是一个整数，这样属性在 属性检查器 里就不能输入小数点。 @property({type:CCInteger}) private num = 0; 当默认值是一个枚举（Enum）时，由于枚举值本身其实也是一个数字（number），所以要将 type 设置为枚举类型，才能在 属性检查器 中显示为枚举下拉框。 enum A{ c, d } Enum(A); @ccclass(\"test\") export class test extends Component { @property({type:A}) accx:A=A.c; } override参数 所有属性都将被子类继承，如果子类要覆盖父类同名属性，需要显式设置 override 参数，否则会有重名警告： @property({type:CCString,tooltip:\"my id\",override:true}) private _id = \"\"; @property({displayName:\"Name\",override:true}) private _name = null; private get name(){ return this._name; } 更多参数内容请查阅 属性参数。 GetSet 方法 在属性中设置了 get 或 set 以后，访问属性的时候，就能触发预定义的 get 或 set 方法。 get 在属性中设置 get 方法： @property({type:CCInteger}) private _num = 0; private get num(){ return this._num; } get 方法可以返回任意类型的值。 这个属性同样能显示在 属性检查器 中，并且可以在包括构造函数内的所有代码里直接访问。 class Sprite{ _width: number; constructor() { this._width = 128; console.log(this.width); // 128 } @property({type:CCInteger}) private width = 0; private get width(){ return this._width; } }; 请注意： 设定了 get 以后，这个属性就不能被序列化，也不能指定默认值，但仍然可附带除了 default, serializable 外的大部分参数。 @property({type:CCInteger,tooltip: \"The width of sprite\"}) private _width = 0; private get width(){ return this._width; } get 属性本身是只读的，但返回的对象并不是只读的。用户使用代码依然可以修改对象内部的属性，例如： @property _num=0; private get num(){ return this._num; } start(){ consolo.log(this.num); } set 在属性中设置 set 方法： @property({type:CCInteger}) private _width = 0; set(value){ this._width = value } set 方法接收一个传入参数，这个参数可以是任意类型。 set 一般和 get 一起使用： @property _width=0; private get width(){ return this._width; } set(value){ this._width = value; } 如果没有和 get 一起定义，则 set 自身不能附带任何参数。 和 get 一样，设定了 set 以后，这个属性就不能被序列化，也不能指定默认值。 "},"scripting/reference/attributes.html":{"url":"scripting/reference/attributes.html","title":"属性参数参考","keywords":"","body":"属性参数 属性参数用来给已定义的属性附加元数据，类似于脚本语言的 Decorator 或者 C# 的 Attribute。 属性检查器相关参数 参数名 说明 类型 默认值 备注 type 限定属性的数据类型 (Any) undefined 详见 type 参数 visible 在 属性检视器 面板中显示或隐藏 boolean (注1) 详见 visible 参数 displayName 在 属性检视器 面板中显示为另一个名字 string undefined tooltip 在 属性检视器 面板中添加属性的 Tooltip string undefined multiline 在 属性检视器 面板中使用多行文本框 boolean false readonly 在 属性检视器 面板中只读 boolean false min 限定数值在编辑器中输入的最小值 number undefined max 限定数值在编辑器中输入的最大值 number undefined step 指定数值在编辑器中调节的步长 number undefined range 一次性设置 min, max, step [min, max, step] undefined step 值可选 slide 在 属性检视器 面板中显示为滑动条 boolean false 序列化相关参数 这些参数不能用于 get 方法 参数名 说明 类型 默认值 备注 serializable 序列化该属性 boolean true 详见 serializable 参数 formerlySerializedAs 指定之前序列化所用的字段名 string undefined 重命名属性时，声明这个参数来兼容之前序列化的数据 editorOnly 在导出项目前剔除该属性 boolean false 其它参数 参数名 说明 类型 默认值 备注 default 定义属性的默认值 (Any) undefined 详见 default 参数 notify 当属性被赋值时触发指定方法 function (oldValue) {} undefined 需要定义 default 属性并且不能用于数组不支持 ES6 定义方式 override 当重写父类属性时需要定义该参数为 true boolean false 详见 override 参数 animatable 该属性是否能被动画编辑器修改 boolean undefined 注1: visible 的默认值取决于属性名。当属性名以下划线 _ 开头时，默认隐藏，否则默认显示。 返回 脚本开发。 "},"scripting/access-node-component.html":{"url":"scripting/access-node-component.html","title":"访问节点和其他组件","keywords":"","body":"访问节点和组件 你可以在 属性检查器 里修改节点和组件，也能在脚本中动态修改。动态修改的好处是能够在一段时间内连续地修改属性、过渡属性，实现渐变效果。脚本还能够响应玩家输入，能够修改、创建和销毁节点或组件，实现各种各样的游戏逻辑。要实现这些效果，你需要先在脚本中获得你要修改的节点或组件。 在本篇教程，我们将介绍如何 获得组件所在的节点 获得其它组件 使用 属性检查器 设置节点和组件 查找子节点 全局节点查找 访问已有变量里的值 获得组件所在的节点 获得组件所在的节点很简单，只要在组件方法里访问 this.node 变量： start(){ let node = this.node; node.setPosition(0.0,0.0,0.0); } 获得其它组件 你会经常需要获得同一个节点上的其它组件，这就要用到 getComponent 这个 API，它会帮你查找你要的组件。 import { _decorator, Component, LabelComponent } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"test\") export class test extends Component { private label: any = null start(){ this.label = this.getComponent(LabelComponent); let text = this.name + 'started'; // Change the text in Label Component this.label.string = text; } } 你也可以为 getComponent 传入一个类名。对用户定义的组件而言，类名就是脚本的文件名，并且区分大小写。例如 \"SinRotate.ts\" 里声明的组件，类名就是 \"SinRotate\"。 let rotate = this.getComponent(\"SinRotate\"); 在节点上也有一个 getComponent 方法，它们的作用是一样的： start() { console.log( this.node.getComponent(LabelComponent) === this.getComponent(LabelComponent) ); // true } 如果在节点上找不到你要的组件，getComponent 将返回 null，如果你尝试访问 null 的值，将会在运行时抛出 \"TypeError\" 这个错误。因此如果你不确定组件是否存在，请记得判断一下： import { _decorator, Component, LabelComponent } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"test\") export class test extends Component { private label: any =null; start() { this.label = this.getComponent(LabelComponent); if (this.label) { this.label.string = \"Hello\"; } else { console.error(\"Something wrong?\"); } } } 获得其它节点及其组件 仅仅能访问节点自己的组件通常是不够的，脚本通常还需要进行多个节点之间的交互。例如，一门自动瞄准玩家的大炮，就需要不断获取玩家的最新位置。Cocos Creator 3D提供了一些不同的方法来获得其它节点或组件。 利用属性检查器设置节点 最直接的方式就是在 属性检查器 中设置你需要的对象。以节点为例，这只需要在脚本中声明一个 type 为 Node 的属性： // Cannon.ts import { _decorator, Component, Node } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"Cannon\") export class Cannon extends Component { // 声明Player属性 @property({type:Node}) private player = null; } 这段代码在 properties 里面声明了一个 player 属性，默认值为 null，并且指定它的对象类型为 Node。这就相当于在其它语言里声明了 public Node player = null;。脚本编译之后，这个组件在 属性检查器 中看起来是这样的： 接着你就可以将层级管理器上的任意一个节点拖到这个 Player 控件： 这样一来它的 player 属性就会被设置成功，你可以直接在脚本里访问 player： // Cannon.ts import { _decorator, Component, Node } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"Cannon\") export class Cannon extends Component { @property({type:Node}) private player = null; start() { console.log(\"The player is \" + this.player.name); } } 利用属性检查器设置组件 在上面的例子中，如果你将属性的 type 声明为 Player 组件，当你拖动节点 \"Player Node\" 到 属性检查器，player 属性就会被设置为这个节点里面的 Player 组件。这样你就不需要再自己调用 getComponent 啦。 // Cannon.ts import { _decorator, Component } from \"cc\"; const { ccclass, property } = _decorator; import { Player } from \"Player\"; @ccclass(\"Cannon\") export class Cannon extends Component { @property({type:Player}) private player = null; start(){ let PlayerComp = this.player; } } 你还可以将属性的默认值由 null 改为数组[]，这样你就能在 属性检查器 中同时设置多个对象。 不过如果需要在运行时动态获取其它对象，还需要用到下面介绍的查找方法。 查找子节点 有时候，游戏场景中会有很多个相同类型的对象，像是炮塔、敌人和特效，它们通常都有一个全局的脚本来统一管理。如果用 属性检查器 来一个一个将它们关联到这个脚本上，那工作就会很繁琐。为了更好地统一管理这些对象，我们可以把它们放到一个统一的父物体下，然后通过父物体来获得所有的子物体： // CannonManager.ts import { _decorator, Component, Node } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"CannonManager\") export class CannonManager extends Component { start() { let cannons = this.node.children; //... } } 你还可以使用 getChildByName： this.node.getChildByName(\"Cannon 01\"); 如果子节点的层次较深，你还可以使用 find，find 将根据传入的路径进行逐级查找： find(\"Cannon 01/Barrel/SFX\", this.node); 全局名字查找 当 find 只传入第一个参数时，将从场景根节点开始逐级查找： this.backNode = find(\"Canvas/Menu/Back\"); 访问已有变量里的值 如果你已经在一个地方保存了节点或组件的引用，你也可以直接访问它们 通过模块访问 你可以使用 import 来实现脚本的跨文件操作，让我们看个示例： // Global.ts, now the filename matters import { _decorator, Component, Node } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"Global\") export class Global extends Component { public static backNode:any=null; public static backLabel:any=null; } 每个脚本都能用 import{ } from + 文件名(不含路径) 来获取到对方 exports 的对象。 // Back.ts import { _decorator, Component, Node, LabelComponent } from \"cc\"; const { ccclass, property } = _decorator; // this feels more safe since you know where the object comes from import{Global}from \"./Global\"; @ccclass(\"Back\") export class Back extends Component { onLoad(){ Global.backNode=this.node; Global.backLabel=this.getComponent(LabelComponent); } } // AnyScript.ts import { _decorator, Component, Node } from \"cc\"; const { ccclass, property } = _decorator; // this feels more safe since you know where the object comes from import{Global}from \"./Global\"; @ccclass(\"AnyScript\") export class AnyScript extends Component { start () { var text = \"Back\"; Global.backLabel.string=text; } } 继续前往 常用节点和组件接口。 "},"scripting/basic-node-api.html":{"url":"scripting/basic-node-api.html","title":"常用节点和组件接口","keywords":"","body":"常用节点和组件接口 在通过 访问节点和组件 介绍的方法获取到节点或组件实例后，这篇文章将会介绍通过节点和组件实例可以通过哪些常用接口实现我们需要的种种效果和操作。这一篇也可以认为是 Node 和 Component 类的 API 阅读指南，可以配合 API 一起学习理解。 节点状态和层级操作 假设我们在一个组件脚本中，通过 this.node 访问当前脚本所在节点。 激活/关闭节点 节点默认是激活的，我们可以在代码中设置它的激活状态，方法是设置节点的 active 属性： this.node.active = false; 设置 active 属性和在编辑器中切换节点的激活、关闭状态，效果是一样的。当一个节点是关闭状态时，它的所有组件都将被禁用。同时，它所有子节点，以及子节点上的组件也会跟着被禁用。要注意的是，子节点被禁用时，并不会改变它们的 active 属性，因此当父节点重新激活的时候它们就会回到原来的状态。 也就是说，active 表示的其实是该节点 自身的 激活状态，而这个节点 当前 是否可被激活则取决于它的父节点。并且如果它不在当前场景中，它也无法被激活。我们可以通过节点上的只读属性 activeInHierarchy 来判断它当前是否已经激活。 this.node.active = true; 若节点原先就处于 可被激活 状态，修改 active 为 true 就会立即触发激活操作： 在场景中重新激活该节点和节点下所有 active 为 true 的子节点 该节点和所有子节点上的所有组件都会被启用，他们中的 update 方法之后每帧会执行 这些组件上如果有 onEnable 方法，这些方法将被执行 this.node.active = false; 如该节点原先就已经被激活，修改 active 为 false 就会立即触发关闭操作： 在场景中隐藏该节点和节点下的所有子节点 该节点和所有子节点上的所有组件都将被禁用，也就是不会再执行这些组件中的 update 中的代码 这些组件上如果有 onDisable 方法，这些方法将被执行 更改节点的父节点 假设父节点为 parentNode，子节点为 this.node 您可以： this.node.parent = parentNode; 或 this.node.removeFromParent(false); parentNode.addChild(this.node); 这两种方法是等价的。 注意： removeFromParent 通常需要传入一个 false，否则默认会清空节点上绑定的事件和 action 等。 通过 创建和销毁节点 介绍的方法创建出新节点后，要为节点设置一个父节点才能正确完成节点的初始化。 索引节点的子节点 this.node.children 将返回节点的所有子节点数组。 this.node.childrenCount 将返回节点的子节点数量。 注意 以上两个 API 都只会返回节点的直接子节点，不会返回子节点的子节点。 更改节点的变换（位置、旋转、缩放） 更改节点位置 使用 setPosition 方法： this.node.setPosition(100, 50, 100); this.node.setPosition(new Vec3(100,50,100)); 设置 position 变量： this.node.position = new Vec3(100,50,100); 以上两种用法等价。 更改节点旋转 this.node.setRotation(90,90,90); 或通过欧拉角设置本地旋转 this.node.setRotationFromEuler(90,90,90); 更改节点缩放 this.node.setScale(2,2,2); 常用组件接口 Component 是所有组件的基类，任何组件都包括如下的常见接口（假设我们在该组件的脚本中，以 this 指代本组件）： this.node：该组件所属的节点实例 this.enabled：是否每帧执行该组件的 update 方法，同时也用来控制渲染组件是否显示 update(deltaTime: number)：作为组件的成员方法，在组件的 enabled 属性为 true 时，其中的代码会每帧执行 onLoad()：组件所在节点进行初始化时（节点添加到节点树时）执行 start()：会在该组件第一次 update 之前执行，通常用于需要在所有组件的 onLoad 初始化完毕后执行的逻辑 更多组件成员方法请继续参考 生命周期回调 文档。 "},"scripting/life-cycle-callbacks.html":{"url":"scripting/life-cycle-callbacks.html","title":"生命周期回调","keywords":"","body":"﻿# 生命周期回调 Cocos Creator 3D为组件脚本提供了生命周期的回调函数。用户只要定义特定的回调函数，Creator 3D就会在特定的时期自动执行相关脚本，用户不需要手工调用它们。 目前提供给用户的生命周期回调函数主要有： onLoad start update lateUpdate onDestroy onEnable onDisable onLoad 组件脚本的初始化阶段，我们提供了 onLoad 回调函数。onLoad 回调会在节点首次激活时触发，比如所在的场景被载入，或者所在节点被激活的情况下。在 onLoad 阶段，保证了你可以获取到场景中的其他节点，以及节点关联的资源数据。onLoad 总是会在任何 start 方法调用前执行，这能用于安排脚本的初始化顺序。通常我们会在 onLoad 阶段去做一些初始化相关的操作。例如： import { _decorator, Component, Node, SpriteFrame, find } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"test\") export class test extends Component { @property({type:SpriteFrame}) bulletSprite=null; @property({type:Node}) gun=null; _bulletRect=null; onLoad(){ this._bulletRect=this.bulletSprite.getRect(); this.gun = find('hand/weapon'),this.node; } } start start 回调函数会在组件第一次激活前，也就是第一次执行 update 之前触发。start 通常用于初始化一些中间状态的数据，这些数据可能在 update 时会发生改变，并且被频繁的 enable 和 disable。 import { _decorator, Component, Node } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"starttest\") export class starttest extends Component { private _timer: number = 0.0; start () { this._timer = 1.0; } update (deltaTime: number) { this._timer += deltaTime; if(this._timer >= 10.0){ console.log('I am done!'); this.enabled = false; } } } update 游戏开发的一个关键点是在每一帧渲染前更新物体的行为，状态和方位。这些更新操作通常都放在 update 回调中。 import { _decorator, Component, Node } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"updatetest\") export class updatetest extends Component { update (deltaTime: number) { this.node.setPosition(0.0,40.0*deltaTime,0.0); } } lateUpdate update 会在所有动画更新前执行，但如果我们要在动效（如动画、粒子、物理等）更新之后才进行一些额外操作，或者希望在所有组件的 update 都执行完之后才进行其它操作，那就需要用到 lateUpdate 回调。 import { _decorator, Component, Node } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"lateupdatetest\") export class lateupdatetest extends Component { lateUpdate (deltaTime: number) { this.node.setPosition(0.0,50,0.0); } } onEnable 当组件的 enabled 属性从 false 变为 true 时，或者所在节点的 active 属性从 false 变为 true 时，会激活 onEnable 回调。倘若节点第一次被创建且 enabled 为 true，则会在 onLoad 之后，start 之前被调用。 onDisable 当组件的 enabled 属性从 true 变为 false 时，或者所在节点的 active 属性从 true 变为 false 时，会激活 onDisable 回调。 onDestroy 当组件或者所在节点调用了 destroy()，则会调用 onDestroy 回调，并在当帧结束时统一回收组件。 继续前往 创建和销毁节点。 "},"scripting/create-destroy.html":{"url":"scripting/create-destroy.html","title":"创建和销毁节点","keywords":"","body":"创建和销毁节点 创建新节点 除了通过场景编辑器创建节点外，我们也可以在脚本中动态创建节点。通过 new Node() 并将它加入到场景中，可以实现整个创建过程。 以下是一个简单的例子: import { _decorator, Component, Node } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"test\") export class test extends Component { start(){ let node =new Node('box'); node.setPosition(0,0,-10); } } 克隆已有节点 有时我们希望动态的克隆场景中的已有节点，我们可以通过 instantiate 方法完成。使用方法如下： import { _decorator, Component, Node,instantiate, director } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"test\") export class test extends Component { @property({type:Node}) private target: Node = null; start(){ let scene = director.getScene(); let node = instantiate(this.target); node.parent = scene; node.setPosition(0, 0,-10); } } 创建预制节点 和克隆已有节点相似，你可以设置一个预制（Prefab）并通过 instantiate 生成节点。使用方法如下： import { _decorator, Component, Prefab, instantiate, director } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"test\") export class test extends Component { @property({type:Prefab}) private target: Prefab = null; start(){ let scene = director.getScene(); let node = instantiate(this.target); node.parent = scene; node.setPosition(0,0,0); } } 销毁节点 通过 node.destroy() 函数，可以销毁节点。值得一提的是，销毁节点并不会立刻被移除，而是在当前帧逻辑更新结束后，统一执行。当一个节点销毁后，该节点就处于无效状态，可以通过 isValid 判断当前节点是否已经被销毁。 使用方法如下： import { _decorator, Component, Node } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"test\") export class test extends Component { @property({type:Node}) private target: Node = null; private positionz: number = -20; start(){ // 5秒后销毁节点 setTimeout(function () { this.target.destroy(); }.bind(this), 5000); } update(deltaTime: number){ console.info(this.target.isValid); this.positionz += 1*deltaTime; if (this.target.isValid) { this.target.setPosition(0.0,0.0,this.positionz); } } } destroy 和 removeFromParent 的区别 调用一个节点的 removeFromParent 后，它不一定就能完全从内存中释放，因为有可能由于一些逻辑上的问题，导致程序中仍然引用到了这个对象。因此如果一个节点不再使用了，请直接调用它的 destroy 而不是 removeFromParent。destroy 不但会激活组件上的 onDestroy，还会降低内存泄露的几率，同时减轻内存泄露时的后果。 总之，如果一个节点不再使用，destroy 就对了，不需要 removeFromParent 也不需要设置 parent 为 null 哈。 继续前往 资源管理/加载和切换场景 说明文档。 "},"scripting/scene-managing.html":{"url":"scripting/scene-managing.html","title":"加载和切换场景","keywords":"","body":"加载和切换场景 在 Cocos Creator 3D中，我们使用场景文件名（不包含扩展名）来索引指代场景。并通过以下接口进行加载和切换操作： director.loadScene(\"MyScene\"); 通过常驻节点进行场景资源管理和参数传递 引擎同时只会运行一个场景，当切换场景时，默认会将场景内所有节点和其他实例销毁。如果我们需要用一个组件控制所有场景的加载，或在场景之间传递参数数据，就需要将该组件所在节点标记为「常驻节点」，使它在场景切换时不被自动销毁，常驻内存。我们使用以下接口： game.addPersistRootNode(myNode); 上面的接口会将 myNode 变为常驻节点，这样挂在上面的组件都可以在场景之间持续作用，我们可以用这样的方法来储存玩家信息，或下一个场景初始化时需要的各种数据。 需要注意的是，目标节点必须为位于层级的根节点，否则设置无效。 如果要取消一个节点的常驻属性： game.removePersistRootNode(myNode); 需要注意的是上面的 API 并不会立即销毁指定节点，只是将节点还原为可在场景切换时销毁的节点。 场景加载回调 加载场景时，可以附加一个参数用来指定场景加载后的回调函数： director.loadScene(\"MyScene\", onSceneLaunched); 上一行里 onSceneLaunched 就是声明在本脚本中的一个回调函数，在场景加载后可以用来进一步的进行初始化或数据传递的操作。 由于回调函数只能写在本脚本中，所以场景加载回调通常用来配合常驻节点，在常驻节点上挂载的脚本中使用。 预加载场景 director.loadScene 会在加载场景之后自动切换运行新场景，有些时候我们需要在后台静默加载新场景，并在加载完成后手动进行切换。那就可以预先使用 preloadScene 接口对场景进行预加载： director.preloadScene(\"table\", function () { console.log(\"Next scene preloaded\"); }); 之后在合适的时间调用 loadScene, 就可以真正切换场景。 director.loadScene(\"table\"); 就算预加载还没完成，你也可以直接调用 director.loadScene，预加载完成后场景就会启动。 继续前往 获取和加载资源 说明文档。 "},"scripting/load-assets.html":{"url":"scripting/load-assets.html","title":"获取和加载资源","keywords":"","body":"获取和加载资源 Cocos Creator 3D 采用与 Cocos Creator 统一的资源管理机制，在本篇教程，我们将介绍 资源属性的声明 如何在 属性检查器 里设置资源 动态加载资源 加载远程资源和设备资源 资源的依赖和释放 资源属性的声明 在 Cocos Creator 3D 中，所有继承自 Asset 的类型都统称资源，如 Texture2D, SpriteFrame, AnimationClip, Prefab 等。它们的加载是统一并且自动化的，相互依赖的资源能够被自动预加载。 例如，当引擎在加载场景时，会先自动加载场景关联到的资源，这些资源如果再关联其它资源，其它也会被先被加载，等加载全部完成后，场景加载才会结束。 脚本中可以这样定义一个 Asset 属性： //test.ts import { _decorator, Component, Node, SpriteFrame } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"test\") export class test extends Component { @property({type: SpriteFrame}) private spriteFrame: SpriteFrame = null; } 如何在属性检查器里设置资源 只要在脚本中定义好类型，就能直接在 属性检查器 很方便地设置资源。假设我们创建了这样一个脚本： //test.ts import { _decorator, Component, Node, SpriteFrame, Texture2D } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"test\") export class test extends Component { @property({type: Texture2D}) private texture: Texture2D = null; @property({type: SpriteFrame}) private spriteFrame: SpriteFrame = null; } 将它添加到节点后，在 属性检查器 中是这样的： 接下来我们从 资源管理器 里面分别将一个 Texture 和一个 SpriteFrame 拖到 属性检查器 的对应属性中： 结果如下： 这样就能在脚本里直接拿到设置好的资源： start () { let spriteFrame = this.spriteFrame; let texture = this.texture; } 在 属性检查器 里设置资源虽然很直观，但资源只能在场景里预先设好，没办法动态切换。如果需要动态切换，你需要看看下面的内容。 动态加载 关于资源加载,我们提供了各类型资源加载的案例,可参考:test-case-3d(AssetLoading) 动态加载资源要注意两点，一是所有需要通过脚本动态加载的资源，都必须放置在 resources 文件夹或它的子文件夹下。resources 需要在 assets 文件夹中手工创建，并且必须位于 assets 的根目录，就像这样： resources 文件夹中的资源，可以引用文件夹外部的其它资源，同样也可以被外部场景或资源引用到。项目构建时，除了已在 构建发布 面板勾选的场景外，resources 文件夹中的所有资源，连同它们关联依赖的 resources 文件夹外部的资源，都会被导出。 如果一份资源仅仅是被 resources 中的其它资源所依赖，而不需要直接被 loader.loadRes 调用，那么 请不要 放在 resources 文件夹里。否则会增大包体和 settings.ts 的大小，并且项目中无用的资源，将无法在构建的过程中自动剔除。同时在构建过程中，JSON 的自动合并策略也将受到影响，无法尽可能将零碎的 JSON 合并起来。 第二个要注意的是 Cocos Creator 3D 的资源动态加载都是 异步 的，需要在回调函数中获得载入的资源。这么做是因为除了场景关联的资源，没有另外的资源预加载列表，动态加载的资源是真正的动态加载。 动态加载 Asset Cocos Creator 3D 提供了 loader.loadRes 这个 API 来专门加载那些位于 resources 目录下的 Asset。和 loader.load 不同的是，loadRes 一次只能加载单个 Asset。调用时，你只要传入相对 resources 的路径即可，并且路径的结尾处 不能 包含文件扩展名。 // 加载 Prefab loader.loadRes(\"test assets/prefab\", Prefab , (err: any, prefab: Prefab) => { const newNode = instantiate(prefab); this.node.addChild(newNode); }); // 加载 AnimationClip loader.loadRes(\"test assets/anim\", AnimationClip , (err: any, clip: AnimationClip) => { this.node.getComponent(AnimationComponent).addClip(clip, \"anim\"); }); 加载 SpriteFrame 或 Texture2D 图片设置为 sprite-frame 或 texture 或其他图片类型后，将会在 资源管理器 中生成一个对应类型的资源。但如果直接加载 test assets/image，得到的类型将会是 ImageAsset。你必须在图片路径之后加入资源类型，才能加载到图片生成的 对应资源的子资源, 如果不确定对应资源的路径可以在运行或预览时到settings.js中查看： // 加载 SpriteFrame，image 是 ImageAsset，spriteFrame 是 image/spriteFrame， texture 是 image/texture loader.loadRes(\"test assets/image/spriteFrame\", SpriteFrame ,(err: any, spriteFrame: SpriteFrame) => { this.node.getComponent(SpriteComponent).spriteFrame = spriteFrame; }); // 加载 texture loader.loadRes(\"test assets/image/texture\", Texture2D ,(err: any, texture: Texture2D) => { const spriteFrame = new SpriteFrame(); spriteFrame.texture = texture; this.node.getComponent(SpriteComponent).spriteFrame = spriteFrame; }); 如果指定了类型参数，就会在路径下查找指定类型的资源。当你需要获取 “子资源”（例如获取 ImageAsset 的子资源 SpriteFrame），就需要指定子资源的路径。 加载图集中的 SpriteFrame 对从 TexturePacker 等第三方工具导入的图集而言，如果要加载其中的 SpriteFrame，则只能先加载图集，再获取其中的 SpriteFrame。这是一种特殊情况。 // 加载 SpriteAtlas（图集），并且获取其中的一个 SpriteFrame // 注意 atlas 资源文件（plist）通常会和一个同名的图片文件（png）放在一个目录下, 所以需要在第二个参数指定资源类型,且加载时请加载后缀为 .plist 的文件,且需要后缀名 loader.loadRes(\"test assets/atlas.plist\", SpriteAtlas, (err: any, atlas: SpriteAtlas) => { const frame = atlas.getSpriteFrame('sheep_run_0'); this.node.getComponent(SpriteComponent).spriteFrame = frame; }); 资源释放 loadRes 加载进来的单个资源如果需要释放，可以调用 loader.releaseRes，releaseRes 可以传入和 loadRes 相同的路径和类型参数。 loader.releaseRes(\"test assets/image/spriteFrame\"); loader.releaseRes(\"test assets/anim\"); 此外，你也可以使用 loader.releaseAsset 来释放特定的 Asset 实例。 loader.releaseAsset(spriteFrame); 特别说明, 使用 loader.loadRes 或 loader.loadResDir 动态加载的资源，不受场景设置的影响，默认不自动释放,可以使用 setAutoRelease 来改变单个资源的默认行为,强制在切换场景时保留或者释放指定资源。 loader.setAutoRelease(spriteFrame, true); 资源批量加载 loader.loadResDir 可以加载相同路径下的多个资源： // 加载 test assets 目录下所有资源 loader.loadResDir(\"test assets\", function (err, assets) { // ... }); // 加载 test assets 目录下所有 SpriteFrame，并且获取它们的路径 loader.loadResDir(\"test assets\", SpriteFrame, function (err, assets, urls) { // ... }); 加载远程资源和设备资源 在目前的 Cocos Creator 3D中，我们支持加载远程贴图资源，这对于加载用户头像等需要向服务器请求的贴图很友好，需要注意的是，这需要开发者直接调用 loader.load。同时，如果用户用其他方式下载了资源到本地设备存储中，也需要用同样的 API 来加载，上文中的 loadRes 等 API 只适用于应用包内的资源和热更新的本地资源。下面是这个 API 的用法： // 远程 url 带图片后缀名 let remoteUrl = \"http://unknown.org/someres.png\"; loader.load(remoteUrl, function (err, texture) { // Use texture to create sprite frame }); // 远程 url 不带图片后缀名，此时必须指定远程图片文件的类型 remoteUrl = \"http://unknown.org/emoji?id=124982374\"; loader.load({url: remoteUrl, type: 'png'}, function () { // Use texture to create sprite frame }); 目前的此类手动资源加载还有一些限制，对用户影响比较大的是： 这种加载方式只支持图片、声音、文本等原生资源类型，不支持 SpriteFrame、SpriteAtlas、Tilemap 等资源的直接加载和解析（需要后续版本中的 AssetBundle 支持） Web 端的远程加载受到浏览器的 CORS 跨域策略限制，如果对方服务器禁止跨域访问，那么会加载失败，而且由于 WebGL 安全策略的限制，即便对方服务器允许 http 请求成功之后也无法渲染。 资源的依赖和释放 在加载完资源之后，所有的资源都会临时被缓存到 loader 中，以避免重复加载资源时发送无意义的 http 请求，当然，缓存的内容都会占用内存，有些资源可能用户不再需要了，想要释放它们，这里介绍一下在做资源释放时需要注意的事项。 首先最为重要的一点就是：资源之间是互相依赖的。 比如下图，Prefab 资源中的 Node 包含 SpriteComponent 组件, SpriteComponent 组件依赖于 SpriteFrame，SpriteFrame 资源依赖于 Texture 资源，而 Prefab，SpriteFrame 和 Texture 资源都被 loader 缓存起来了。这样做的好处是，有可能有另一个 SpriteAtlas 资源依赖于同样的一个 SpriteFrame 和 Texture，那么当你手动加载这个 SpriteAtlas 的时候，就不需要再重新请求贴图资源了，loader 会自动使用缓存中的资源。 在搞明白资源的相互引用之后，资源释放的问题也就呼之欲出了，当你选择释放一个 Prefab 时，我们是不会自动释放它依赖的其他资源的，因为有可能这些依赖资源还有其他的用处。所以用户在释放资源时经常会问我们，为什么我都把资源释放了，内存占用还是居高不下？原因就是真正占用内存的贴图等基础资源并不会随着你释放 Prefab 或者 SpriteAtlas 而被释放。 接下来要介绍问题的另一个核心：JavaScript 中无法跟踪对象引用。 在 JavaScript 这种脚本语言中，由于其弱类型特性，以及为了代码的便利，往往是不包含内存管理功能的，所有对象的内存都由垃圾回收机制来管理。这就导致 JS 层逻辑永远不知道一个对象会在什么时候被释放，这意味着引擎无法通过类似引用计数的机制来管理外部对象对资源的引用，也无法严谨得统计资源是否不再被需要了。基于以上的原因，目前 loader 的设计实际上是依赖于用户根据游戏逻辑管理资源，用户可以决定在某一时刻不再需要某些资源以及它依赖的资源，立即将它们在 loader 中的缓存释放。也可以选择在释放依赖资源的时候，防止部分共享资源被释放。下面是一个简单的示例： // 直接释放某个贴图 loader.release(texture); // 释放一个 prefab 以及所有它依赖的资源 let deps = loader.getDependsRecursively('prefabs/sample'); loader.release(deps); // 如果在这个 prefab 中有一些和场景其他部分共享的资源，你不希望它们被释放，可以将这个资源从依赖列表中删除 let deps = loader.getDependsRecursively('prefabs/sample'); let index = deps.indexOf(texture2d._uuid); if (index !== -1) deps.splice(index, 1); loader.release(deps); 最后一个值得关注的要点：JavaScript 的垃圾回收是延迟的。 想象一种情况，当你释放了 loader 对某个资源的引用之后，由于考虑不周的原因，游戏逻辑再次请求了这个资源。此时垃圾回收还没有开始（垃圾回收的时机不可控），或者你的游戏逻辑某处，仍然持有一个对于这个旧资源的引用，那么意味着这个资源还存在内存中，但是 loader 已经访问不到了，所以会重新加载它。这造成这个资源在内存中有两份同样的拷贝，浪费了内存。如果只是一个资源还好，但是如果类似的资源很多，甚至不止一次被重复加载，这对于内存的压力是有可能很高的。如果观察到游戏使用的内存曲线有这样的异常，请仔细检查游戏逻辑，是否存在泄漏，如果没有的话，垃圾回收机制是会正常回收这些内存的。 以上就是管理资源依赖和释放时需要注意的细节，这部分的功能和 API 设计还没有完全定案，我们还是希望尽力给大家带来尽可能方便的引擎 API，所以后续也会尝试一些其他的办法提升友好度，届时会更新这篇文档。 继续前往 事件系统 说明文档。 "},"scripting/scheduler.html":{"url":"scripting/scheduler.html","title":"使用计时器","keywords":"","body":"使用计时器 在 Cocos Creator 3D中，我们为组件提供了方便的计时器。 也许有人会认为 setTimeout 和 setInterval 就足够了，开发者当然可以使用这两个函数，不过我们更推荐使用计时器，因为它更加强大灵活，和组件也结合得更好！ 下面来看看它的具体使用方式： 开始一个计时器 this.schedule(function() { // 这里的 this 指向 component this.doSomething(); }, 5); 上面这个计时器将每隔 5s 执行一次。 更灵活的计时器 // 以秒为单位的时间间隔 let interval = 5; // 重复次数 let repeat = 3; // 开始延时 let delay = 10; this.schedule(function() { // 这里的 this 指向 component this.doSomething(); }, interval, repeat, delay); 上面的计时器将在10秒后开始计时，每5秒执行一次回调，重复3次。 只执行一次的计时器（快捷方式） this.scheduleOnce(function() { // 这里的 this 指向 component this.doSomething(); }, 2); 上面的计时器将在两秒后执行一次回调函数，之后就停止计时。 取消计时器 开发者可以使用回调函数本身来取消计时器： this.count = 0; this.callback = function () { if (this.count == 5) { // 在第六次执行回调时取消这个计时器 this.unschedule(this.callback); } this.doSomething(); this.count++; } this.schedule(this.callback, 1); 注意：组件的计时器调用回调时，会将回调的 this 指定为组件本身，因此回调中可以直接使用 this。 下面是 Component 中所有关于计时器的函数： schedule：开始一个计时器 scheduleOnce：开始一个只执行一次的计时器 unschedule：取消一个计时器 unscheduleAllCallbacks：取消这个组件的所有计时器 这些 API 的详细描述都可以在我们的 API 文档中找到。 除此之外，如果需要每一帧都执行一个函数，请直接在 Component 中添加 update 函数，这个函数将默认被每帧调用，这在 生命周期文档 中有详细描述。 注意：Node 不包含计时器相关 API "},"scripting/component.html":{"url":"scripting/component.html","title":"组件","keywords":"","body":"组件 所有继承自 Component 的类都称为组件类， 其对象称为组件，实现了 Cocos Creator 3D EC 系统中的组件概念。 组件类必须是 cc 类。 import { Component } from \"cc\"; @ccclass(\"MyComponent\") class MyComponent extends Component { } 组件的创建和销毁 组件的生命周期完全由结点操控。 与普通类对象不同，组件不能由构造函数创建： const component = new MyComponent(); // 错误：组件无法由构造函数创建 相反地，组件必须由结点来创建： const myComponent = node.addComponent(MyComponent); 在此之后，称组件附加到了结点上。 调用 Node.removeComponent 方法移除指定的组件并将其销毁。 组件总是附加在某个结点上，除了： 在组件类的构造函数结束之前； 组件从结点上移除之后。 import { Component } from \"cc\"; @ccclass(\"MyComponent\") class MyComponent extends Component { constructor () { console.log(this.node.name); // 错误：组件并未附加到结点上 } public printNodeName () { console.log(this.node.name); } } // >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> const myComponent = node.addComponent(MyComponent); myComponent.printNodeName(); // 正确 node.removeComponent(); myComponent.printNodeName(); // 错误：组件并未附加到结点上 "},"scripting/execution-order-component.html":{"url":"scripting/execution-order-component.html","title":"组件顺序","keywords":"","body":"脚本执行顺序 使用统一的控制脚本来初始化其他脚本 一般我都会有一个 Game.ts 的脚本作为总的控制脚本，假如我还有 Player.ts, Enemy.ts, Menu.ts 三个组件，那么他们的初始化过程是这样的： // Game.ts import { _decorator, Component, Node } from \"cc\"; const { ccclass, property } = _decorator; import { Player } from './Player'; import { Enemy } from './Enemy'; import { Menu }from './Menu'; @ccclass(\"Game\") export class Game extends Component { private player =Player; private enemy =Enemy; private menu =Menu; onLoad(){ this.player.init(); this.enemy.init(); this.menu.init(); } } 其中在 Player.ts, Enemy.ts 和 Menu.ts 中需要实现 init 方法，并将初始化逻辑放进去。这样我们就可以保证 Player, Enemy 和 Menu 的初始化顺序。 在 Update 中用自定义方法控制更新顺序 同理如果要保证以上三个脚本的每帧更新顺序，我们也可以将分散在每个脚本里的 update 替换成自己定义的方法： //Player.ts static updataPlayer(deltaTime: number) { } 然后在 Game.ts 脚本的 update 里调用这些方法： // Game.ts update (deltaTime: number) { this.player.updataPlayer(deltaTime); this.enemy.updataEnemy(deltaTime); this.menu.updateMenu(deltaTime); } 控制同一个节点上的组件执行顺序 在同一个节点上的组件脚本执行顺序，可以通过组件在 属性检查器 里的排列顺序来控制。排列在上的组件会先于排列在下的组件执行。我们可以通过组件右上角的齿轮按钮里的 Move Up 和 Move Down 菜单来调整组件的排列顺序和执行顺序。 假如我们有两个组件 CompA 和 CompB，他们的内容分别是： // CompA.ts import { _decorator, Component, Node } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"CompA\") export class CompA extends Component { onLoad(){ console.log('CompA onLoad!'); } start () { console.log('CompA start!'); } update (deltaTime: number) { console.log('CompA update!'); } } // CompB.ts import { _decorator, Component, Node } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"CompB\") export class CompB extends Component { onLoad(){ console.log('CompB onLoad!'); } start () { console.log('CompB start!'); } update (deltaTime: number) { console.log('CompB update!'); } } 组件顺序 CompA 在 CompB 上面时，输出： CompA onLoad! CompB onLoad! CompA start! CompB start! CompA update! CompB update! 在 属性检查器 里通过 CompA 组件右上角齿轮菜单里的 Move Down 将 CompA 移到 CompB 下面后，输出： CompB onLoad! CompA onLoad! CompB start! CompA start! CompB update! CompA update! 设置组件执行优先级 如果以上方法还是不能提供所需的控制粒度，还可以直接设置组件的 executionOrder。executionOrder 会影响组件的生命周期回调的执行优先级。设置方法如下： //Player.ts import { _decorator, Component, Node } from \"cc\"; const { ccclass, executionOrder } = _decorator; @ccclass(\"Player\") @executionOrder(-1) export class Player extends Component { onLoad () { console.log('Player onLoad!'); } } // Menu.ts import { _decorator, Component, Node } from \"cc\"; const { ccclass, executionOrder } = _decorator; @ccclass(\"Menu\") @executionOrder(1) export class Menu extends Component { onLoad () { console.log('Menu onLoad!'); } } executionOrder 越小，该组件相对其它组件就会越先执行。executionOrder 默认为 0，因此设置为负数的话，就会在其它默认的组件之前执行。 executionOrder 只对 onLoad, onEnable, start, update 和 lateUpdate 有效，对 onDisable 和 onDestroy 无效。 "},"engine/event/":{"url":"engine/event/","title":"事件机制","keywords":"","body":"事件 事件是用于引擎内对象交互的消息传递机制。 事件监听 // 该事件监听每次都会触发，需要手动取消注册 xxx.on(type, func, target); 的方式来监听，其中 type 为事件注册字符串，func 为执行事件监听的回调，target 为事件接收对象。 事件取消 // 取消对象身上所有注册的该类型的事件 xxx.off(type); // 取消对象身上该类型指定回调指定目标的事件 xxx.off(type, func, target); 事件派发 // 事件派发的时候可以指定派发参数 xxx.emit(type, ...arg); 需要说明的是，出于底层事件派发的性能考虑，这里最多只支持传递 5 个事件参数。所以在传参时需要注意控制参数的传递个数。 事件说明 系统事件 系统事件指的是全局事件，直接从浏览器进行事件监听和派发。 cc.systemEvent.on(type, func, target); 当前支持的系统事件有：触摸事件，鼠标事件，重力事件，按键事件。可以通过 cc.SystemEventType 获取全局事件类型。 事件名 事件类型说明 TOUCH_START 手指开始触摸事件。 TOUCH_MOVE 当手指在屏幕上移动时。 TOUCH_END 手指结束触摸事件。 TOUCH_CANCEL 当手指在目标节点区域外离开屏幕时。 MOUSE_DOWN 当鼠标按下时触发一次。 MOUSE_MOVE 当鼠标在目标节点在目标节点区域中移动时，不论是否按下。 MOUSE_UP 当鼠标从按下状态松开时触发一次。 MOUSE_WHEEL 鼠标滚动事件。 MOUSE_ENTER 当鼠标移入目标节点区域时，不论是否按下。 MOUSE_LEAVE 当鼠标移出目标节点区域时，不论是否按下。 KEY_DOWN 当按下按键时触发的事件。 KEY_UP 当松开按键时触发的事件。 DEVICEMOTION 重力感应。 KEY 事件获取的键值列表具体可参照 API 的 Macro 来使用。 UI 事件 事件处理是在节点（cc.Node）中完成的。对于组件，可以通过访问节点 this.node 来注册和监听事件。监听事件可以 通过 this.node.on() 函数来注册，方法如下： import { _decorator, Component, Node } from \"Cocos3D\"; const { ccclass } = _decorator; @ccclass(\"example\") export class example extends Component { onLoad() { this.node.on(Node.EventType.TOUCH_CANCEL, this.callback, this); } callback(){ } onDestroy(){ // 一般为了数据回收把控，我们会指定 func，并且在组件 destroy 的时候注销事件 this.node.off(Node.EventType.TOUCH_CANCEL); } 事件名 事件类型说明 TRANSFORM_CHANGED 节点改变位置、旋转或缩放事件。 POSITION_PART 节点位置改变事件。统一由 TRANSFORM_CHANGED 监听，派发后判断类型。 ROTATION_PART 节点旋转事件。统一由 TRANSFORM_CHANGED 监听，派发后判断类型。 SCALE_PART 节点缩放事件。统一由 TRANSFORM_CHANGED 监听，派发后判断类型。 SIZE_CHANGED 当节点尺寸改变时触发的事件。 ANCHOR_CHANGED 当节点锚点改变时触发的事件。 CHILD_ADDED 节点子类添加。 CHILD_REMOVED 节点子类移除。 "},"scripting/log.html":{"url":"scripting/log.html","title":"添加 Log","keywords":"","body":"在引擎内添加 Log 信息 本文档主要说明如何按照正确的规范在引擎内部代码中添加新的 Log 信息（包含 log, warning, error）。 Log 信息机制和背景 目前 Cocos Creator 3d 中的 Log 信息是以一个错误信息表形式独立于引擎存储的，具体存储在 engine 目录下的 EngineErrorMap.md 中。而在引擎代码中，不允许直接以字符串形式写日志、警告、错误等信息，必须以下面三个 API 来书写： import { logID, warnID, errorID } from 'core/platform/debug'; logID(id, ...params); warnID(id, ...params); errorID(id, ...params); 这样做的主要目的是减少字符串在引擎源码中所占据的包体。 EngineErrorMap 的编写规范 EngineErrorMap 按照一百位来做大模块划分，总共四位，从 0000 到 9900，也就是说支持最多 100 个大模块。十位数是用来划分子模块的，或者也可以直接以连续的形式排列，这个由模块负责人决定。 由于历史原因，目前没有按照严格的优先级顺序来做排序，新建的模块可以简单得往后顺延。未来我们会做更好的排序管理和整理。 具体错误信息的编写规范如下： ### 4 number ID Message in english. 比如 ### 8300 Should only one camera exists, please check your project. 信息中支持使用 %s，%d，%f 这样的参数接收符，运行输出 LOG 时会按照参数顺序依次拼接到信息中。 EngineErrorMap 的维护 EngineErrorMap 修改后，如果希望代码中的调用生效，需要在 engine 目录下执行 > gulp build-debug-infos EngineErrorMap.md 的修改也要跟随引擎的其他修改提交到 git。 "},"scripting/deprecated.html":{"url":"scripting/deprecated.html","title":"废弃 API","keywords":"","body":"废弃 API 框架说明 为了更友好和便利的维护废弃API ，将通过三个函数来实现： markAsWarning 对给予对象上的属性中嵌入一个警告，给予对象需要存在该属性。 removeProperty 重新定义给予对象上移除的属性，并嵌入一个报错，给予对象应不存在该属性。 replaceProperty 重新定义给予对象上移除的属性，并嵌入一个警告和调用新的属性，参数不兼容的需要进行适配，给予对象应不存在该属性。 函数签名 interface IRemoveItem { /** 废弃属性的名称 */ name: string; /** 警告的次数 */ logTimes?: number; /** 额外建议 */ suggest?: string; } interface IMarkItem { /** 废弃属性的名称 */ name: string; /** 警告的次数 */ logTimes?: number; /** 额外建议 */ suggest?: string; } interface IReplacement { /** 废弃属性的名称 */ name: string; /** 警告的次数 */ logTimes?: number; /** 替换属性的名称 */ newName?: string; /** 废弃属性的所属对象 */ target?: object; /** 废弃属性的所属对象的名称 */ targetName?: string; /** 自定义替换属性（函数） */ customFunction?: Function; /** 自定义替换属性的 setter */ customSetter?: (v: any) => void; /** 自定义替换属性的 getter */ customGetter?: () => any; } export let removeProperty: (owner: object, ownerName: string, properties: IRemoveItem[]) => void; export let markAsWarning: (owner: object, ownerName: string, properties: IMarkItem[]) => void; export let replaceProperty: (owner: object, ownerName: string, properties: IReplacement[]) => void; /** 此函数用于设置全局默认的信息输出次数 */ export function setDefaultLogTimes (times: number): void; 使用规范 按照模块划分，每个模块维护一份废弃文件。为了便于维护，命名统一为 deprecated.ts ，并且放在相应模块的目录下，并需要在相应的模块的index.ts文件中import该文件，例如import './deprecated'。 注：cocos\\utils目录下的deprecated.ts文件为声明和实现文件。 使用示例 // 对于替换参数不兼容的API，通过合适的自定义功能进行适配 replaceProperty(AnimationComponent.prototype, 'AnimationComponent.prototype', [ { name: 'removeClip', newName: 'removeState', customFunction: function (...args: any) { const arg0 = args[0] as AnimationClip; return AnimationComponent.prototype.removeState.call(this, arg0.name); } } ]); replaceProperty(vmath, 'vmath', [ { name: 'vec2', newName: 'Vec2', target: math, targetName: 'math', 'logTimes': 1 }, { name: 'EPSILON', target: math, targetName: 'math', 'logTimes': 2 } ]); removeProperty(vmath, 'vmath', [ { 'name': 'random', 'suggest': 'use Math.random.' } ]); markAsWarning(math, 'math', [ { 'name': 'toRadian' } ]); 使用注意 操作目标都是对象，如果想要修改类的成员函数，请传入target.prototype。 replaceProperty不传入newName或newTarget，表示和name或target一致。 如果要控制次数，最好在使用之前调用setDefaultLogTimes，因为别的模块可能会把默认次数改了。 "},"asset/":{"url":"asset/","title":"资源手册","keywords":"","body":"关于资源 本章节将详细介绍 Cocos Creator 3D 中资源的整体工作流程，并对各类资源的使用方法及可能需要注意的地方做出说明。 资源管理器 资源管理器 作为访问管理资源的重要工具，开发者在管理资源时推荐先熟悉资源管理器的使用方法，关于资源管理器的详细介绍可见：资源管理器 资源工作流 资源工作流 通用的资源工作流程包括导入资源、同步资源、定位资源等说明可见：资源工作流 资源的获取和加载 资源的获取和加载的详细说明可见：获取和加载资源 资源的分包加载 对于小游戏平台的游戏分包，Cocos Creator 3D 为开发者提供了分包加载功能，详细说明可见：分包加载 常见资源类型工作流程 接下来我们会介绍 Cocos Creator 3D 中主要资源类型和相关工作流程： 场景资源 图像资源 纹理贴图资源 精灵帧资源 立方体贴图资源 图像资源的自动裁剪 图集资源 渲染纹理 预制资源 脚本资源 字体资源 声音资源 材质资源 模型资源 从第三方工具导出模型资源 动画资源 "},"asset/asset-workflow.html":{"url":"asset/asset-workflow.html","title":"资源工作流","keywords":"","body":"资源工作流 导入资源 提供了三种 导入资源 的方式： 以新建文件的方式，通过 Cocos Creator 3D 窗口的 资源管理器 面板 创建按钮 导入资源 以复制文件的方式，在操作系统的文件管理器中，将资源文件复制到项目资源文件夹下，之后打开编辑器或激活编辑器窗口会自动刷新 资源管理器 的资源列表，完成导入资源。 以拖拽文件的方式，从操作系统的文件管理器中拖拽资源文件到 资源管理器 面板的某个文件夹位置，完成导入资源。 名称解释 英文 中文 dataBase 数据库 asset-db 项目资源数据库 internal-db 内置数据库 uuid 唯一标识符 meta 元信息 同步资源 资源管理器 面板中的资源和 操作系统的文件管理器 中看到的项目资源文件是同步的，在 资源管理器 中对资源的移动、重命名和删除，都会同步到 操作系统的文件管理器 ，反之亦然。 资源配置信息 .meta 文件 所有资源文件都会在导入时生成一份同名的 .meta 后缀的配置文件 这份配置文件提供了该资源在项目中的唯一标识 uuid 以及其他的一些配置信息，如图集中的小图引用，贴图资源的裁剪数据等，是识别一份合法资源的必要因素。 在 资源管理器 面板中 .meta 文件是不可见的，对资源的重命名，移动，删除，都会由编辑器自动同步该资源对应的 .meta 文件，以确保配置信息如 uuid 等保持不变，即不影响现有的引用。 不推荐直接在 操作系统的文件管理器 对资源文件进行操作，如有操作，请同步处理相应的 .meta 文件，如下建议： 关闭正在使用的编辑器，避免因为文件锁定或资源名称相同导致更新失败。 删除，重命名，移动资源时，请连同 .meta 文件一起删除，重命名，移动。 复制资源时如果连同 .meta 文件一起复制，将直接使用复制进来的 .meta 文件，而不是再生成新的 .meta 文件；如果只复制了资源文件，则会生成对应名称的新的 .meta 文件。 Library 中的资源 资源经过导入后会生成一份新的数据存在项目的 Library 文件夹里。在 Library 里的文件，其结构和资源是面向引擎的，是最终游戏时需要的格式，即机器友好，但对人的阅读不友好。这块。 当 library 丢失或损坏的时候，只要删除整个 library 文件夹再打开项目，就会重新生成资源库。 如何定位资源 一个资源有唯一的 uuid 来定位到该资源，但这种方式不够直观，还有另一种直观的方式：Database URL 格式例如 asset-db 对应的协议头是 db://assets ，internal-db 对应的协议头是 db://internal。 有文件夹层级的资源格式，如 db://assets/prefabs/fire.prefab SVN 或 GIT 同步资源 需要注意 .meta 文件的换行符，建议统一下团队成员电脑的换行符风格和规则，避免同步项目资源后打开项目，出现了大量的 .meta 文件修改 "},"asset/load-assets.html":{"url":"asset/load-assets.html","title":"获取和加载资源","keywords":"","body":"获取和加载资源 使用脚本管理和加载资源,请参考脚本指南中的: 获取和加载资源 "},"asset/subpackage.html":{"url":"asset/subpackage.html","title":"分包加载","keywords":"","body":"分包加载 随着游戏玩法越来越丰富，游戏的代码量也越来越大，开发者对于扩大包大小的需求越来越强烈，同时微信小游戏也支持了分包加载的功能。所以 Cocos Creator 3D 支持 分包加载 这样一个功能，该功能支持 代码 和 资源 的分包加载。分包加载目前只支持各类小游戏平台，如微信小游戏。 分包加载，即把游戏内容按一定规则拆分在几个包里，在首次启动的时候只下载必要的包，这个必要的包称为 主包，开发者可以在主包内触发下载其他子包，这样可以有效降低首次启动的消耗时间。 配置方法 Cocos Creator 3D 的分包是以文件夹为单位来配置的，当我们选中一个文件夹时，在 属性检查器 中会出现文件夹的相关配置选项： 勾选 配置为子包 后，点击右上方的 确定，这个文件夹下的资源（包含代码和其他资源）就会被当做是子包的内容了。子包名 会在加载子包时作为加载的名字传入，默认会使用这个文件夹的名字。 注意：配置为子包后，只有原生资源，例如图片和音频会被最终放到子包中。Prefab、AnimationClip 等 JSON 类型的资源仍然会放在主包里。 注意：应尽量避免子包的嵌套，比如A文件夹被勾选为子包后，A文件夹下B文件夹也被勾选为子包。如果存在嵌套，则父文件夹不会将子文件夹中的内容打包 构建 分包的作用只会在项目构建后才会体现，预览的时候还是按照整包来进行加载的。项目构建后会在发布包目录下的 subpackages 生成对应的分包文件夹。 例如：将 example 工程中的 cases/01_graphics 文件夹配置为子包，那么项目构建后将会在发布包目录下的 subpackages 生成 01_graphics 文件夹。 构建发布时，会对 cases/01_graphics 子包文件夹下所有的 代码 和 资源 进行以下的相关处理： 代码：cases/01_graphics 文件夹下的所有代码会合并成一个命名为 01_graphics/game.js 的入口脚本文件，并且会将这些代码从主包中剔除。 资源：会把 cases/01_graphics 子包资源从发布包目录下的 res/raw-assets 文件夹移动到发布包目录下的 subpackages/01_graphics 目录下。 加载子包 引擎提供了一个统一的 api loader.downloader.loadSubpackage 来加载子包文件里面的资源（包含代码和其他资源）。loadSubpackage 需要传入一个子包的名字，这个名字即是之前用户在项目中配置的子包名字，默认为子包文件夹的名字。 当子包加载完成后，会触发回调，如果加载失败的话，会返回一个错误信息。 loader.downloader.loadSubpackage('01_graphics', (err: any) => { if (err) { return console.error(err); } console.log('load subpackage successfully.'); }); 如果加载成功，子包中的脚本将被执行，子包的资源加载路径将被添加到引擎中。开发者就可以用和访问主包完全一样的方式访问这个子包中的所有资源，无需关心这些资源原先是在主包还是在子包中。 微信小游戏 在微信小游戏平台的构建中，子包的配置也会按照规则自动生成到微信小游戏发布包目录下的 game.json 配置文件中。 注意：微信小游戏需要特定的版本才能支持分包功能。微信 6.6.7 客户端，2.1.0 及以上基础库开始支持，请更新至最新客户端版本，开发者工具请使用 1.02.1806120 及以上版本。更新了开发者工具后不要忘记修改开发者工具中的 详情 -> 项目设置 -> 调试基础库 为 2.1.0 及以上： 分包加载包大小的限制 目前微信小游戏分包大小有以下限制： 整个微信小游戏所有分包大小不超过 8M 单个分包/主包大小不能超过 4M 具体请参考 微信小游戏分包加载官方文档。 "},"asset/scene.html":{"url":"asset/scene.html","title":"场景资源","keywords":"","body":"场景资源 在 Cocos Creator 3D 中，游戏场景（Scene） 是开发时组织游戏内容的中心，也是呈现给玩家所有游戏内容的载体。而场景文件本身也作为游戏资源存在，其保存了游戏的大部分信息，也是创作的基础。 创建场景 我们现在共有三种创建场景的方式： 为了您的项目具备良好的文件夹目录结构，我们强烈建议您使用 方法一 创建场景 方法一：在 资源管理器 中选中你想要创建场景文件的文件夹，在文件夹目录上 右键/新建/场景文件，之后键入想要的场景名即可。 方法二：在 资源管理器 中点击创建菜单，创建新场景。 方法三：选择主菜单：文件/新建场景，会在层级管理器直接出现新场景，但资源管理器中不会出现新场景，需要在进行了场景保存后才会在资源文件夹的根目录下出现New Scene.scene场景文件。 保存场景 在标记场景的过程中，可通过快捷键 Ctrl + S (Windows) 或 Command + S (Mac) 来快速保存场景 切换场景 在 资源管理器 中，双击需要打开的场景。 如需游戏中切换场景，可通过 director.loadScene 等 API 来实现游戏中动态场景加载及切换，详情请见我们的 API 文档。 场景资源的属性 作为一个资源文件，在 资源管理器 中选中想要管理的场景时，可设置场景文件是否要异步加载资源 而在打开场景文件之后，scene 作为场景节点树的根节点，在 层级管理器 中选中 Scene 节点,在左侧的属性检查器中可设置整个场景相关的属性，包括环境光设置，阴影设置和天空盒设置。 各类属性的详细说明请见： 环境光 阴影 天空盒 "},"asset/image.html":{"url":"asset/image.html","title":"图像资源","keywords":"","body":"图像资源 图像资源又经常被称作贴图、图片，是游戏中绝大部分图像渲染的数据源。图像资源一般由图像处理软件（比如 Photoshop，Windows 上自带的画图）制作而成并输出成 Cocos Creator 3D可以使用的文件格式，目前包括 JPG 和 PNG 两种。 导入图像资源 使用默认的资源导入方式就可以将图像资源导入到项目中，之后我们就可以在 资源管理器 中看到如下图所示的图像资源。 图像资源的类型 选中导入的图像资源，在右侧的属性检查器面板上，可以选择图像资源不同的使用方式，目前共有4中使用方式供开发者使用，如下所示： 各类型图像资源的详情在下面的章节中有详细介绍： raw 类型为原始图片类型，无作用，用户不需使用 texture 类型为图像资源类型，也为导入的默认类型，详情可见：Texture normal map 类型为法线贴图类型 sprite-frame 类型为精灵帧资源，用于 UI 制作上，详情可见：SpriteFrame texture cube 类型为立方贴图类型，使用在全景图上，用于制作天空盒上，详情可见：天空盒 在 资源管理器 中，图像资源的左边会显示一个和文件夹类似的三角图标，点击就可以展开看到它的子资源（sub asset），每个图像资源导入后编辑器会自动在它下面创建同名的 选中类型 的资源。选中资源本身可进行更改资源类型、设置图像翻转及设置图像在各平台的质量的操作。子资源的详细属性说明请见：子资源属性面板 "},"asset/texture.html":{"url":"asset/texture.html","title":"纹理贴图资源","keywords":"","body":"纹理贴图资源 纹理贴图资源是一种用于程序采样的资源，如模型上的贴图、精灵上的UI。 当程序渲染UI或者模型时，会对相应的纹理进行采样，然后填充在模型网格上，再加上光照等等一系列处理便渲染出了整个场景。 纹理资源可由 ImageAsset 转化而成，一些通用的图像交换格式如 png , jpeg 等等都可为 ImageAsset。 Texture2D Texture2D 是纹理资源的一种，通常用于 3D 模型的渲染，如模型材质中的反射贴图、环境光遮罩贴图等等。 在 Cocos Creator 3D 中的 Texture2D: 注：texture 类型即为 Texture2D 资源。 调整 Texture2D 的属性 当导入一张 ImageAsset 时，默认会将其设置为 Texture2D 的类型，这时会在原资源上会生成一个或多个子资源，点击原资源前的箭头便可以看到所有的子资源，如下动图所示： 选中生成的 Texture2D 子资源后可以看到以下面板 子资源 Texture2D 的属性面板 以下介绍了面板的所有属性： 属性 解释 anisotropy 各项异性值 minFilter 缩小过滤算法 magFilter 放大过滤算法 mipFilter 多级纹理过滤算法 wrapS S（U）方向纹理寻址模式 wrapT T（V）方向纹理寻址模式 使用 Texture2D Texture2D 是使用范围非常广泛的资源，在属性面板上任何标记为 Texture2D 类型的属性，都可以拖入 Texture2D 类型的资源。 使用场景主要为编辑器环境与动态获取使用 在编辑器中，只需要将资源拖入即可； 动态使用时，需要先获取 ImageAsset 资源，然后根据获取到 ImageAsset 实例化出 Texture2D 资源； TextureCube TextureCube 为立方体纹理，可用于设置场景的天空盒，可以通过设置全景图 ImageAsset 为 TextureCube 类型获得，也可以通过制作 CubeMap 资源获得，在场景的天空盒章节有详细的使用和制作方式。 在 Cocos Creator 3D 中通过全景图获得的 TextureCube: 在 Cocos Creator 3D 中通过制作 CubeMap 获得的 TextureCube: 阅读天空盒 章节去了解更多 TextureCube 的使用与制作 CubeMap 的方式。 "},"asset/sprite-frame.html":{"url":"asset/sprite-frame.html","title":"精灵帧资源","keywords":"","body":"精灵帧资源（SpriteFrame） Cocos Creator 3D SpriteFrame 是 UI 渲染基础图形的容器。其本身管理图像的裁剪和九宫格信息，默认持有一个与其同级的 Texture2D 资源引用。 导入精灵帧资源 使用默认的资源导入方式就可以将图像资源导入到项目中，将图像资源的类型选择为 sprite-frame 之后我们就可以在 资源管理器 中看到如下图所示的图像资源。 图像资源在 资源管理器 中会以自身图片的缩略图作为图标。在 资源管理器 中选中图像子资源后，属性检查器 下方会显示该图片的缩略图。 使用 SpriteFrame 1. 容器内包含对象是贴图的使用方式 在编辑器中，拖拽 SpriteFrame 资源到该 Sprite 组件的 Sprite Frame 属性栏中，来切换该 Sprite 显示的图像。在运行时，以上图中的 content 图片为例，整个资源分为 content（图像源资源 ImageAsset）及其子资源 spriteFrame（精灵帧资源 SpriteFrame）和子资源 texture（贴图资源 Texture2D）。在游戏包内（也就是已经放在 resources 目录下）的资源可以通过 方法一（加载 SpriteFrame）： const url = 'test_assets/test_atlas/content/spriteFrame'; loader.loadRes(url, SpriteFrame,(err: any , spriteFrame) => { const sprite = this.getComponent(SpriteComponent); sprite.spriteFrame = spriteFrame; }); 在服务器上的资源只能加载到图像源 ImageAsset，具体方法请参考: 资源加载。 我们提供了 createWithImage 方法来帮助用户快捷的将 ImageAsset 或者原始图像资源 ImageSource 包装为 SpriteFrame，使用方法如下： 方法二（加载 ImageAsset）： const self = this; const url = 'test_assets/test_atlas/content'; loader.loadRes(url, ImageAsset,(err: any, imageAsset) => { const sprite = this.getComponent(SpriteComponent); sprite.spriteFrame = SpriteFrame.createWithImage(imageAsset); }); 或者用户也可以手动来填充信息如下： const self = this; const url = 'test_assets/test_atlas/content'; loader.loadRes(url, ImageAsset,(err: any, imageAsset) => { const sprite = this.getComponent(SpriteComponent); const spriteFrame = new SpriteFrame(); const tex = new Texture2D(); tex.image = imageAsset; spriteFrame.texture = tex; sprite.spriteFrame = spriteFrame; }); 方法三（canvas 绘制内容 UI 上显示）（加载 ImageSource）： const sprite = this.getComponent(SpriteComponent); sprite.spriteFrame = SpriteFrame.createWithImage(canvas); 或者用户也可以手动来填充信息如下： const sprite = this.getComponent(SpriteComponent); const img = new ImageAsset(canvas); const tex = new Texture2D(); tex.image = img; const sp = new SpriteFrame(); sp.texture = tex; sprite.spriteFrame = sp; 2. 容器内包含对象是 RenderTexture 的使用方式 RenderTexture 是一个渲染纹理，它可以将摄像机上的内容直接渲染到一张纹理上而不是屏幕上。SpriteFrame 通过管理 RenderTexture 可以轻松的将 3D 相机内容显示在 UI 上。使用方法如下： const cameraComp = this.getComponent(CameraComponent); const renderTexture = new RenderTexture(); const size = view.getVisibleSize(); renderTexture.reset({ width: size.width, height: size.height, colorFormat: RenderTexture.PixelFormat.RGBA8888, depthStencilFormat: RenderTexture.DepthStencilFormat.DEPTH_24_STENCIL_8 }); cameraComp.targetTexture = renderTexture; const spriteFrame = new SpriteFrame(); spriteFrame.texture = renderTexture; const sprite = this.getComponent(SpriteComponent); sprite.spriteFrame = spriteFrame; "},"ui-system/components/engine/trim.html":{"url":"ui-system/components/engine/trim.html","title":"图像资源的自动裁剪","keywords":"","body":"图像资源的自动剪裁 导入图像资源后生成的 SpriteFrame 会进行自动剪裁，去除原始图片周围的透明像素区域。这样我们在使用 SpriteFrame 渲染 Sprite 时，将会获得有效图像更精确的大小。 Sprite 组件剪裁相关设置详解 和图片裁剪相关的 Sprite 组件设置有以下两个： Trim 勾选后将在渲染 Sprite 图像时去除图像周围的透明像素，我们将看到刚好能把图像包裹住的约束框。取消勾选，Sprite 节点的约束框会包括透明像素的部分。 Size Mode 用来将节点的尺寸设置为原图或原图裁剪透明像素后的大小，通常用于在序列帧动画中保证图像显示为正确的尺寸。有以下几种选择： TRIMMED 选择这个选项，会将节点的尺寸（size）设置为原始图片裁剪掉透明像素后的大小。 RAW 选择这个，会将节点尺寸设置为原始图片包括透明像素的大小。 CUSTOM 自定义尺寸，用户在使用 矩形变换工具 拖拽改变节点的尺寸，或通过修改 Size 属性，或在脚本中修改 width 或 height 后，都会自动将 Size Mode 设为 CUSTOM。表示用户将自己决定节点的尺寸，而不需要考虑原始图片的大小。 下图中展示了两种常见组合的渲染效果： 自带位置信息的序列帧动画 有很多动画师在绘制序列帧动画时，会使用一张较大的画布，然后将角色在动画中的运动直接通过角色在画布上的位置变化表现出来。在使用这种素材时，我们需要将 Sprite 组件 的 Trim 设为 false，将 Size Mode 设为 RAW。这样动画在播放每个序列帧时，都将使用原始图片的尺寸，并保留图像周围透明像素的信息，这样才能正确显示绘制在动画中的角色位移。 而 Trim 设为 true，则是在位移完全由角色位置属性控制的动画中，更推荐使用的方式。 TexturePacker 设置 在制作序列帧动画时，我们通常会使用 TexturePacker 这样的工具将序列帧打包成图集，并在导入后通过图集资源下的 SpriteFrame 来使用。在 TexturePacker 中输出图集资源时，Sprites 分类下的 Trim mode 请选择 Trim，一定不要选择 Crop, flush position，否则透明像素剪裁信息会丢失，您在使用图集里的资源时也就无法获得原始图片未剪裁的尺寸和偏移信息了。目前建议使用 4.x 以上版本进行打包，以防止低版本导出数据不一致造成的导入失败。 "},"asset/compress-texture.html":{"url":"asset/compress-texture.html","title":"压缩纹理","keywords":"","body":"压缩纹理 Cocos Creator 3D 可以直接在编辑器中设置纹理需要的压缩方式，然后在项目发布时自动对纹理进行压缩。针对 Web 平台，支持同时导出多种图片格式，引擎将根据不同的浏览器自动下载合适的格式。 配置压缩纹理 Cocos Creator 3D 支持导入多种格式的图片（具体见下表），但是在实际游戏运行中，我们不建议使用原始图片作为资源来加载。比如在手机平台上可能只需要原图 80% 或者更少的画质，又或者是没有使用到透明通道的 .png 可以将其转换成 .jpg，这样可以减少很大一部分图片的存储空间。 图片格式 Android iOS 微信小游戏 Web PNG 支持 支持 支持 支持 JPG 支持 支持 支持 支持 WEBP Android 4.0 以上原生支持其他版本可以使用 解析库 可以使用 解析库 不支持 部分支持 PVR 不支持 支持 支持 iOS 设备 支持 iOS 设备 ETC1 支持 不支持 支持 Android 设备 支持 Android 设备 ETC2 只支持生成资源，引擎部分需要参考 pr 自己实现：https://github.com/cocos-creator/cocos2d-x-lite/pull/1685 默认情况下 Cocos Creator 3D 在构建的时候输出的是原始图片，如果在构建时需要对某一张图片进行压缩，可以在 资源管理器 中选中这张图片，然后在 属性管理器 中对图片的纹理格式进行编辑。 压缩纹理详解 如果想要使用压缩纹理，在构建项目的时候需要打开压缩纹理选项使项目使用压缩纹理功能： Cocos Creator 3D 在构建图片的时候，会查找当前图片是否进行了压缩纹理的配置，如果没有，则继续查找是否做了默认（Default）的配置，如果没有，则最后按原图输出。 如果查找到了压缩纹理的配置，那么会按照找到的配置对图片进行纹理压缩。在一个平台中可以指定多种纹理格式，每种纹理格式在构建时都会根据原图压缩生成一张指定格式的图片。 这些生成的图片不会都被加载到引擎中，引擎会根据 macro.SUPPORT_TEXTURE_FORMATS 中的配置来选择加载合适格式的图片。macro.SUPPORT_TEXTURE_FORMATS 列举了当前平台支持的所有图片格式，引擎加载图片时会从生成的图片中找到在这个列表中 优先级靠前（即排列靠前）的格式来加载。 用户可以通过修改 macro.SUPPORT_TEXTURE_FORMATS 来自定义平台的图片资源支持情况以及加载顺序的优先级。 示例 在上面的示例图中，默认平台配置了 png 格式的压缩纹理，web 平台配置了 pvr、png 格式的压缩纹理，而其他平台没有添加任何配置。那么在构建 web 平台的时候这张图片就会被压缩成 pvr，png 两种格式，在构建其他平台的时候则只会生成 png 格式的图片。 而默认设置的 macro.SUPPORT_TEXTURE_FORMATS 中只有 ios 平台上才添加了 .pvr 的支持，所以只有在 ios 的浏览器上才会加载 pvr 格式的图片，其他平台上的浏览器则加载 png 格式的图片。 "},"asset/atlas.html":{"url":"asset/atlas.html","title":"图集资源","keywords":"","body":"图集资源（Atlas） 图集（Atlas）也称作 Sprite Sheet，是游戏开发中常见的一种美术资源。图集是通过专门的工具将多张图片合并成一张大图，并通过 plist 等格式的文件索引的资源。可供 Cocos Creator 3D 使用的图集资源由 plist 和 png 文件组成。下面就是一张图集使用的图片文件： 为什么要使用图集资源 在游戏中使用多张图片合成的图集作为美术资源，有以下优势： 合成图集时会去除每张图片周围的空白区域，加上可以在整体上实施各种优化算法，合成图集后可以大大减少游戏包体和内存占用 多个 Sprite 如果渲染的是来自同一张图集的图片时，这些 Sprite 可以使用同一个渲染批次来处理，大大减少 CPU 的运算时间，提高运行效率。 更形象生动的解释可以观看来自 CodeAndWeb 的教学视频 What is a Sprite Sheet（什么是图集），需要使用 VPN 打开视频。 制作图集资源 要生成图集，首先您应该准备好一组原始图片： 接下来可以使用专门的软件生成图集，我们推荐的图集制作软件包括： TexturePacker 4.x Zwoptex 使用这些软件生成图集时请选择 cocos2d-x 格式的 plist 文件。最终得到的图集文件是同名的 plist 和 png。 使用 TexturePacker 打包图集的用户需要注意： 3D 这里不再做 3.x 版本以下的图集格式，导入是会报错的，望用户知悉，推荐使用的版本是 4.x。 由于 TexturePacker 打包结果的问题，与我们处理九宫格算法的不匹配，所以在 1.0.4 版本的编辑器中，生成合图时请禁止旋转，以获得正确的效果。 导入图集资源 将上面所示的 plist 和 png 文件同时拖拽到 资源管理器 中，就可以生成可以在编辑器和脚本中使用的图集资源了。 Atlas 和 SpriteFrame 在图像资源文档中，我们介绍了 Texture 和 SpriteFrame 的关系。导入图集资源后，我们可以看到类型为 Atlas 的图集资源可以点击左边的三角图标展开，展开后可以看到图集资源里包含了很多类型为 SpriteFrame 的子资源，每个子资源都是可以单独使用和引用的图片。 接下来对于 Sprite Frame 的使用方法就和图像资源中介绍的一样了，请查阅相关文档。 "},"asset/auto-atlas.html":{"url":"asset/auto-atlas.html","title":"自动图集资源","keywords":"","body":"自动图集资源 (Auto Atlas) 自动图集资源 作为 Cocos Creator 3D 自带的合图功能，可以将指定的一系列碎图打包成一张大图，具体作用和 Texture Packer 的功能很相近。 创建自动图集资源 在 资源管理器 中右键，可以在如下菜单中找到 新建 -> 自动图集配置 的子菜单，点击菜单将会新建一个类似 AutoAtlas.pac 的资源。 自动图集资源 将会以当前文件夹下的所有 SpriteFrame 作为碎图资源，以后会增加其他的选择碎图资源的方式。 如果碎图资源 SpriteFrame 有进行配置过，在打包后重新生成的 SpriteFrame 将会保留这些配置。 配置自动图集资源 在资源管理器中选中一个 自动图集资源 后，属性检查器 面板将会显示 自动图集资源 的所有可配置项。 属性 功能说明 最大宽度 单张图集最大宽度 最大高度 单张图集最大高度 间距 图集中碎图之间的间距 允许旋转 是否允许旋转碎图 输出大小为正方形 是否强制将图集长宽大小设置成正方形 输出大小为二次幂 是否将图集长宽大小设置为二次方倍数 算法 图集打包策略，目前暂时只有一个选项 输出格式 图集图片生成格式，可选的格式有 [png、jpg、webp...] 扩边 在碎图的边框外扩展出一像素外框，并复制相邻碎图像素到外框中。该功能也称作 “Extrude”。 不包含未被引用资源 在预览中，此选项不会生效，构建后此选项才会生效 配置完成后可以点击 预览 按钮来预览打包的结果，按照当前自动图集配置生成的相关结果将会展示在 属性检查器 下面的区域。 需要注意的是每次配置过后，需要重新点击 预览 才会重新生成预览图。 结果分为： Packed Textures：显示打包后的图集图片以及图片相关的信息，如果会生成的图片有多张，则会往下在 属性检查器 中列出来。 Unpacked Textures：显示不能打包进图集的碎图资源，造成的原因有可能是这些碎图资源的大小比图集资源的大小还大导致的，这时候可能需要调整下图集的配置或者碎图的大小了。 生成图集 预览项目或者在 Cocos Creator 3D 中使用碎图的时候都是直接使用的碎图资源，在 构建项目 这一步才会真正生成图集到项目中，注意在构建时要勾选自动图集选项才会生效。 "},"asset/render-texture.html":{"url":"asset/render-texture.html","title":"渲染纹理","keywords":"","body":"渲染纹理资源（RenderTexture） 渲染纹理是一张在 GPU 上的纹理。通常我们会把它设置到相机的 目标纹理 上，使相机照射的内容通过离屏的 frambuffer 绘制到该纹理上。一般可用于制作汽车后视镜，动态阴影等功能。 使用 RenderTexture // 方法一：把 3D 相机照射的内容绘制到 UI 的精灵帧上 export class CaptureToWeb extends Component { @property(SpriteComponent) sprite: SpriteComponent = null; @property(CameraComponent) camera: CameraComponent = null; protected _renderTex: RenderTexture = null; start () { const spriteframe = this.sprite.spriteFrame; const sp = new SpriteFrame(); sp.reset({ originalSize: spriteframe.getOriginalSize(), rect: spriteframe.getRect(), offset: spriteframe.getOffset(), isRotate: spriteframe.isRotated(), borderTop: spriteframe.insetTop, borderLeft: spriteframe.insetLeft, borderBottom: spriteframe.insetBottom, borderRight: spriteframe.insetRight, }); const rendetTex = this._renderTex = new RenderTexture(); rendetTex.reset({ width: 256, height: 256, colorFormat: RenderTexture.PixelFormat.RGBA8888, depthStencilFormat: RenderTexture.DepthStencilFormat.DEPTH_24_STENCIL_8 }); this.camera.targetTexture = rendetTex; sp.texture = rendetTex; this.sprite.spriteFrame = sp; } } // 方法二：把 3D 相机照射的内容绘制到 3D 模型上 export class RenderCameraToModel extends Component { @property(ModelComponent) model: ModelComponent = null; start () { // Your initialization goes here. const renderTex = new RenderTexture(); renderTex.reset({ width: 256, height: 256, colorFormat: RenderTexture.PixelFormat.RGBA8888, depthStencilFormat: RenderTexture.DepthStencilFormat.DEPTH_24_STENCIL_8, }); const cameraComp = this.getComponent(CameraComponent); cameraComp.targetTexture = renderTex; const pass = this.model.material.passes[0]; const binding = pass.getBinding('mainTexture'); pass.bindTextureView(binding, renderTex.getGFXTextureView()); } } 更多方法请参考：test-case-3d "},"asset/prefab.html":{"url":"asset/prefab.html","title":"预制资源","keywords":"","body":"预制资源（Prefab） 对于项目中会重复生成的节点，使用预制件是很有必要的。 创建预制件 在场景中将节点编辑好之后，直接将节点从 层级管理器 拖到 资源管理器 中即可完成预制件的创建。 完成创建后，原节点自动变为该预制件节点，呈现 绿色。 使用预制件 将节点从 资源管理器 拖到 层级管理器 或 场景面板 中可在场景中产生一个预制件节点。 场景中的预制件节点对象，数据源来自预制件资源的反序列化，彼此是完全独立的，可多个并存，并且与预制件资源无数据上关联，资源与节点各自的改动，除非使用了 从资源还原 或 更新到资源 (下面会表述)，否则不会互相影响。 场景中编辑预制件节点 层级管理器 选中预制件节点，在 属性检查器 中顶部有可操作的几个按钮，鼠标上移会有该功能的文字提示，以下对红框区按钮的功能做说明： 第一个，还原为普通节点 预制件节点可变为普通节点，即完全脱离和资源的关系。在顶级菜单 编辑 中有此功能。 第二个，将节点关联到另一个预制件资源 作为节点重新关联资源的一种方式，需要先在 资源管理器 选中一个预制件资源，再在 层级管理器 选中预制件节点，就可以重新关联了。在顶级菜单 编辑 中有此功能。 第三个，定位资源 便于快速在 资源管理器 中定位到预制件资源，资源多时，效率较高。 第四个，从资源还原 可重新从资源反序列化出一个节点对象，替换现有节点，此操作不会改变现有节点的 uuid。一般用在节点与资源同步，或更正错误的情况下。 第五个，更新到资源 预制件节点有新的修改，同时想更新到关联的资源，可用此按钮功能。 预制件节点的状态 预制件节点在 属性检查器 呈现 绿色 表示与资源关联正常；呈现 红色 表示关联的资源不存在了。 进入预制件编辑模式 资源管理器 中双击预制件资源可从场景编辑模式切换到预制件编辑模式： 此时可以在编辑器中编辑预制件资源，编辑完成之后，点击场景编辑器中的 保存 Prefab 即可保存编辑后的预制件资源，之后点击 关闭 可返回场景编辑模式。 目前预制件节点与资源没有自动同步的功能，需要手动同步： 此种方式修改预制件资源，在保存之后并不会影响已存在的预制件节点，如果需要更新场景中的其他此类预制件节点，则节点所在的场景没有打开的需要打开处于编辑状态，再选中预制件节点，在 属性检查器 中点击顶部的 从资源还原 按钮，更新节点，最后保存场景，完成资源同步到节点。 "},"asset/script.html":{"url":"asset/script.html","title":"脚本资源","keywords":"","body":"脚本资源 在 Cocos Creator 3D 中，脚本也是资源的一部分。 关于脚本的详细介绍，可参考：脚本指南 关于脚本资源的创建和使用方法，详情可见：脚本创建 "},"asset/font.html":{"url":"asset/font.html","title":"字体资源","keywords":"","body":"字体资源 使用 Cocos Creator 制作的游戏中可以使用三类字体资源：系统字体，动态字体和位图字体。 其中系统字体是通过调用游戏运行平台自带的系统字体来渲染文字，不需要用户在项目中添加任何相关资源。要使用系统字体，请使用 Label组件 中的 Use System Font 属性。 导入字体资源 动态字体 目前 Cocos Creator 支持 TTF 格式的动态字体。只要将扩展名为 TTF 的字体文件拖拽到 资源管理器 中，即可完成字体资源的导入。 位图字体 位图字体由 fnt 格式的字体文件和一张 png 图片组成，fnt 文件提供了对每一个字符小图的索引。这种格式的字体可以由专门的软件生成，请参考： Glyph Designer Hiero BMFont (Windows) 在导入位图字体时，请务必将 fnt 文件和 png 文件同时拖拽到 资源管理器 中。 请注意，在导入位图字体之后，需要将 png 文件的类型更改为 sprite-frame ，否则位图字体将无法正常使用。 导入后的字体在 资源管理器 中显示如下： 注意 为了提高资源管理效率，建议将导入的 fnt 和 png 文件存放在单独的目录下，不要和其他资源混在一起。 使用字体资源 字体资源需要通过 Label 组件来渲染，下面是在场景中创建带有 Label 组件的节点的方法。 使用菜单创建 Label（字体）节点 在 层级管理器 中点击左上角的 创建节点 按钮，并选择 创建渲染节点/Label（文字），就会在场景中创建出一个带有 Label 组件的节点。 您也可以通过主菜单的 节点/创建渲染节点/Label（文字） 来完成创建，效果和上面的方法一样。 关联字体资源 使用上面方法创建的字体组件默认使用系统字体作为关联的资源，如果想要使用导入到项目中的 TTF 或位图字体，可以将您的字体资源拖拽到创建的 Label 组件中的 Font 属性栏中。 这时场景中的字体会立刻用刚才指定的字体资源进行渲染。您也可以根据项目需要，自由的切换同一个 Label 组件的 Font 属性，来使用 TTF 或位图字体。切换字体文件时，Label 组件的其他属性不受影响。 如果要恢复使用系统字体，可以点击 Use System Font 的属性复选框，来清除 Font 属性中指定的字体文件。 拖拽创建 Label（字体）节点 另外一种快捷使用指定资源创建字体节点的方法，是直接从 资源管理器 中拖拽字体文件（TTF 或位图字体都可以）到 层级管理器 中。和上面用菜单创建的唯一区别，是使用拖拽方式创建的文字节点会自动使用拖拽的字体资源来设置 Label 组件的 Font 属性。 "},"asset/audio.html":{"url":"asset/audio.html","title":"声音资源","keywords":"","body":"声音资源 声音资源就是音频文件 对于声音系统来说，其接口主要面向两种需求：长度较长的音乐，长度短的音效。 但对于声音资源来说，两者并没有区别，所有的音频资源在导入编辑器之后，AudioClip 资源通过 AudioSourceComponent 声音系统组件来进行相关的音频操作。关于声音系统的使用，请参考： 声音系统 支持的声音资源的格式 目前引擎的音频系统已经能够支持 web 原生支持的格式： .ogg .mp3 .wav .mp4 .m4a 声音资源的使用 在节点上添加了 AudioSourceComponent 组件之后，将导入的声音资源从 资源管理器 中 拖动到节点AudioSourceComponent组件的 Clip 中即可对该声音资源进行控制： "},"asset/material.html":{"url":"asset/material.html","title":"材质资源","keywords":"","body":"材质资源 材质创建 材质创建方式如下： 或 材质控制着每个模型最终的着色，材质由 Effect 构成，由材质操控 Effect 的着色流程。材质本身也可以看作是 Effect 资源的容器，材质可以任意切换当前要使用的 Effect 资源。下图就是我们创建的材质默认选择的 Effect 资源。 同时，我们还可以通过点击 Effect 属性右边的框要切换当前材质的 Effect。 Effect 创建 Effect 的创建方式跟 Material 的创建方式类似。 创建出来的 Effect 默认是一个 PBR 的 Effect。 以上就是一个材质的创建流程，更多信息可以参考：Effect 书写格式与语法 "},"asset/mesh.html":{"url":"asset/mesh.html","title":"模型资源","keywords":"","body":"模型资源 目前，我们支持 FBX 和 glTF 两种格式的模型文件。关于如何从第三方工具导出这两种模型文件，可以参考这里。 模型导入 从外部导入编辑器中后，在 资源管理器 中可得到对应的模型资源文件，其目录结构如下：（以 glTF 文件为例，fbx 文件相同） 无动画的模型文件结构如下： 包含动画的模型文件结构如下： 其中： .material 文件为材质文件 .mesh 文件为模型文件 .texture 文件为模型贴图文件 .animation 文件为模型动画文件 .skeleton 文件为模型骨骼文件 .prefab 文件为导入时自动生成的预制体文件 模型使用 将模型文件导入后，直接将模型文件的根节点从资源管理器 拖拽到 层级管理器 中想要放置的节点下即可完成节点创建，此时模型就成功在场景中创建了。 或者也可以将模型文件的节点展开，选中模型文件节点下的 .prefab 文件，从 资源管理器 拖拽到 层级管理器 中同样能够完成创建。 模型资源属性面板说明 当在 资源管理器 中 选中模型资源文件时（ .fbx 或 .gltf ）,在 属性检查器 中可以设置模型资源的相关属性： model 模块 Normals 法线信息：有 Optional，Exclude，Require，Recalculate 四种选项 Tangents 切空间信息：有 Optional，Exclude，Require，Recalculate 四种选项 SkipValidation ：是否跳过标准检测 Animation 模块 上方的动画文件表格是当前模型下的所有动画资源信息，下方是当前选择动画的具体帧数信息的编辑区域，可以在此处更改动画名称或进行简单的动画裁剪。 点击图上红框内的 + 按钮可以添加动画文件，添加的新文件默认拷贝一份完整的 clip 数据，可以再下方的 Start End 输入框内输入帧数来裁剪动画。(目前暂时不支持拖拽裁剪动画) 点击图上红框内的 - 按钮可以删除当前选中的动画文件 Material 模块 DumpMaterial ：当对模型文件自带的材质不满意想要修改时，需开启此选项，将文件结构目录下的材质文件 dump 出模型资源中，此时就可以进行材质的调整修改了 Dumper Directory ：这里可以指定或者查看 dump 出来的目录位置 关于 glTF 目前我们的引擎已支持 glTF 2.0 规范，但暂时不支持以下功能： Sparse accessor morph target "},"asset/anim.html":{"url":"asset/anim.html","title":"动画资源","keywords":"","body":"动画资源 编辑器自定义动画 编辑器内自定义动画的创建以及格式请参考：动画创建，格式说明 模型导入后附带的骨骼动画 带动画的模型导入后，会生成对应模型带上的动画，这个动画和内部新建资源的使用方式是一致，骨骼动画的裁剪可以参考模型资源的动画模块介绍。 "},"getting-started/":{"url":"getting-started/","title":"启动","keywords":"","body":"新手上路 欢迎使用 Cocos Creator 3D，在学习使用之前，请先按照以下步骤安装好编辑器开发环境。 在安装完我们的编辑器之后，就可以通过 Hello world! 熟悉编辑器，也可以参考我们的 示例游戏 进行自己的开发啦。 本章节包括以下内容： Dashboard Hello world! 快速上手：制作第一个游戏 注意事项 继续前往 Dashboard 说明文档。 "},"getting-started/helloworld/":{"url":"getting-started/helloworld/","title":"Hello world!","keywords":"","body":"Hello World项目 第一个Cocos Creator 3D项目, 为您展示: 创建项目 了解工程目录 创建一个物体 修改相机属性 创建、修改、绑定脚本 运行及调试项目 新建项目 在Dashboard面板中，点击右下角新建按钮，在弹出菜单中选中Creator 3D。 选择空的模板，设置项目路径，点击下方的创建按钮。 编辑器界面 工程目录 通常情况的我们只需要关心assets(资源目录) assets(资源目录) build(构建目录) library(导入的资源目录) local(日志文件目录) profiles(编辑器配置) temp(临时文件目录) package.json(项目配置) 新建场景 左下方资源管理器面板点击鼠标右键，选择新建->Scene。 创建物体 左上方层级管理器面板点击鼠标右键, 选择创建->3D对象->Cube 正方体。创建的正方体就会出现在场景编辑器里。 修改Camera 选择Camera对象 在层级管理器面板，选择Camera，场景编辑器会选中它，并显示Gizmo。 修改Camera位置 在场景编辑器里，拖动Gizmo, 使Camera能够看到创建的正方体。 修改Camera背景颜色 在属性检查器面板，点击Color属性，选择黑色为背景色。 添加脚本 新建脚本 在资源管理器面板点击鼠标右键，选择新建->TypeScript。 生命周期函数（按以下顺序调用） onLoad 脚本初始化时调用 onEnable 组件的 enabled 属性从 false 变为 true 时调用 start 组件第一次激活时调用 update 每一帧渲染前更新物体调用 lateUpdate 在所有组件的 update 都执行完之后调用 onDisable 组件的 enabled 属性从 true 变为 false 时调用 onDestroy 组件或者所在节点销毁时调用 添加代码 添加onLoad()函数，并输出Hello world import { _decorator, Component, Node } from 'cc'; const { ccclass, property } = _decorator; @ccclass('HelloWorld') export class HelloWorld extends Component { /* class member could be defined like this */ // dummy = ''; /* use `property` decorator if your want the member to be serializable */ // @property // serializableDummy = 0; start () { // Your initialization goes here. console.info('Hello world'); } // update (deltaTime: number) { // // Your update function goes here. // } } 为物体绑定脚本 选择创建的正方体，在属性检查器面板点击添加组件->自定义脚本->HelloWorld 运行项目 编辑器菜单栏点击->项目->运行预览, 或者点击中间的运行按钮。 调试项目 以Chrome浏览器为例： 按 F12 或者 Ctrl + Shift + I 打开Chrome的开发者工具。 日志信息 Console面板显示了所有日志输出 断点调试 选择标签栏的Source选项，按下Ctrl+P，搜索HelloWorld.js，在onLoad函数里设置断点，再刷新网页就可以调试了。 "},"getting-started/first-game/":{"url":"getting-started/first-game/","title":"快速上手：制作第一个游戏","keywords":"","body":"快速上手：制作第一个游戏 Cocos Creator 3D编辑器的强大之处就是可以让开发者快速的制作游戏原型。 下面我们将跟随教程制作一款名叫 一步两步 的魔性小游戏。这款游戏考验玩家的反应能力，根据路况选择是要跳一步还是跳两步，“一步两步，一步两步，一步一步似爪牙似魔鬼的步伐”。 可以在 这里 体验一下游戏的完成形态。 新建项目 如果您还不了解如何获取和启动 Cocos Creator 3D，请阅读 安装和启动 一节。 首先启动 Cocos Creator 3D，然后新建一个名为 MindYourStep 的项目，如果不知道如何创建项目，请阅读 Hello World!。 新建项目后会看到如下的编辑器界面： 创建游戏场景 在 Cocos Creator 3D 中，游戏场景（Scene） 是开发时组织游戏内容的中心，也是呈现给玩家所有游戏内容的载体。游戏场景中一般会包括以下内容： 场景物体 角色 UI 以组件形式附加在场景节点上的游戏逻辑脚本 当玩家运行游戏时，就会载入游戏场景，游戏场景加载后就会自动运行所包含组件的游戏脚本，实现各种各样开发者设置的逻辑功能。所以除了资源以外，游戏场景是一切内容创作的基础。现在，让我们来新建一个场景。 在 资源管理器 中点击选中 assets 目录，点击 资源管理器 左上角的加号按钮，选择文件夹，命名为Scenes。 点击先中Scenes目录（下图把一些常用的文件夹都提前创建好了），点击鼠标右键，在弹出的菜单中选择 场景文件 我们创建了一个名叫 New Scene 的场景文件，创建完成后场景文件 New Scene 的名称会处于编辑状态，将它重命名为 Main。 双击 Main，就会在 场景编辑器 和 层级管理器 中打开这个场景。 添加跑道 我们的主角需要在一个由方块（Block）组成的跑道上从屏幕左边向右边移动。我们使用编辑器自带的立方体（Cube）来组成道路。 在 层级管理器 中创建一个立方体（Cube），并命名为Cube。 选中Cube，按Ctrl+D来复制出3个Cube。 将3个Cube按以下坐标排列：第一个节点位置（0，-1.5，0），第二个节点位置（1，-1.5，0），第三个节点位置（2，-1.5，0） 效果如下： 添加主角 创建主角节点 首先创建一个名字为Player的空节点，然后在这个空节点下创建名为Body的主角模型节点，为了方便，我们采用编辑器自带的胶囊体模型做为主角模型。 分为两个节点的好处是，我们可以使用脚本控制Player节点来使主角进行水平方向移动，而在Body节点上做一些垂直方向上的动画（比如原地跳起后下落），两者叠加形成一个跳越动画。 将Player节点设置在（0，0，0）位置，使得它能站在第一个方块上。 效果如下： 编写主角脚本 想要主角影响鼠标事件来进行移动，我们就需要编写自定义的脚本。如果您从没写过程序也不用担心，我们会在教程中提供所有需要的代码，只要复制粘贴到正确的位置就可以了，之后这部分工作可以找您的程序员小伙伴来解决。下面让我们开始创建驱动主角行动的脚本吧。 创建脚本 如果还没有创建Scripts文件夹，首先在 资源管理器 中右键点击 assets 文件夹，选择 新建 -> 文件夹，重命名为Scripts。 右键点击Scripts文件夹，选择 新建 -> TypeScript，创建一个 TypeScript 脚本，有关TypeScript资料可以查看 TypeScript 官方网站。 将新建脚本的名字改为PlayerController，双击这个脚本，打开代码编辑器（例如VSCode）。 注意： Cocos Creator 3D 中脚本名称就是组件的名称，这个命名是大小写敏感的！如果组件名称的大小写不正确，将无法正确通过名称使用组件！ 编写脚本代码 在打开的 PlayerController 脚本里已经有了预先设置好的一些代码块，如下所示： import { _decorator, Component } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"PlayerController\") export class PlayerController extends Component { /* class member could be defined like this */ // dummy = ''; /* use `property` decorator if your want the member to be serializable */ // @property // serializableDummy = 0; start () { // Your initialization goes here. } // update (deltaTime: number) { // // Your update function goes here. // } } 这些代码就是编写一个组件（脚本）所需的结构。具有这样结构的脚本就是 Cocos Creator 3D 中的 组件（Component），他们能够挂载到场景中的节点上，提供控制节点的各种功能，更详细的脚本信息可以查看 脚本。 我们在脚本中添加对鼠标事件的监听，然后让Player动起来，将PlayerController中代码做如下修改。 import { _decorator, Component, Vec3, systemEvent, SystemEvent, EventMouse, AnimationComponent, v3 } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"PlayerController\") export class PlayerController extends Component { /* class member could be defined like this */ // dummy = ''; /* use `property` decorator if your want the member to be serializable */ // @property // serializableDummy = 0; // for fake tween private _startJump: boolean = false; private _jumpStep: number = 0; private _curJumpTime: number = 0; private _jumpTime: number = 0.1; private _curJumpSpeed: number = 0; private _curPos: Vec3 = v3(); private _deltaPos: Vec3 = v3(0, 0, 0); private _targetPos: Vec3 = v3(); private _isMoving = false; start () { // Your initialization goes here. systemEvent.on(SystemEvent.EventType.MOUSE_UP, this.onMouseUp, this); } onMouseUp(event: EventMouse) { if (event.getButton() === 0) { this.jumpByStep(1); } else if (event.getButton() === 2) { this.jumpByStep(2); } } jumpByStep(step: number) { if (this._isMoving) { return; } this._startJump = true; this._jumpStep = step; this._curJumpTime = 0; this._curJumpSpeed = this._jumpStep / this._jumpTime; this.node.getPosition(this._curPos); Vec3.add(this._targetPos, this._curPos, v3(this._jumpStep, 0, 0)); this._isMoving = true; } onOnceJumpEnd() { this._isMoving = false; } update (deltaTime: number) { if (this._startJump) { this._curJumpTime += deltaTime; if (this._curJumpTime > this._jumpTime) { // end this.node.setPosition(this._targetPos); this._startJump = false; this.onOnceJumpEnd(); } else { // tween this.node.getPosition(this._curPos); this._deltaPos.x = this._curJumpSpeed * deltaTime; Vec3.add(this._curPos, this._curPos, this._deltaPos); this.node.setPosition(this._curPos); } } } } 现在我们可以把 PlayerController 组件添加到主角节点上。在 层级管理器 中选中 Player 节点，然后在 属性检查器 中点击 添加组件 按钮，选择 添加用户脚本组件 -> PlayerController，为主角节点添加 PlayerController 组件。 为了能在运行时看到物体，我们需要将场景中的Camera进行一些参数调整，将位置放到（0，0，13），Color设置为（50，90，255，255）： 现在点击工具栏中心位置的Play按钮，在打开的网页中点击鼠标左键和右键，可以看到如下画面： 更多的预览功能，可以参考 项目预览调试 添加角色动画 从上面运行的结果可以看到单纯对Player进行水平方向的移动是十分呆板的，我们要让Player跳跃起来才比较有感觉，我们可以通过为角色添加垂直方向的动画来达到这个效果。有关 动画编辑器 的更多信息，请阅读 动画编辑器 选中场景中的Body节点，编辑器下方 控制台 边上的 动画编辑器，添加Animation组件并创建Clip，命名为oneStep。 进入动画编辑模式，添加position属性轨道，并添加三个关键帧，position值分别为（0，0，0）、（0，0.5，0）、（0，0，0）。 退出动画编辑模式前前记得要保存动画，否则做的动画就白费了。 我们还可以通过 资源管理器 来创建Clip，下面我们创建一个名为twoStep的Clip并将它添加到Body身上的 AnimationComponent 上，这里为了录制方便调整了一下面板布局。 进入动画编辑模式，选择并编辑twoStep的clip，类似第2步，添加三个position的关键帧，分别为（0，0，0）、（0，1，0）、（0，0，0）。 在 PlayerController组件 中引用 动画组件 ，我们需要在代码中根据跳的步数不同来播放不同的动画。 首先需要 在 PlayerController组件 中引用Body身上的 AnimationComponent。 @property({type: AnimationComponent}) public BodyAnim: AnimationComponent = null; 然后在 属性检查器 中将Body身上的 AnimationComponent 拖到这个变量上。 在跳跃的函数 jumpByStep 中加入动画播放的代码： if (step === 1) { this.BodyAnim.play('oneStep'); } else if (step === 2) { this.BodyAnim.play('twoStep'); } 点击Play按钮,点击鼠标左键、右键，可以看到新的跳跃效果： 跑道升级 为了让游戏有更久的生命力，我们需要一个很长的跑道来让Player在上面一直往右边跑，在场景中复制一堆Cube并编辑位置来组成跑道显然不是一个明智的做法，我们通过脚本完成跑道的自动创建。 游戏管理器（GameManager） 一般游戏都会有一个管理器，主要负责整个游戏生命周期的管理，可以将跑道的动态创建代码放到这里。在场景中创建一个名为GameManager的节点，然后在 assets/Scripts 中创建一个名为GameManager的ts脚本文件，并将它添加到GameManager节点上。 制作Prefab 对于需要重复生成的节点，我们可以将他保存成 Prefab（预制） 资源，作为我们动态生成节点时使用的模板。关于 Prefab 的更多信息，请阅读 预制资源（Prefab）。 我们将生成跑道的基本元素正方体（Cube）制作成Prefab，之后可以把场景中的三个Cube都删除了。 添加自动创建跑道代码 我们需要一个很长的跑道，理想的方法是能动态增加跑道的长度，这样可以永无止境的跑下去，这里为了方便我们先生成一个固定长度的跑道，跑道长度可以自己定义。跑道上会生成一些坑，跳到坑上就GameOver了。 将GameManager脚本中代码替换成以下代码： import { _decorator, Component, Prefab, instantiate, Node, CCInteger} from \"cc\"; const { ccclass, property } = _decorator; enum BlockType{ BT_NONE, BT_STONE, }; @ccclass(\"GameManager\") export class GameManager extends Component { @property({type: Prefab}) public cubePrfb: Prefab = null; @property({type: CCInteger}) public roadLength: Number = 50; private _road: number[] = []; start () { this.generateRoad(); } generateRoad() { this.node.removeAllChildren(true); this._road = []; // startPos this._road.push(BlockType.BT_STONE); for (let i = 1; i 在GameManager的inspector面板中可以通过修改roadLength的值来改变跑道的长度。 预览可以看到现在自动生成了跑道，不过因为Camera没有跟随Player移动，所以看不到后面的跑道，我们可以将场景中的Camera设置为Player的子节点。 这样Camera就会跟随Player的移动而移动，现在预览可以从头跑到尾的观察生成的跑道了。 增加开始菜单 开始菜单是游戏不可或缺的一部分，我们可以在这里加入游戏名称、游戏简介、制作人员等信息。 添加一个名为Play的按钮 这个操作生成了一个Canvas节点，一个PlayButton节点和一个Label节点。因为UI组件需要在带有 CanvasComponent 的父节点下才能显示，所以编辑器在发现目前场景中没有带这个组件的节点时会自动添加一个。 创建按钮后，将Label节点上的 cc.LabelComponent 的String属性从Button改为Play。 在Canvas底下创建一个名字为StartMenu的空节点，将PlayButton拖到它底下。我们可以通过点击工具栏上的2D/3D按钮来切换到2D编辑视图下进行UI编辑操作，详细的描述请查阅 场景编辑。 增加一个背景框，在StartMenu下新建一个名字为BG的Sprite节点，调节它的位置到PlayButton的上方，设置它的宽高为（200，200）,并将它的SpriteFrame设置为 internal/default_ui/default_sprite_splash 。 添加一个名为Title的 Label 用于开始菜单的标题，。 修改Title的文字，并调整Title的位置、文字大小、颜色。 增加操作的Tips，然后调整PlayButton的位置，一个简单的开始菜单就完成了 增加游戏状态逻辑，一般我们可以将游戏分为三个状态： 初始化（Init）：显示游戏菜单，初始化一些资源。 游戏进行中（Playing）：隐藏游戏菜单，玩家可以操作角度进行游戏。 结束（End）：游戏结束，显示结束菜单。 使用一个枚举（enum）类型来表示这几个状态。 enum BlockType{ BT_NONE, BT_STONE, }; enum GameState{ GS_INIT, GS_PLAYING, GS_END, }; GameManager脚本中加入表示当前状态的私有变量 private _curState: GameState = GameState.GS_INIT; 为了在开始时不让用户操作角色，而在游戏进行时让用户操作角色，我们需要动态的开启和关闭角色对鼠标消息的监听。 所以对PlayerController做如下的修改： start () { // Your initialization goes here. //systemEvent.on(SystemEvent.EventType.MOUSE_UP, this.onMouseUp, this); } setInputActive(active: boolean) { if (active) { systemEvent.on(SystemEvent.EventType.MOUSE_UP, this.onMouseUp, this); } else { systemEvent.off(SystemEvent.EventType.MOUSE_UP, this.onMouseUp, this); } } 然后需要在GameManager脚本中引用PlayerController，需要在Inspector中将场景的Player拖入到这个变量中。 @property({type: PlayerController}) public playerCtrl: PlayerController = null; 为了动态的开启\\关闭开启菜单，我们需要在GameManager中引用StartMenu节点，需要在Inspector中将场景的StartMenu拖入到这个变量中。 @property({type: Node}) public startMenu: Node = null; 增加状态切换代码，并修改GameManger的初始化方法： start () { this.curState = GameState.GS_INIT; } init() { this.startMenu.active = true; this.generateRoad(); this.playerCtrl.setInputActive(false); this.playerCtrl.node.setPosition(v3()); } set curState (value: GameState) { switch(value) { case GameState.GS_INIT: this.init(); break; case GameState.GS_PLAYING: this.startMenu.active = false; setTimeout(() => { //直接设置active会直接开始监听鼠标事件，做了一下延迟处理 this.playerCtrl.setInputActive(true); }, 0.1); break; case GameState.GS_END: break; } this._curState = value; } 添加对Play按钮的事件监听。 为了能在点击Play按钮后开始游戏，我们需要对按钮的点击事件做出响应。 在GameManager脚本中加入响应按钮点击的代码，在点击后进入游戏的Playing状态： onStartButtonClicked() { this.curState = GameState.GS_PLAYING; } 然后在Play按钮的Inspector上添加ClickEvents的响应函数。 现在预览场景就可以点击Play按钮开始游戏了。 添加游戏结束逻辑 目前游戏角色只是呆呆的往前跑，我们需要添加游戏规则，来让他跑的更有挑战性。 角色每一次跳跃结束需要发出消息，并将自己当前所在位置做为参数发出消息 在PlayerController中记录自己跳了多少步 private _curMoveIndex = 0; // ... jumpByStep(step: number) { // ... this._curMoveIndex += step; } 在每次跳跃结束发出消息： onOnceJumpEnd() { this._isMoving = false; this.node.emit('JumpEnd', this._curMoveIndex); } 在GameManager中监听角色跳跃结束事件，并根据规则判断输赢 增加失败和结束判断，如果跳到空方块或是超过了最大长度值都结束： checkResult(moveIndex: number) { if (moveIndex 监听角色跳跃消息，并调用判断函数： start () { this.curState = GameState.GS_INIT; this.playerCtrl.node.on('JumpEnd', this.onPlayerJumpEnd, this); } // ... onPlayerJumpEnd(moveIndex: number) { this.checkResult(moveIndex); } 此时预览，会发现重新开始游戏时会有判断出错，是因为我们重新开始时没有重置PlayerController中的_curMoveIndex属性值。所以我们在PlayerController中增加一个reset函数： reset() { this._curMoveIndex = 0; } 在GameManager的init函数调用reset来重置PlayerController的属性。 init() { \\\\ ... this.playerCtrl.reset(); } 步数显示 我们可以将当前跳的步数显示到界面上，这样在跳跃过程中看着步数的不断增长会十分有成就感。 在Canvas下新建一个名为Steps的Label，调整位置、字体大小等属性。 在GameManager中引用这个Label @property({type: LabelComponent}) public stepsLabel: LabelComponent = null; 将当前步数数据更新到这个Label中 因为我们现在没有结束界面，游戏结束就跳回开始界面，所以在开始界面要看到上一次跳的步数，因此我们在进入Playing状态时，将步数重置为0。 set curState (value: GameState) { switch(value) { case GameState.GS_INIT: this.init(); break; case GameState.GS_PLAYING: this.startMenu.active = false; this.stepsLabel.string = '0'; // 将步数重置为0 setTimeout(() => { //直接设置active会直接开始监听鼠标事件，做了一下延迟处理 this.playerCtrl.setInputActive(true); }, 0.1); break; case GameState.GS_END: break; } this._curState = value; } 在响应角色跳跃的函数中，将步数更新到Label控件上 onPlayerJumpEnd(moveIndex: number) { this.stepsLabel.string = '' + moveIndex; this.checkResult(moveIndex); } 光照和阴影 有光的地方就会有影子，光和影构成明暗交错的3D世界。接下来我们为角色加上简单的影子。 开启阴影 在 层级管理器 中点击最顶部的 Scene 节点，将planarShadows选项中的Enabled打钩，并修改Distance和Normal参数 点击Player节点下的Body节点，将 cc.ModelComponent 下的ShadowCastingMode设置为ON。 此时在场景编辑器中会看到一个阴影面片，预览会发现看不到这个阴影，因为它在模型的正后方，被胶囊体盖住了。 调整光照 新建场景时默认会添加一个 DirctionalLight ，由这个平行光计算阴影，所以为了让阴影换个位置显示，我们可以调整这个平行光的方向。 在 层级管理器 中点击选中 Main Light 节点，调整Rotation参数为（-10，17，0）。 预览可以看到影子效果： 添加主角模型 做为一个官方教程，用胶囊体当主角显的有点寒碜，所以我们花（低）重（预）金（算）制作了一个Cocos主角。 导入模型资源 从原始资源导入模型、材质、动画等资源不是本篇基础教程的重点，所以这边直接使用已经导入工程的资源。 将项目工程中assets目录下的cocos文件夹拷贝到你自己工程的assets目录下。 添加到场景中 在cocos文件中已经包含了一个名为Cocos的Prefab，将它拖到场景中Player下的Body节点中。 此时会发现模型有些暗，可以加个聚光灯，以突出它锃光瓦亮的脑门。 添加跳跃动画 现在预览可以看到主角初始会有一个待机动画，但是跳跃时还是用这个待机动画会显得很不协调，所以我们在跳跃过程中换成跳跃的动画。 在 PlayerController 类中添加一个引用模型动画的变量： @property({type: SkeletalAnimationComponent}) public CocosAnim: SkeletalAnimationComponent = null; 然后在Inspector中要将Cocos节点拖入这个变量里。 在jumpByStep函数中播放跳跃动画 jumpByStep(step: number) { if (this._isMoving) { return; } this._startJump = true; this._jumpStep = step; this._curJumpTime = 0; this._curJumpSpeed = this._jumpStep / this._jumpTime; this.node.getPosition(this._curPos); Vec3.add(this._targetPos, this._curPos, v3(this._jumpStep, 0, 0)); this._isMoving = true; this.CocosAnim.getState('cocos_anim_jump').speed = 3.5; //跳跃动画时间比较长，这里加速播放 this.CocosAnim.play('cocos_anim_jump'); //播放跳跃动画 if (step === 1) { //this.BodyAnim.play('oneStep'); } else if (step === 2) { this.BodyAnim.play('twoStep'); } this._curMoveIndex += step; } 在onOnceJumpEnd函数中让主角变为待机状态，播放待机动画。 onOnceJumpEnd() { this._isMoving = false; this.CocosAnim.play('cocos_anim_idle'); this.node.emit('JumpEnd', this._curMoveIndex); } 预览效果： 最终代码 PlayerController.ts import { _decorator, Component, Vec3, systemEvent, SystemEvent, EventMouse, AnimationComponent, SkeletalAnimationComponent, v3 } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"PlayerController\") export class PlayerController extends Component { @property({type: AnimationComponent}) public BodyAnim: AnimationComponent = null; @property({type: SkeletalAnimationComponent}) public CocosAnim: SkeletalAnimationComponent = null; // for fake tween private _startJump: boolean = false; private _jumpStep: number = 0; private _curJumpTime: number = 0; private _jumpTime: number = 0.3; private _curJumpSpeed: number = 0; private _curPos: Vec3 = v3(); private _deltaPos: Vec3 = v3(0, 0, 0); private _targetPos: Vec3 = v3(); private _isMoving = false; private _curMoveIndex = 0; start () { } reset() { this._curMoveIndex = 0; } setInputActive(active: boolean) { if (active) { systemEvent.on(SystemEvent.EventType.MOUSE_UP, this.onMouseUp, this); } else { systemEvent.off(SystemEvent.EventType.MOUSE_UP, this.onMouseUp, this); } } onMouseUp(event: EventMouse) { if (event.getButton() === 0) { this.jumpByStep(1); } else if (event.getButton() === 2) { this.jumpByStep(2); } } jumpByStep(step: number) { if (this._isMoving) { return; } this._startJump = true; this._jumpStep = step; this._curJumpTime = 0; this._curJumpSpeed = this._jumpStep / this._jumpTime; this.node.getPosition(this._curPos); Vec3.add(this._targetPos, this._curPos, v3(this._jumpStep, 0, 0)); this._isMoving = true; this.CocosAnim.getState('cocos_anim_jump').speed = 3.5; //跳跃动画时间比较长，这里加速播放 this.CocosAnim.play('cocos_anim_jump'); //播放跳跃动画 if (step === 1) { //this.BodyAnim.play('oneStep'); } else if (step === 2) { this.BodyAnim.play('twoStep'); } this._curMoveIndex += step; } onOnceJumpEnd() { this._isMoving = false; this.CocosAnim.play('cocos_anim_idle'); this.node.emit('JumpEnd', this._curMoveIndex); } update (deltaTime: number) { if (this._startJump) { this._curJumpTime += deltaTime; if (this._curJumpTime > this._jumpTime) { // end this.node.setPosition(this._targetPos); this._startJump = false; this.onOnceJumpEnd(); } else { // tween this.node.getPosition(this._curPos); this._deltaPos.x = this._curJumpSpeed * deltaTime; Vec3.add(this._curPos, this._curPos, this._deltaPos); this.node.setPosition(this._curPos); } } } } GameManager.ts import { _decorator, Component, Prefab, instantiate, Node, LabelComponent, CCInteger, v3} from \"cc\"; import { PlayerController } from \"./PlayerController\"; const { ccclass, property } = _decorator; enum BlockType{ BT_NONE, BT_STONE, }; enum GameState{ GS_INIT, GS_PLAYING, GS_END, }; @ccclass(\"GameManager\") export class GameManager extends Component { @property({type: Prefab}) public cubePrfb: Prefab = null; @property({type: CCInteger}) public roadLength: Number = 50; private _road: number[] = []; @property({type: Node}) public startMenu: Node = null; @property({type: PlayerController}) public playerCtrl: PlayerController = null; private _curState: GameState = GameState.GS_INIT; @property({type: LabelComponent}) public stepsLabel: LabelComponent = null; start () { this.curState = GameState.GS_INIT; this.playerCtrl.node.on('JumpEnd', this.onPlayerJumpEnd, this); } init() { this.startMenu.active = true; this.generateRoad(); this.playerCtrl.setInputActive(false); this.playerCtrl.node.setPosition(v3()); this.playerCtrl.reset(); } set curState (value: GameState) { switch(value) { case GameState.GS_INIT: this.init(); break; case GameState.GS_PLAYING: this.startMenu.active = false; this.stepsLabel.string = '0'; // 将步数重置为0 setTimeout(() => { //直接设置active会直接开始监听鼠标事件，做了一下延迟处理 this.playerCtrl.setInputActive(true); }, 0.1); break; case GameState.GS_END: break; } this._curState = value; } generateRoad() { this.node.removeAllChildren(); this._road = []; // startPos this._road.push(BlockType.BT_STONE); for (let i = 1; i 总结 恭喜您完成了用 Cocos Creator 3D 制作的第一个游戏！在 这里 可以下载完整的工程，希望这篇快速入门教程能帮助您了解 Cocos Creator 3D 游戏开发流程中的基本概念和工作流程。如果您对编写和学习脚本编程不感兴趣，也可以直接从完成版的项目工程中把写好的脚本复制过来使用。 接下来您还可以继续完善游戏的各方各面，以下是一些推荐的改进方向： 为游戏增加难度，当角色在原地停留1秒就算失败 改为无限跑道，动态的删除已经跑过的跑道，延长后面的跑道。 增加游戏音效 为游戏增加结束菜单界面，统计玩家跳跃步数和所花的时间 用更漂亮的资源替换角色和跑道 可以增加一些可拾取物品来引导玩家“犯错” 添加一些粒子特效，例如角色运动时的拖尾、落地时的灰尘 为触屏设备加入两个操作按钮来代替鼠标左右键操作 此外如果希望将完成的游戏发布到服务器上分享给好友玩耍，可以阅读 发布工作流 一节的内容。 "},"editor/publish/publish-baidu-mini-game.html":{"url":"editor/publish/publish-baidu-mini-game.html","title":"发布到百度小游戏","keywords":"","body":"发布到百度小游戏 Cocos Creator 3D从 v1.0.3 版本开始正式支持将游戏发布到百度小游戏。 百度小游戏是基于手机百度 app 上的智能小程序进行扩展的小游戏，它不仅提供了强大的游戏能力，还和智能小程序一样，提供了大量的原生接口，比如支付，文件系统，位置，分享等。相当于同时结合了 WEB 易于传播以及 Native 功能丰富的优势。 百度小游戏的运行环境和微信小游戏类似，基本思路也是封装必要的 WEB 接口提供给用户，尽可能追求和 WEB 同样的开发体验。百度小游戏在智能小程序环境的基础上提供了 WebGL 接口的封装，使得渲染能力和性能有了大幅度提升。不过由于这些接口都是百度团队通过自研的原生实现封装的，所以并不可以等同为浏览器环境。 作为引擎方，为了尽可能简化开发者的工作量，我们为用户完成的主要工作包括： 引擎框架适配百度小游戏 API，纯游戏逻辑层面，用户不需要任何额外的修改 Cocos Creator 3D编辑器提供了快捷的打包流程，直接发布为百度小游戏 自动加载远程资源，缓存资源以及缓存资源版本控制 具体百度小游戏的申请入驻，开发准备，游戏提交，审核和发布流程可以参考 百度小游戏注册指导文档。 使用 Cocos Creator 3D 发布百度小游戏 准备工作 在 百度开发者工具文档 里下载并安装百度开发者工具 在手机的应用商店中下载并安装百度应用 登录 智能小程序平台，找到 appid 发布流程 在 构建发布 面板中选择 发布平台 为 百度小游戏，填入 appid，然后点击 构建。 构建完成后，会在发布包的目录下生成一个 baidugame 的百度小游戏工程文件夹，其中已经包含了百度小游戏环境的配置文件：game.json 和 project.swan.json 使用 百度开发者工具 打开构建生成的 baidugame 文件夹，即可打开百度小游戏项目及预览调试游戏内容。百度开发者工具 的使用方式请参考 百度开发者工具文档。 注意： 请不要升级 百度开发者工具 到 2.0.10 版本。 预览调试时若出现了 当前版本的开发者工具无法发布小程序，请更新最新的开发者工具 的提示，说明填写的 appid 是小程序的 appid，不是小游戏的 appid，请重新申请一个小游戏 appid。 百度小游戏环境的资源管理 百度小游戏与微信小游戏类似，都存在着包体限制，超过 4MB 的额外资源，必须通过网络请求下载。 我们建议用户只保存脚本文件在小游戏包内，其他资源都从远程服务器下载。Cocos Creator 3D已经帮用户做好了远程资源的下载、缓存和版本管理。具体的实现逻辑和微信小游戏类似，具体可参考 微信小游戏资源管理。 同时，当开启引擎的 md5Cache 功能后，文件的 url 会随着文件内容的改变而改变，这样当游戏发布新版本后，旧版本的资源在缓存中就自然失效了，只能从服务器请求新的资源，也就达到了版本控制的效果。 具体来说，开发者需要做的是： 构建时，在 构建发布 面板中勾选 md5Cache 功能。 设置 远程服务器地址，然后点击 构建。 构建完成后将百度小游戏发布包目录下的 res 文件夹完整的上传到服务器。 删除本地发布包目录下的 res 文件夹。 注意： 百度在真机上加载远程服务器上的资源时，目前只支持通过 https 访问，所以必须将资源文件放在 https 服务器上，否则会出现加载资源失败的情况。 如果缓存资源超过百度环境限制，用户需要手动清除资源，可以在百度小游戏中使用 remoteDownloader.cleanAllCaches() 和 remoteDownloader.cleanOldCaches() 接口来清除缓存。前者会清除缓存目录下的所有缓存资源，请慎重使用；而后者会清除缓存目录下目前应用中未使用到的缓存资源。 百度小游戏分包加载 百度小游戏的分包加载方式和微信小游戏类似，其包体限制如下： 所有包的总大小不超过 8MB 单个分包/主包大小不超过 4MB 具体的分包加载机制可参考 分包加载。 平台 SDK 接入 除了纯游戏内容以外，百度小游戏环境还提供了非常强大的原生 SDK 接口，这些接口都是仅存在于百度小游戏环境中的，等同于其他平台的第三方 SDK 接口。这类 SDK 接口的移植工作在现阶段还是需要开发者自己处理。下面列举一些百度小游戏所提供的强大 SDK 能力： 用户接口：登陆，授权，用户信息等 百度收银台支付 转发信息 文件上传下载 其他：图片、位置、广告、设备信息等等 百度小游戏已知问题： 目前 Cocos Creator 3D 对百度小游戏的适配工作还未完全结束，暂时还不支持以下组件： VideoPlayer WebView 参考链接 百度小游戏注册指导文档 百度开发者工具文档 百度小游戏 API 文档 "},"module-map/":{"url":"module-map/","title":"功能地图","keywords":"","body":"引擎功能地图导览 图形渲染渲染系统，包括材质，光照，粒子等 UI系统UI系统，包括与UI 相关的全部内容 动画系统基于动画帧数据及骨骼顶点数据的通用动画及骨骼动画体系 音频控制声音片段的播放暂停等 物理模拟物理仿真模拟，主要包括刚体和碰撞等 脚本指南及事件系统用于实现用户定义行为的脚本使用指南，包括事件的触发机制等 组件用于为游戏对象添加不同功能的组件说明 资源引擎使用到的各种不同资源介绍及整体资源工作流概述 场景及环境设置场景结构及环境相关设置 "},"module-map/graphics.html":{"url":"module-map/graphics.html","title":"图形渲染","keywords":"","body":"图形渲染 材质着色器控制的模型表面外形 光照光照、阴影控制及环境设置 粒子系统各种类型粒子特效的创建及使用 "},"ui-system/components/editor/ui-coordinate-tracker.html":{"url":"ui-system/components/editor/ui-coordinate-tracker.html","title":"UICoordinateTracker 组件参考","keywords":"","body":"UICoordinateTracker UI 坐标跟踪映射组件 该组件是在 UI 上执行坐标转换以及模拟透视相机下 3D 物体近大远小效果。通过事件的方式将转换后的坐标以及物体在视口下的占比返回。适用于 3D 人物血条以及姓名条之类功能。 UICoordinateTracker 属性 属性 功能说明 Target 目标对象。需要转换到哪一个 UI 节点下。 Camera 照射相机。 UseScale 是否是缩放映射。如果是透视相机，勾选此项，返回一个物体在视口下的占比。 Distance 距相机多少距离为正常显示计算大小。根据模型在相机下的照射效果调整最佳位置，以该位置为分界线计算在视口占比。 CoordinateDataEvents 映射数据事件。回调的第一个参数是映射后的本地坐标，第二个是距相机距离比。 案例可参照：https://github.com/cocos-creator/demo-ui/tree/3d 的 rocker 场景。 该组件即将在 1.2 版本上移除。 "},"submit-pr/submit-pr.html":{"url":"submit-pr/submit-pr.html","title":"向 Cocos 提交代码","keywords":"","body":"如何向 Cocos 提交代码 和 Cocos2d-x-lite 一样，Cocos Creator 3D 也是一个开源引擎，连同范例、文档都是开源的。 在你开发游戏的过程中，当发现了引擎、文档或者范例不够完善的地方，如果仅仅是向官方团队提出建议，官方团队可能会因为人力资源的紧张而无法及时跟进。在此我们欢迎所有用户主动向我们提交 PR，帮助 Cocos 越做越好。引擎有 Bug？提 PR！范例难看？提 PR！API 注释不清晰？提 PR！文档有错别字？提 PR！想要把你的宝贵修改贡献给游戏社区？提 PR！以下几个是目前官方比较常用的开源仓库，这些仓库都可以提交 PR。 JavaScript 引擎：https://github.com/cocos-creator/engine/tree/3d Cocos2d-x-lite 引擎：https://github.com/cocos-creator/cocos2d-x-lite jsb-adapter：https://github.com/cocos-creator-packages/jsb-adapter 下面让我们来看一下，如何从零开始在 GitHub 上向 Cocos 提交代码。 注册一个 GitHub 账号 打开 GitHub 网站 注册账号。若之前已经有注册过，那直接登录就可以了。 环境配置 安装 Git 首先先确认电脑是否已经安装 Git，命令行输入 git，安装过则会输出以下内容： 未安装过则 下载 Git 并安装。安装过程中的所有选项保留默认就可以了，一直点 next，直到安装完成。 安装 Git 客户端 —— GitKraken GitKraken 是比较常用的 Git 客户端工具。如果不使用 GitKraken 的话，Git 操作全部要通过命令行操作完成，比较麻烦。下面以 Windows 版本为例进行演示。 1、下载 GitKraken 并解压缩，进行安装。 安装完成后界面如下图所示： Fork 项目 以手册文档的代码仓库 docs-3d 为例。进入手册文档仓库页面，点击右上角的 Fork 按钮，如下图所示： Fork 完成后，会自动跳转到你的 GitHub 仓库页面，可以看到已经生成了 docs-3d 项目副本，如下图所示： 将远程仓库克隆到本地仓库 1、首先需要到你的远程仓库复制 远程仓库项目地址，如下图所示： 2、切换到 GitKraken 后点击上方的 Clone a repo 按钮，跳转到 Clone 页面，粘贴刚才复制的 远程仓库项目地址，然后填入相关配置。如果想让本地的文件夹名称和项目名称一样，那么在本地存储路径后添加 /docs-3d。配置完成后点击 Clone。 克隆完成后就会在本地自动创建 docs-3d 文件夹并且在 GitKraken 上自动打开项目。 上传本地修改到远程仓库 1、检出需要的分支。在左侧的 REMOTE 目录下有一个 origin 仓库，这是你自己的远程仓库。例如要修改的分支是 next 分支，则点击 origin 后双击 next 分支。如下图所示： 注意：根据不同的版本，还需要切换不同的分支，例如： vX.Y 分支：对应 X.Y 版本所用分支 next 分支： 用于 2.0 分支 master/develop 分支：当前最新版本所用分支 2、打开本地 docs-3d 项目进行修改，修改完成后查看仓库详情，如下图所示： 3、提交暂存区文件到本地仓库。将你要上传的修改文件提交到本地暂存区，然后在下方备注提交内容注释。完成之后点击 Commit，将暂存区文件提交到本地仓库。完成后点击 Push 。步骤如下图所示： 4、将本地仓库的修改推送到自己的远程仓库 origin。 5、完成之后，到 GitHub 自己的 docs-3d 远程仓库查看（可以从 右上方的头像 -> Your profile -> Repositories -> docs-3d 进入你的远程仓库），可以看到已经有本次的提交信息了。然后点击 New pull request。 6、点击 New pull request 后会跳转到官方仓库的 Open a pull request。标题会自动填入刚才提交的信息，也可自行修改。下方的填写信息区域需要对提交内容进行适当的补充。特别是针对引擎本身的修改，请将问题描述、改动内容、涉及版本、相关平台等信息补充完整。如果有相关 Issue，或者论坛地址也可以贴上来。最下方的是本次提交的 PR 的改动详情。填写完成后点击 Create pull request。 7、创建完成后在官方仓库 docs-3d 的 pull requests 页面中可以看到创建了一个新的 PR。官方人员会收到提醒并将 PR 指派给相关人员进行 review 和合并。到此 PR 创建完成，若官方审核通过，就会把这个 PR 的修改合并到官方仓库中了。如果上方的Open图标变为Merged图标，则表示修改已合并到官网。若官方觉得有需要，也会在该 PR 上展开进一步讨论。请留意 GitHub 相关消息或关注 PR 所在页面，以免错过讨论。如果你需要修改 PR 提交的内容，请重复 上传本地修改到远程仓库 中的 2、3、4 步骤。 添加官方仓库 如果距离上次克隆仓库已经挺长时间，那么请在提交 PR 前先从官方仓库获取最新的修改以防和其他人的修改发生冲突。 1、添加官方仓库。点击 GitKraken 左边列表的 REMOTE + ，如下图所示： 2、在 GitKraken 的 docs-3d 本地仓库的左侧，可以看到有 origin 和 cocos-creator3D 两个远程仓库，分别是自己的远程仓库和官方仓库。可以看到 远程 -> cocos-creator3D 下已经有了官方仓库的各个分支，如下图所示： 3、从官方仓库拉取最新更新。切换到要拉取的分支，然后点击左上方的 Pull。如下图所示： 注意：在更新官方版本前，如果你完全不熟悉 Git 的操作，建议先确保没有在本地的 Git 仓库中进行任何文件的改动。如果有的话，建议先手动还原，然后等更新完毕后再手动把改动添加回来。 如何反馈文档有关的问题 针对文档本身的问题，建议通过 GitHub issue 进行反馈，下面我们简单演示一下。在提交问题之前请先确认： 文档版本和 Creator 3D 版本是否一致 操作步骤是否正确 是否是文档本身的问题，例如代码错误或者根据文档步骤执行出现异常等。 若以上问题都是确定的，那么，有以下两种提交方式： 1、可在 creator 3D 官方文档的右下方点击 提交反馈 进入提交 issue 界面。 填写完成后点击 Submit new issue 提交 issue，就完成了。 2、或者也可以进入官方仓库 docs-3d，选择 Issue -> New issue 进入提交 issue 界面，填写内容并提交。 本次提交 pr 和提交 issue 的教程到这里就结束了，若有不理解或者有误的地方请根据上述步骤向我们反馈。 有些人可能会问，为什么要这么麻烦的提交问题。其实，正确的提交问题可以节省很多的沟通成本，而且有些问题可能在初步排查的时候就可以解决了，或者会发现只是由于自己粗心大意导致的。而官方节省下来的人力就可以更好的去服务于 Creator 3D ，让 Creator 3D 能更好地为游戏开发者服务。 "}}